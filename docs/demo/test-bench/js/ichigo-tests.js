(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./Css/CssInlineRule"));
__export(require("./Css/CssRule"));
__export(require("./Css/CssRuleContract"));
__export(require("./Css/CssVariable"));
__export(require("./Css/GetCssRulesInElement"));
__export(require("./Html/CreateElement"));
__export(require("./Html/DeleteNodeContent"));
__export(require("./Html/ElementType"));
__export(require("./Html/EscapeHtml"));
__export(require("./Html/FindIndexInParent"));
__export(require("./Html/FormFieldValue"));
__export(require("./Html/ExtractNodeContent"));
__export(require("./Html/QuerySelectorNodeList"));
__export(require("./Html/ValidateUniqueDomIds"));
__export(require("./HtmlComponent/BoundComponent"));
__export(require("./HtmlComponent/Component"));
__export(require("./HtmlComponent/ComponentMap"));
__export(require("./HtmlComponent/Options/IExistingElementOptions"));
__export(require("./HtmlComponent/Options/IInnerHtmlOptions"));
__export(require("./HtmlComponent/Options/IExistingLookupOptions"));
__export(require("./HtmlComponent/Options/IOuterHtmlOptions"));
__export(require("./HtmlComponent/Options/IComponentBindingOptions"));
__export(require("./Observable/IObservable"));
__export(require("./Observable/ObservableAssign"));
__export(require("./Observable/ObservableBase"));
__export(require("./Observable/ObservableProperty"));
__export(require("./Observable/ObservableProxy"));
__export(require("./Observable/ObservableState"));
__export(require("./Router/PageRouter"));
__export(require("./Router/AdvancedPageRouter"));
__export(require("./System/Async/DynamicWebWorker"));
__export(require("./System/Async/DeferredPromise"));
__export(require("./System/Async/Delay"));
__export(require("./System/Async/RepeatablePromise"));
__export(require("./System/Collections/ArrayUtilities"));
__export(require("./System/Collections/OrderBy"));
__export(require("./System/EventHandler/ArrayChangedEventArgs"));
__export(require("./System/EventHandler/Delegate"));
__export(require("./System/EventHandler/EventHandler"));
__export(require("./System/EventHandler/PropertyChangedEventArgs"));
__export(require("./System/Types/Constructable"));
__export(require("./System/Types/KeywordArguments"));
__export(require("./System/Types/NoneType"));
__export(require("./System/Utility/Assert"));
__export(require("./System/Utility/CloneDeep"));
__export(require("./System/Utility/CloneObject"));
__export(require("./System/Utility/Elvis"));
__export(require("./System/Utility/IsInteger"));
__export(require("./System/Utility/IsPrimitive"));
__export(require("./System/Utility/GetUniqueId"));
__export(require("./System/Utility/ObjectFullAssign"));

},{"./Css/CssInlineRule":2,"./Css/CssRule":3,"./Css/CssRuleContract":4,"./Css/CssVariable":6,"./Css/GetCssRulesInElement":7,"./Html/CreateElement":12,"./Html/DeleteNodeContent":13,"./Html/ElementType":14,"./Html/EscapeHtml":15,"./Html/ExtractNodeContent":16,"./Html/FindIndexInParent":17,"./Html/FormFieldValue":18,"./Html/QuerySelectorNodeList":19,"./Html/ValidateUniqueDomIds":20,"./HtmlComponent/BoundComponent":21,"./HtmlComponent/Component":22,"./HtmlComponent/ComponentMap":23,"./HtmlComponent/Options/IComponentBindingOptions":24,"./HtmlComponent/Options/IExistingElementOptions":25,"./HtmlComponent/Options/IExistingLookupOptions":26,"./HtmlComponent/Options/IInnerHtmlOptions":27,"./HtmlComponent/Options/IOuterHtmlOptions":28,"./Observable/IObservable":29,"./Observable/ObservableAssign":34,"./Observable/ObservableBase":35,"./Observable/ObservableProperty":36,"./Observable/ObservableProxy":37,"./Observable/ObservableState":38,"./Router/AdvancedPageRouter":39,"./Router/PageRouter":40,"./System/Async/DeferredPromise":41,"./System/Async/Delay":42,"./System/Async/DynamicWebWorker":43,"./System/Async/RepeatablePromise":44,"./System/Collections/ArrayUtilities":45,"./System/Collections/OrderBy":46,"./System/EventHandler/ArrayChangedEventArgs":47,"./System/EventHandler/Delegate":48,"./System/EventHandler/EventHandler":49,"./System/EventHandler/PropertyChangedEventArgs":50,"./System/Types/Constructable":51,"./System/Types/KeywordArguments":52,"./System/Types/NoneType":53,"./System/Utility/Assert":54,"./System/Utility/CloneDeep":55,"./System/Utility/CloneObject":56,"./System/Utility/Elvis":57,"./System/Utility/GetUniqueId":58,"./System/Utility/IsInteger":59,"./System/Utility/IsPrimitive":60,"./System/Utility/ObjectFullAssign":61}],2:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CssRule_1 = require("./CssRule");
/**
 * A simple, default Css Rule that is with an inline initializer in the constructor, useful for quick and dirty inline classes.
 */
class CssInlineRule extends CssRule_1.CssRule {
    constructor(selector, initial, parent) {
        super(parent);
        Object.assign(this, initial);
        this.selector$ = selector;
    }
}
exports.CssInlineRule = CssInlineRule;

},{"./CssRule":3}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ElementType_1 = require("../Html/ElementType");
const CreateElement_1 = require("../Html/CreateElement");
const Constructable_1 = require("../System/Types/Constructable");
const GetUniqueId_1 = require("../System/Utility/GetUniqueId");
const CssVariable_1 = require("./CssVariable");
/**
 * A Javascript CSS rule. Note the capitalization. This isn't the same as CSSRule. I'm considering renaming this to
 * CssJsRule but I'm hoping I think up something better. It has to be more generic than CssClass because, well, there's
 * more to CSS than class selectors.
 */
class CssRule {
    constructor(parent) {
        /** Storing this somewhere other than the HEAD would make it easy to drop the sheet on page change. */
        this.styleSheetParent$ = document.head;
        this.styleSheetId$ = GetUniqueId_1.getUniqueId();
        this.extends$ = [];
        this.nested$ = [];
        this.revert$ = false;
        this._constructed$ = false;
        this._selectors$ = [];
        if (parent) {
            this.styleSheetParent$ = parent;
        }
    }
    render$(parentSelector) {
        if (!this._constructed$) {
            // Remember, we cannot read properties of this in the constructor, because their population is emitted
            // after the super() call. But we don't want to clone this object and repeat this every time it's rendered.
            this._constructed$ = true;
            if (this.revert$) {
                this.all = "initial";
            }
            this._extendClass$();
            if (this.nested$) {
                if (!Array.isArray(this.nested$)) {
                    this.nested$ = [this.nested$];
                }
                for (const [idx, nest] of this.nested$.entries()) {
                    if (Constructable_1.constructorTypeGuard(nest)) {
                        this.nested$[idx] = new nest(this.styleSheetParent$);
                    }
                }
            }
            this._buildSelectors$(parentSelector);
        }
        // This creates a separate style element for each rule. That might seem pretty excessive, but it's the only way
        // to make it easy to update rules. The API for dealing with CSS in HTML5 is NAAAAAAASTY.
        let styleElement = this.styleSheetParent$.querySelector('#' + this.styleSheetId$);
        if (styleElement) {
            this.styleSheetParent$.removeChild(styleElement);
        }
        styleElement = this.styleSheetParent$.appendChild(CreateElement_1.createElement(ElementType_1.elementType.HTMLStyleElement, { id: this.styleSheetId$ }));
        const sheet = styleElement.sheet;
        this._buildRule$(sheet);
        if (this.nested$) {
            // We previously made this an array of constructed types.
            for (const nest of this.nested$) {
                nest.styleSheetParent$ = this.styleSheetParent$;
                for (const sel of this._selectors$) {
                    nest.render$(sel);
                }
            }
        }
        return this;
    }
    remove$() {
        const styleElement = this.styleSheetParent$.querySelector('#' + this.styleSheetId$);
        if (styleElement) {
            this.styleSheetParent$.removeChild(styleElement);
        }
    }
    /**
     * Implement "multiple inheritance".
     *
     * This checks only CSS properties. If you inherit from other CssRule classes that
     * themselves have extends$ set, those are not checked. I don't think there's enough
     * justification to bring recursion into this.
     *
     * Note that priority is in the opposite direction of normal inheritance priority.
     * Normally, when looking for a property, the runtime traverses the inheritance tree
     * and uses the first occurrence. In CSS, the LAST occurance takes priority.
     */
    _extendClass$() {
        if (!this.extends$) {
            return;
        }
        if (!Array.isArray(this.extends$)) {
            this.extends$ = [this.extends$];
        }
        for (const ex of this.extends$) {
            let traitSource;
            if (Constructable_1.constructorTypeGuard(ex)) {
                traitSource = new ex();
            }
            else {
                traitSource = ex;
            }
            const names = Array.from(new Set(findPropertyNames(traitSource)));
            for (const key of names) {
                // Filter out names with special meaning
                if (key.endsWith('$')) {
                    continue;
                }
                this[key] = traitSource[key];
            }
        }
    }
    _buildSelectors$(parentSelector) {
        parentSelector = (parentSelector || '');
        // If scopeElement$ is set, <style scoped> is simulated in a hacky way. It generates an random class name and adds
        // that to both the selector and the element. This similar to the way CSS Modules and Angular do it, except the
        // random selector comes during runtime instead of a custom build process.
        if (this.scopeElement$ && !this._fakeScopeClass$) {
            this._fakeScopeClass$ = this._fakeScopeClass$ || 'scope-' + GetUniqueId_1.getUniqueId();
            this.scopeElement$.classList.add(this._fakeScopeClass$);
        }
        for (let sel of this.selector$.split(',').map(m => m.trim())) {
            sel = (sel || '').replace('&', ''); // Ampersand tells us where to start (allows a space) but it's invalid CSS
            if (this._fakeScopeClass$) {
                if (!sel) {
                    this._selectors$.push(parentSelector + '.' + this._fakeScopeClass$);
                }
                else {
                    // produce an id like "div.autogen .otherclass, .autogen div .otherclass"
                    const words = sel.split(' ');
                    words[0] = parentSelector + words[0] + '.' + this._fakeScopeClass$;
                    this._selectors$.push(words.join(' ').trim());
                    // There is no CSS selector that matches an item and its children. It takes 2 rules.
                    this._selectors$.push((parentSelector + '.' + this._fakeScopeClass$ + ' ' + sel).trim());
                }
            }
            else if (!sel) {
                // A blank selector will fail
                if (parentSelector) {
                    this._selectors$.push(parentSelector);
                }
                else {
                    this._selectors$.push('body');
                }
            }
            else {
                this._selectors$.push(parentSelector + sel);
            }
        }
    }
    _buildRule$(sheet) {
        const ruleText = [];
        const variables = [];
        const names = Array.from(new Set(findPropertyNames(this)));
        for (const key of names) {
            // Filter out names with special meaning
            if (key.endsWith('$') || !this[key] || typeof this[key] === 'function') {
                continue;
            }
            // If Typescript was working correctly, we know that all properties that don't end in $ are RuleValue type.
            const val = this[key];
            if (typeof val === 'string') {
                ruleText.push(`${key}: ${val}`);
            }
            else if (val instanceof CssVariable_1.CssVariable) {
                variables.push(val);
                ruleText.push(`${key}: var(--${val.name})`);
            }
            else {
                // Nested properties, which extend the key and add more rules
                for (const np of Object.getOwnPropertyNames(val)) {
                    // Should never happen
                    if (np.endsWith('$')) {
                        continue;
                    }
                    const vp = val[np];
                    if (typeof vp === 'string') {
                        ruleText.push(`${key}-${np}: ${vp}`);
                    }
                    else {
                        variables.push(vp);
                        ruleText.push(`${key}-${np}: var(--${val.name})`);
                    }
                }
            }
        }
        const fullSelector = this._selectors$.join(', ');
        const fullText = ruleText.join('; \n');
        if (!fullText) {
            // tslint:disable-next-line:no-console
            console.warn(`No CSS properties defined for rule: ${this.constructor.name} on ${fullSelector}.`);
        }
        let fullRule = `${fullSelector} { \n${fullText}; \n}`;
        if (this.media$) {
            fullRule = `@media ${this.media$} { \n${fullRule}\n}`;
        }
        sheet.insertRule(fullRule, 0);
        // Add all the variable values
        let i = 1;
        for (const v of variables) {
            const varText = `${v.scope} { --${v.name}: ${v.value}; }`;
            sheet.insertRule(varText, i);
            i++;
        }
    }
}
exports.CssRule = CssRule;
function findPropertyNames(obj) {
    const result = [];
    result.push(...Object.getOwnPropertyNames(obj).filter(f => f !== 'constructor'));
    const proto = Object.getPrototypeOf(obj);
    if (proto && proto.constructor.name !== 'Object') {
        result.push(...findPropertyNames(proto));
    }
    return result;
}

},{"../Html/CreateElement":12,"../Html/ElementType":14,"../System/Types/Constructable":51,"../System/Utility/GetUniqueId":58,"./CssVariable":6}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This type is here for a bullshit reason, which is that if you want to require values to be all strings, this copypasta
 * must be included in the definition of the class. That's going far beyond time checking.
 * https://github.com/microsoft/TypeScript/issues/15300 (not just interfaces)
 */
class CssSimpleRule {
    constructor(initial) {
        if (initial) {
            Object.assign(this, initial);
        }
    }
}
exports.CssSimpleRule = CssSimpleRule;

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Constructable_1 = require("../System/Types/Constructable");
class CssStyleSheet {
    constructor(rules, parent) {
        this.rules = [];
        if (rules) {
            for (const rule of rules) {
                if (Constructable_1.constructorTypeGuard(rule)) {
                    this.rules.push(new rule(parent));
                }
                else {
                    rule.styleSheetParent$ = parent || rule.styleSheetParent$;
                    this.rules.push(rule);
                }
            }
        }
    }
    render() {
        for (const rule of this.rules) {
            rule.render$();
        }
    }
    remove() {
        for (const rule of this.rules) {
            rule.remove$();
        }
    }
}
exports.CssStyleSheet = CssStyleSheet;

},{"../System/Types/Constructable":51}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Use to define a CSS custom property.
 */
class CssVariable {
    constructor(name, value, scope = ':root') {
        this.scope = ':root';
        this.name = name;
        this.value = value;
        this.scope = scope;
    }
}
exports.CssVariable = CssVariable;

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getCssRulesInElement(element) {
    const result = [];
    for (const style of element.querySelectorAll('style')) {
        for (const rule of style.sheet.cssRules) {
            // A very minimum of pretty printing. I may beef it up later.
            result.push(rule.cssText.replace(/\{/g, '\n    {\n   ').replace(/;/g, ';\n    '));
        }
    }
    return result.join('\n');
}
exports.getCssRulesInElement = getCssRulesInElement;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * This script contains extensions to provide additional functions used by Ichigo.
 * In your main process, import this script (import '/path/to/Ichigo/IchigoExtensionLoader') to add
 * these extensions to prototypes.
 */
require("./Extensions/ObservableExtensions");
require("./Extensions/ComponentExtensions");
require("./Extensions/ElementExtensions");

},{"./Extensions/ComponentExtensions":9,"./Extensions/ElementExtensions":10,"./Extensions/ObservableExtensions":11}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IComponentBindingOptions_1 = require("../HtmlComponent/Options/IComponentBindingOptions");
const BoundComponent_1 = require("../HtmlComponent/BoundComponent");
const ComponentMap_1 = require("../HtmlComponent/ComponentMap");
HTMLElement.prototype.getComponent = function _getComponent() {
    return ComponentMap_1.ComponentMap.components.get(this);
};
HTMLElement.prototype.bindComponent = function _bind(viewModel) {
    return new BoundComponent_1.BoundComponent(viewModel, new IComponentBindingOptions_1.ExistingElementBindingOptions({ element: this }));
};
HTMLElement.prototype.deleteComponent = function _deleteComponent() {
    const component = ComponentMap_1.ComponentMap.components.get(this);
    if (!component) {
        // tslint:disable-next-line:no-console
        console.error('Not a component');
        return;
    }
    if (component instanceof BoundComponent_1.BoundComponent) {
        component.dispose();
    }
    const parent = this.parentNode || document;
    parent.removeChild(this);
};

},{"../HtmlComponent/BoundComponent":21,"../HtmlComponent/ComponentMap":23,"../HtmlComponent/Options/IComponentBindingOptions":24}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CreateElement_1 = require("../Html/CreateElement");
/**
 * Set the parent for an element (join the parent's family as a new child), the opposite of appendChild. Fluent, for chaining, so
 * it's not a perfect analog (appendChild returns the argument while this returns the extended object ... though both are the child).
 */
HTMLElement.prototype.appendToParent = function _appendToParent(parent) {
    parent.appendChild(this);
    return this;
};
/**
 * Fluent version of appendChild, which returns the parent, not the child (the argument).
 */
HTMLElement.prototype.appendChildFluent = function _appendChildFluent(child) {
    this.appendChild(child);
    return this;
};
/**
 * Add the element after the current item, at the same level. Not fluent, so this is the same pattern as appendChild.
 */
HTMLElement.prototype.appendSibling = function _appendSibling(next) {
    const parent = this.parentNode || document;
    return parent.appendChild(next);
};
/**
 * Add the element after the current item, at the same level. Fluent.
 */
HTMLElement.prototype.appendSiblingFluent = function _appendSiblingFluent(next) {
    const parent = this.parentNode || document;
    parent.appendChild(next);
    return this;
};
/**
 * Replace the element. Not fluent, so this is the same pattern as appendChild. There is no fluent version because
 * this is deleting the extended object.
 */
HTMLElement.prototype.replaceWith = function _replaceWith(newElement) {
    const parent = this.parentNode || document;
    parent.replaceChild(newElement, this);
    return newElement;
};
/**
 * Swap two elements from their places in the DOM, returning the argument.
 */
HTMLElement.prototype.swap = function _swap(element) {
    const parent = this.parentNode || document;
    const elementParent = element.parentNode || document;
    const placeHolder = document.createElement('span');
    elementParent.replaceChild(placeHolder, element);
    parent.replaceChild(element, this);
    elementParent.replaceChild(this, placeHolder);
    return element;
};
/**
 * A wrapper around document.removeChild that uses the same API as the other functions here.
 * Included for the sake of consistency.
 */
HTMLElement.prototype.extract = function _extract() {
    const parent = this.parentNode || document;
    return parent.removeChild(this);
};
/**
 * Fluent version of addEventListener.
 */
HTMLElement.prototype.addEventListenerFluent = function _addEventListenerFluent(eventType, event, options) {
    this.addEventListener(eventType, event, options);
    return this;
};
/**
 * Fluent style adder.
 */
HTMLElement.prototype.addStyle = function _addStyle(property, value) {
    this.style.setProperty(property, value);
    return this;
};
/**
 * Fluent class adder.
 */
HTMLElement.prototype.addClass = function _addClass(classNames) {
    if (!Array.isArray(classNames)) {
        classNames = [classNames];
    }
    // Need to also allow classes in the "class1 class2" format
    for (const c of [].concat(...classNames
        .map(q => q.split(' '))
        .filter(q => q))) {
        this.classList.add(c);
    }
    return this;
};
/**
 * Create an element using the createElement helper function and add it to the fragment, returning the new element.
 */
DocumentFragment.prototype.createElement = function _createElement(tagName, properties, attributes) {
    const element = CreateElement_1.createElement(tagName, properties);
    this.appendChild(element);
    return element;
};
/**
 * Create an element using the createElement helper function and add it to the fragment. Fluent version, so it's easy to quickly add
 * a bunch of elements to the fragment.
 */
DocumentFragment.prototype.createElementFluent = function _createElementFluent(tagName, properties, attributes) {
    const element = CreateElement_1.createElement(tagName, properties);
    this.appendChild(element);
    return this;
};
/**
 * Take a document fragment and add its contents to a parent element. Cannot be fluent because at this point, the fragment is empty and
 * pretty useless, so this returns the parent argument (as good as any other option).
 */
DocumentFragment.prototype.appendToParent = function _appendToParent(parent) {
    parent.appendChild(this);
    return parent;
};

},{"../Html/CreateElement":12}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ObservableProperty_1 = require("../Observable/ObservableProperty");
/**
 * Quickly convert an object to a ObservableProperty.
 */
Object.prototype.toObservable = function (name) {
    return new ObservableProperty_1.ObservableProperty(this, { name });
};
/**
 * Quickly convert a string to an ObservableProperty.
 */
String.prototype.toObservable = function (name) {
    return new ObservableProperty_1.ObservableProperty(this, { name });
};
/**
 * Quickly convert a number to a ObservableProperty.
 */
Number.prototype.toObservable = function (name) {
    return new ObservableProperty_1.ObservableProperty(this, { name });
};
/**
 * Quickly convert a bool to a ObservableProperty.
 */
Boolean.prototype.toObservable = function (name) {
    return new ObservableProperty_1.ObservableProperty(this, { name });
};

},{"../Observable/ObservableProperty":36}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const KeywordArguments_1 = require("../System/Types/KeywordArguments");
const ElementType_1 = require("./ElementType");
const ExtractNodeContent_1 = require("./ExtractNodeContent");
function createElement(tagName, properties = {}, attributes) {
    ({ tagName, properties = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ tagName, properties, attributes })); // kwargline
    // Allow attributes to be sent on properties, providing a cleaner interface.
    // It allows you to send createElement('div', {attributes: { class: 'foo' }}) instead of createElement('div', null, { class: 'foo' });
    // Another option is to use Kwargs, but not everyone wants to.
    if (properties && 'attributes' in properties) {
        attributes = Object.assign(attributes || {}, properties.attributes);
        delete properties.attributes;
    }
    return create(tagName, properties, attributes);
}
exports.createElement = createElement;
function create(tag, properties = {}, attributes) {
    const element = (document.createElement(tag));
    if (attributes) {
        for (const attr of Object.getOwnPropertyNames(attributes)) {
            element.setAttribute(attr, attributes[attr]);
        }
    }
    // DOM properties take precedence over attributes, because in some cases, they override the initial value.
    Object.assign(element, properties);
    return element;
}
/**
 * Quick helper to create HTML from any HTML element provided.
 * Use like const div = createHtml<HTMLDivElement>("<div>Something</div>") or const custom = createHtml("<some-tag></some-tag>").
 * If multiple elements or a plain text string with no HTML is provided, then it will be wrapped in a div, so it can keep
 * returning an HTMLElement
 */
function createHtml(html, inline = false) {
    let wrapper;
    if (inline) {
        wrapper = span((html || '').trim());
    }
    else {
        wrapper = div((html || '').trim());
    }
    const nodes = wrapper.childNodes;
    // Multiple nodes, return the wrapping div
    // e.g. "This is a <em>test</em>" or "<div>Hello</div><div>World</div>"
    if (nodes.length !== 1) {
        return wrapper;
    }
    // If just a textnode (or empty), return a span. Text is incompatible with HTMLElement so can't return that
    // e.g. "Hello world"
    if (!wrapper.firstElementChild) {
        if (inline) {
            return wrapper; // This is a span
        }
        else {
            return span(wrapper.innerHTML);
        }
    }
    // Else return the single child.
    // e.g. "<div><div>Hello</div><div>World</div></div>"
    return wrapper.firstElementChild;
}
exports.createHtml = createHtml;
/**
 * Quick helper to create a document fragment with any html.
 */
function createFragment(html) {
    const wrapper = div((html || '').trim());
    return ExtractNodeContent_1.extractNodeContent(wrapper);
}
exports.createFragment = createFragment;
function div(htmlOrProperties = "", propertiesOrAttributes = {}, attributes) {
    ({ htmlOrProperties = "", propertiesOrAttributes = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ htmlOrProperties, propertiesOrAttributes, attributes })); // kwargline
    return _internal(ElementType_1.elementType.HTMLDivElement, htmlOrProperties, propertiesOrAttributes, attributes);
}
exports.div = div;
function span(htmlOrProperties = "", propertiesOrAttributes = {}, attributes) {
    ({ htmlOrProperties = "", propertiesOrAttributes = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ htmlOrProperties, propertiesOrAttributes, attributes })); // kwargline
    return _internal(ElementType_1.elementType.HTMLSpanElement, htmlOrProperties, propertiesOrAttributes, attributes);
}
exports.span = span;
function paragraph(htmlOrProperties = "", propertiesOrAttributes = {}, attributes) {
    ({ htmlOrProperties = "", propertiesOrAttributes = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ htmlOrProperties, propertiesOrAttributes, attributes })); // kwargline
    return _internal(ElementType_1.elementType.HTMLParagraphElement, htmlOrProperties, propertiesOrAttributes, attributes);
}
exports.paragraph = paragraph;
function anchor(htmlOrProperties = "", hrefOrProperties = {}, propertiesOrAttributes = {}, attributes) {
    ({ htmlOrProperties = "", hrefOrProperties = {}, propertiesOrAttributes = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ htmlOrProperties, hrefOrProperties, propertiesOrAttributes, attributes })); // kwargline
    const tmp = _internal(ElementType_1.elementType.HTMLAnchorElement, htmlOrProperties, propertiesOrAttributes, attributes);
    if (typeof hrefOrProperties === 'string') {
        tmp.href = String(hrefOrProperties || '');
    }
    return tmp;
}
exports.anchor = anchor;
function button(htmlOrProperties = "", propertiesOrAttributes = {}, attributes) {
    ({ htmlOrProperties = "", propertiesOrAttributes = {}, attributes } = KeywordArguments_1.Kwarg.parseArgs({ htmlOrProperties, propertiesOrAttributes, attributes })); // kwargline
    return _internal(ElementType_1.elementType.HTMLButtonElement, htmlOrProperties, propertiesOrAttributes, attributes);
}
exports.button = button;
// Common private functions for overloads. Prevents lots of copypasta.
// This works for everything because TypeScript is keeping the types valid. In pure JS, bugs could be created (for example, passing an inner
// element to a paragraph ... disallowed by TS but the code is there in the JS)
function _internal(type, htmlOrProperties = "", propertiesOrAttributes = {}, attributes) {
    if (htmlOrProperties instanceof HTMLElement) {
        return _ovr1(type, htmlOrProperties, propertiesOrAttributes, attributes);
    }
    else if (typeof htmlOrProperties === "object") {
        return _ovr3(type, htmlOrProperties, propertiesOrAttributes);
    }
    else {
        return _ovr2(type, String(htmlOrProperties || ''), propertiesOrAttributes, attributes);
    }
}
function _ovr1(type, innerElement, props, attrs) {
    const e = createElement(type, props, attrs);
    e.appendChild(innerElement);
    return e;
}
function _ovr2(type, innerHtml, props, attrs) {
    props = props || {};
    props.innerHTML = innerHtml;
    return createElement(type, props, attrs);
}
function _ovr3(type, props, attrs) {
    props = props || {};
    props.innerHTML = props.innerHTML || '';
    return createElement(type, props, attrs);
}

},{"../System/Types/KeywordArguments":52,"./ElementType":14,"./ExtractNodeContent":16}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Delete the contents of any html node.
 */
function deleteNodeContent(node) {
    const range = document.createRange();
    range.selectNodeContents(node);
    range.deleteContents();
}
exports.deleteNodeContent = deleteNodeContent;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A helper for CreateElement, roughly mapping to HtmlElement types, but not perfectly because it's impossible
 * (there's no perfect 1:1 relationship).
 */
var elementType;
(function (elementType) {
    elementType["HTMLAnchorElement"] = "a";
    elementType["HTMLAreaElement"] = "area";
    elementType["HTMLAudioElement"] = "audio";
    elementType["HTMLBRElement"] = "br";
    elementType["HTMLBaseFontElement"] = "basefont";
    elementType["HTMLBlockQuoteElement"] = "blockquote";
    elementType["HTMLButtonElement"] = "button";
    elementType["HTMLCanvasElement"] = "canvas";
    elementType["HTMLDataElement"] = "data";
    elementType["HTMLDataListElement"] = "datalist";
    elementType["HTMLDialogElement"] = "dialog";
    elementType["HTMLDivElement"] = "div";
    elementType["HTMLDListElement"] = "dl";
    elementType["HTMLEmbedElement"] = "embed";
    elementType["HTMLFieldSetElement"] = "fieldset";
    elementType["HTMLFormElement"] = "form";
    elementType["HTMLHeading1Element"] = "h1";
    elementType["HTMLHeading2Element"] = "h2";
    elementType["HTMLHeading3Element"] = "h3";
    elementType["HTMLHeading4Element"] = "h4";
    elementType["HTMLHeading5Element"] = "h5";
    elementType["HTMLHeading6Element"] = "h6";
    elementType["HTMLHRElement"] = "hr";
    elementType["HTMLImageElement"] = "image";
    elementType["HTMLInputElement"] = "input";
    elementType["HTMLLabelElement"] = "label";
    elementType["HTMLLegendElement"] = "legend";
    elementType["HTMLLIElement"] = "li";
    elementType["HTMLLinkElement"] = "link";
    elementType["HTMLMapElement"] = "map";
    elementType["HTMLMeterElement"] = "meter";
    elementType["HTMLModDelElement"] = "del";
    elementType["HTMLModInsElement"] = "ins";
    elementType["HTMLOListElement"] = "ol";
    elementType["HTMLObjectElement"] = "object";
    elementType["HTMLOptGroupElement"] = "optgroup";
    elementType["HTMLOptionElement"] = "option";
    elementType["HTMLOutputElement"] = "output";
    elementType["HTMLParagraphElement"] = "p";
    elementType["HTMLParamElement"] = "param";
    elementType["HTMLPictureElement"] = "picture";
    elementType["HTMLPreElement"] = "pre";
    elementType["HTMLProgressElement"] = "progress";
    elementType["HTMLQuoteElement"] = "q";
    elementType["HTMLScriptElement"] = "script";
    elementType["HTMLSelectElement"] = "select";
    elementType["HTMLSourceElement"] = "source";
    elementType["HTMLSpanElement"] = "span";
    elementType["HTMLStyleElement"] = "style";
    elementType["HTMLTableCaptionElement"] = "caption";
    elementType["HTMLTableDataCellElement"] = "td";
    elementType["HTMLTableHeaderCellElement"] = "th";
    elementType["HTMLTableColElement"] = "col";
    elementType["HTMLTableColGroupElement"] = "colgroup";
    elementType["HTMLTableElement"] = "table";
    elementType["HTMLTableRowElement"] = "tr";
    elementType["HTMLTableSectionBodyElement"] = "tbody";
    elementType["HTMLTableSectionFooterElement"] = "tfoot";
    elementType["HTMLTableSectionHeaderElement"] = "thead";
    elementType["HTMLTemplateElement"] = "template";
    elementType["HTMLTextAreaElement"] = "textarea";
    elementType["HTMLTimeElement"] = "time";
    elementType["HTMLTrackElement"] = "track";
    elementType["HTMLUListElement"] = "ul";
    elementType["HTMLVideoElement"] = "video";
})(elementType = exports.elementType || (exports.elementType = {}));

},{}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function escapeHtml(input) {
    // There isn't a built-in way to do this, still, so we need a helper function.
    // The article "You are probably misusing DOM text methods" convinced me to do it this way,
    // vs. createTextNode. Though createTextNode would probably work fine for setting innerHTML.
    if (!input) {
        return input;
    }
    const escapes = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "/": "&#x2F;",
        "=": "&#x3D;",
        '"': "&quot;",
        "'": "&#39;",
        "`": "&#x60;"
    };
    return input.replace(/[&<>"'`=\/]/g, s => escapes[s]);
}
exports.escapeHtml = escapeHtml;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Get the contents of any html node as a DocumentFragment.
 */
function extractNodeContent(node) {
    const range = document.createRange();
    range.selectNodeContents(node);
    return range.extractContents();
}
exports.extractNodeContent = extractNodeContent;

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function findIndexInParent(element) {
    const parent = element.parentElement;
    if (parent) {
        return Array.from(parent.children).indexOf(element);
    }
}
exports.findIndexInParent = findIndexInParent;

},{}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NoneType_1 = require("../System/Types/NoneType");
/**
 * HTML is inconsistent. Getting the value of form fields is a bit complicated, not always element.value,
 * so here's a helper to make it easier.
 */
function getFormFieldValue(element) {
    // It would be really nice at this point if JS could see generic parameters.
    // If it could, then the code could say "if (input.type === 'checkbox' && TOutput !== boolean) throw new Error()"
    if (element.tagName.toLowerCase() === 'input') {
        const input = element;
        if (input.type.toLowerCase() === 'checkbox') {
            return getCheckboxValue(input);
        }
        if (input.type.toLowerCase() === 'number') {
            return getNumberInputValue(input);
        }
        else if (input.type.toLowerCase() === 'radio') {
            return getRadioValue(input);
        }
        else {
            return input.value;
        }
    }
    else if (element.tagName.toLowerCase() === 'select') {
        return getSelectValue(element);
    }
    else if (element.tagName.toLowerCase() === 'textarea') {
        return element.value;
    }
}
exports.getFormFieldValue = getFormFieldValue;
function getCheckboxValue(input) {
    return !!input.checked;
}
exports.getCheckboxValue = getCheckboxValue;
function getNumberInputValue(input) {
    if (input.value) {
        return Number(input.value);
    }
}
exports.getNumberInputValue = getNumberInputValue;
function getRadioValue(input) {
    // Radio buttons are weird. We want them to appear to be more normal.
    if (input.name) {
        return (document.querySelector(`input[name="${input.name}"]:checked`) || {}).value;
    }
    // If no name, fall back to this
    if (input.checked) {
        return input.value;
    }
}
exports.getRadioValue = getRadioValue;
function getSelectValue(select) {
    if (select.multiple) {
        return getMultiSelectValue(select);
    }
    else {
        return select.value;
    }
}
exports.getSelectValue = getSelectValue;
function getMultiSelectValue(select) {
    return Array.from(select.selectedOptions).filter(f => f.value).map(m => m.value);
}
exports.getMultiSelectValue = getMultiSelectValue;
// This is almost pointless. Just here for consistency.
function getSimpleFormValue(input) {
    if (input.tagName.toLowerCase() === 'select') {
        if (input.multiple) {
            throw new Error('Not valid for multi-selects');
        }
    }
    return input.value;
}
exports.getSimpleFormValue = getSimpleFormValue;
/**
 * Setting values is just as complicated as getting them, because HTML is inconsistent. You can't just say element.value = foo.
 * Here's a helper to make it easier.
 */
function setFormFieldValue(element, value) {
    // Here you can validate the type before setting or do some kind of conversion.
    // For multi-selects, can auto-wrap value in string.
    if (NoneType_1.isNone(value)) {
        value = '';
    }
    const stringValue = value.toString(); // used in most of the cases
    if (element.tagName.toLowerCase() === 'input') {
        const input = element;
        const type = input.type.toLowerCase();
        if (type === 'checkbox') {
            input.checked = value === true || stringValue.toLowerCase() === 'true';
        }
        else if (type === 'radio') {
            input.checked = stringValue === input.value;
        }
        else if (type === 'date') {
            if (!value) {
                return;
            }
            input.value = toDateString(new Date(stringValue));
        }
        else if (type === 'datetime' || type === 'datetime-local') {
            if (!value) {
                return;
            }
            const date = new Date(stringValue);
            if (isNaN(date.valueOf())) {
                return;
            }
            input.value = `${toDateString(date)}T${toTimeString(date)}`;
        }
        else {
            input.value = stringValue;
        }
    }
    else if (element.tagName.toLowerCase() === 'select') {
        const select = element;
        const options = Array.from(select.options);
        if (select.multiple) {
            if (!Array.isArray(value)) {
                checkOption(options, value);
                select.value = stringValue; // treating it like a non-multiple works
                return;
            }
            // Nonexistent options cannot be set. We should let the programmer know. Even though this takes CPU cycles.
            value.map(m => {
                checkOption(options, m);
            });
            for (const opt of options) {
                opt.selected = value.map(m => m.toString()).indexOf(opt.value) > -1;
            }
        }
        else {
            checkOption(options, value);
            select.value = stringValue;
        }
    }
    else if (element.tagName.toLowerCase() === 'textarea') {
        element.value = stringValue;
    }
    else {
        // tslint:disable-next-line:no-console
        console.warn(`Called setFormFieldValue on non-form field ${element.tagName} ${element.id || ''}`);
    }
    function checkOption(options, val) {
        // If you set the value of a select to something that is not an available option, nothing will happen.
        const hasOption = options.map(m => m.value).indexOf(val.toString()) > -1;
        if (!hasOption) {
            // tslint:disable-next-line:no-console
            console.warn(`Called setFormFieldValue with nonexistent option ${val.toString()} on select ${element.id}`);
        }
    }
    // These could be readable oneliners if we had padStart() but it's not worth bumping to ES2017 for one method
    function toDateString(date) {
        if (!isNaN(date.valueOf())) {
            return '';
        }
        const month = ('0' + (date.getUTCMonth() + 1).toString()).slice(-2);
        const day = ('0' + date.getUTCDate().toString()).slice(-2);
        return `${date.getUTCFullYear()}-${month}-${day}`;
    }
    function toTimeString(date) {
        if (!isNaN(date.valueOf())) {
            return '';
        }
        const hour = ('0' + date.getHours()).slice(-2);
        const minute = ('0' + date.getMinutes()).slice(-2);
        return `${hour}:${minute}`;
    }
}
exports.setFormFieldValue = setFormFieldValue;

},{"../System/Types/NoneType":53}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Here's a helper for one of the places where HTML5 falls over. If you get some html like <div id="1"></div><div id="2"></div>, it becomes
 * a NodeList. HTML5 by default does not provide a way to search this for a selector.
 */
function nodeListSelector(nodes, selector) {
    for (const node of nodes) {
        if (!('matches' in node)) {
            // Filter out text nodes
            continue;
        }
        if (node.matches(selector)) {
            return node;
        }
        const search = node.querySelector(selector);
        if (search) {
            return search;
        }
    }
}
exports.nodeListSelector = nodeListSelector;
/**
 * Here's a helper for one of the places where HTML5 falls over. If you get some html like <div id="1"></div><div id="2"></div>, it becomes
 * a NodeList. HTML5 by default does not provide a way to search this for a selector.
 */
function nodeListSelectorAll(nodes, selector) {
    // Because the browser can lose references when moving nodes, this can also take a regular array.
    // Because HTML5 has totally fallen over, it's not possible for the fixed nodeListSelectorAll
    // to match the output signature of querySelectorAll (NodeListOf<Element> instead of array).
    const results = [];
    for (const node of nodes) {
        if (!('matches' in node)) {
            // Filter out text nodes
            continue;
        }
        if (node.matches(selector)) {
            results.push(node);
        }
        const search = node.querySelectorAll(selector);
        results.push(...Array.from(search));
    }
    return results;
}
exports.nodeListSelectorAll = nodeListSelectorAll;

},{}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * If the document contains any duplicate IDs, throw an exception.
 */
function validateUniqueDomIds() {
    const ids = new Set();
    let i = 0;
    for (const foo of document.querySelectorAll('*[id]')) {
        ids.add(foo.id);
        i++;
        if (ids.size !== i) {
            throw new Error(`Duplicate DOM IDs found. The first duplicate id is ${foo}.`);
        }
    }
}
exports.validateUniqueDomIds = validateUniqueDomIds;

},{}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CreateElement_1 = require("../Html/CreateElement");
const ElementType_1 = require("../Html/ElementType");
const EscapeHtml_1 = require("../Html/EscapeHtml");
const ExtractNodeContent_1 = require("../Html/ExtractNodeContent");
const FormFieldValue_1 = require("../Html/FormFieldValue");
const QuerySelectorNodeList_1 = require("../Html/QuerySelectorNodeList");
const IObservable_1 = require("../Observable/IObservable");
const ObservableProperty_1 = require("../Observable/ObservableProperty");
const ObservableState_1 = require("../Observable/ObservableState");
const Constructable_1 = require("../System/Types/Constructable");
const NoneType_1 = require("../System/Types/NoneType");
const Component_1 = require("./Component");
const ComponentMap_1 = require("./ComponentMap");
const KeywordArguments_1 = require("../System/Types/KeywordArguments");
const Elvis_1 = require("../System/Utility/Elvis");
/**
 * A super-basic component that allows configuration of data-binding functions using specially-named HTML attributes, as in Angular
 * or Vue.
 */
class BoundComponent extends Component_1.Component {
    constructor(viewModel, args) {
        super(args);
        this._attributeBindings = [];
        this._writeTargets = []; // Can only write to THIS component
        this._cssClassSwitches = [];
        this._replacements = [];
        this._async = false;
        this._defer = false;
        this._initialized = false;
        this.viewModel = viewModel;
        try {
            if (!window.customElements.get('i-v')) {
                window.customElements.define('i-v', TemplateReplacementValue);
            }
        }
        catch (err) {
            // customElements isn't officially part of an ES version yet so won't work even in some recent-ish browsers
        }
        const options = args || {};
        this._async = options.async || false;
        this._defer = options.defer || false;
        this._id = this.content.id;
        // Defined the default component class for the default loopPostProcess() method
        if (options.loopItemClass) {
            if (!Constructable_1.constructorTypeGuard(options.loopItemClass)) {
                throw new Error('loopItemClass is not a constructor');
            }
            if (!(options.loopItemClass instanceof BoundComponent.constructor)) {
                throw new Error('loopItemClass is not an bound component');
            }
        }
        this.loopParent = options.loopParent; // undefined in most cases
        this._loopItemClass = options.loopItemClass || BoundComponent;
        this._configureComponentBindings();
        this.setTemplate(this.content.innerHTML); // InnerHTML is currently only parsed and then the original text is thrown away.
        // Auto-add subscriptions based on settings.
        if (options.observeAllViewModel) {
            this.observeAll();
        }
        else if (options.observeViewModel) {
            this.observe();
        }
        if (options.observeTargets) {
            for (const tgt of options.observeTargets) {
                this.observe(tgt);
            }
        }
        if (options.observeAllTargets) {
            for (const tgt of options.observeAllTargets) {
                this.observeAll(tgt);
            }
        }
        if (this._async) {
            setTimeout(() => this.render(), 0);
        }
        else {
            this.render();
        }
        // Constructor initialization is done.
        this._initialized = true;
    }
    /**
     * Use this to convert elements to components. It's most useful for custom tags, for example, <my-component></my-component>.
     * It will become <div id="foo">Whatever the component content is</div>.
     * To replace the element (copying existing attributes) send the relevant options, plus {replace: true}.
     *
     * In almost every case, viewModel should be set. But it's not possible to change that and still be compatible with the base
     * class inject(). This is a typescript-only issue but it makes things ugly.
     *
     * Accepts Keyword Arguments. And practically demands their use to set viewModel.
     */
    static inject(selector = '[ichigo]', options, constructor, viewModel) {
        ({ selector = '[ichigo]', options, constructor, viewModel } = KeywordArguments_1.Kwarg.parseArgs({ selector, options, constructor, viewModel })); // kwargline
        const newConstructor = constructor || this;
        const opt = this._getOptions(options || {});
        const replacerFunction = (element) => {
            return this._replaceElementWithBoundComponent(element, viewModel, opt, newConstructor);
        };
        const converterFunction = (element) => {
            return this._convertElementToBoundComponent(element, viewModel, opt, newConstructor);
        };
        return this._inject(selector, opt, replacerFunction, converterFunction);
    }
    /**
     * Call to inject() with a cleaner argument order.
     */
    static injectBind(viewModel, selector = '[ichigo]', options, constructor) {
        ({ selector = '[ichigo]', options, constructor, viewModel } = KeywordArguments_1.Kwarg.parseArgs({ selector, options, constructor, viewModel })); // kwargline
        return this.inject(selector, options, constructor, viewModel);
    }
    static _replaceElementWithBoundComponent(existingElement, viewModel, options, constructor) {
        const opt = this._mergePropertiesAndAttributes(existingElement, options);
        const component = new constructor(viewModel, opt);
        this._replaceElement(existingElement, component);
        return component;
    }
    static _convertElementToBoundComponent(existingElement, viewModel, options, constructor) {
        // WARN: This cast may not be true. There's no way to check that the tags match.
        const opt = Object.assign({ element: existingElement }, options);
        return new constructor(viewModel, opt);
    }
    write(evt) {
        if (!this._writeTargets.length) {
            return;
        }
        const element = evt.currentTarget;
        if (!element) {
            return;
        }
        const value = FormFieldValue_1.getFormFieldValue(element);
        // There are two cases where value is undefined. Either the element is not a form element or it's an unnamed radio button
        // that is not selected. In both cases, we don't want to update the model with undefined, which is useless.
        // TODO: Is this justification valid?
        if (value === undefined) {
            return;
        }
        // WARN: Cannot type check this dynamically. TypeScript is build-time checking only. Runtime code can't even see the type.
        // If you want to be precise, all properties in _writeBindings should be FormItemValue, but as _writeBindings is populated
        // via string, there's no way to enforce that. So if you fill a string value from a multiple select, it'll produce bugs.
        // So be careful. It's on you.
        for (const bind of this._writeTargets) {
            if (bind.startsWith('this.')) {
                const target = this[bind.slice(5)];
                writeValue(target, () => this[bind.slice(5)] = value, this);
            }
            else if (bind === '.') {
                if (ObservableState_1.observableStateCheck(this.viewModel)) {
                    this.viewModel.value = value;
                }
                else {
                    // Assume that the view model is either FormFieldValue or a function that takes one.
                    writeValue(this.viewModel, () => this.viewModel = value, this.viewModel);
                }
            }
            else if (bind.startsWith('^') && Elvis_1.e_(this.loopParent).viewModel && typeof this.loopParent.viewModel === 'object') {
                // Note: Not doing a '^' by itself because that's a pretty BS case. If this is the loop child, the parent is probably
                // an object or an iterable, not really something you'll read or write to directly.
                // Might do a shortcut to the parent component's 'this'
                writeToViewModelObject(this.loopParent, bind.slice(1));
            }
            else if (typeof this.viewModel === 'object') {
                writeToViewModelObject(this, bind);
            }
        }
        function writeValue(target, writeToProperty, thisArg) {
            if (typeof target === 'function') {
                target.call(thisArg, value);
                return;
            }
            if (ObservableProperty_1.observablePropertyCheck(target)) {
                target.value = value;
                return;
            }
            // This needs to be a function to be flexible, because if target is a value type or immutable, writing
            // it directly replaces only the value without updating the model.
            writeToProperty();
        }
        function writeToViewModelObject(comp, property) {
            if (ObservableState_1.observableStateCheck(comp.viewModel)) {
                // With observable state, we need to get the state, update it, and write the whole thing back.
                // While it is possible to update a single property in some cases, it doesn't allow reuse of already-working code.
                const tmp = comp.viewModel.value;
                const target = tmp[property];
                writeValue(target, () => tmp[property] = value, tmp);
                comp.viewModel.value = tmp;
            }
            else {
                const target = comp.viewModel[property];
                writeValue(target, () => comp.viewModel[property] = value, comp.viewModel);
            }
        }
    }
    /**
     * Bind this.render() to the model passed in, or the view model if none passed in.
     */
    observe(model) {
        model = model || this.viewModel;
        if (IObservable_1.observableCheck(model)) {
            model.subscribe(this.render, this);
        }
        return this;
    }
    /**
     * Bind this.render() to all observable properties found in the model passed in,
     * or the view model if none passed in. This only goes one level deep, so it
     * won't pick up nested objects, but it's probably good enough in 60% of cases.
     */
    observeAll(model) {
        model = model || this.viewModel;
        if (!model) {
            return this;
        }
        this.observe(model);
        for (const m of Object.getOwnPropertyNames(model)) {
            this.observe(model[m]);
        }
        return this;
    }
    render() {
        // See if we need to defer rendering until after initialization
        if (this._defer && !this._initialized) {
            return this;
        }
        for (const item of this._attributeBindings) {
            if (item.bool) {
                // For boolean attributes, the very existence of the attribute means it is considered to be true.
                let val = this._getUntypedValue(item.source, item.otherComponentId);
                if (item.negative) {
                    val = !val;
                }
                else {
                    val = !!val;
                }
                if (val) {
                    this.content.setAttribute(item.attribute, val);
                }
                else {
                    this.content.removeAttribute(item.attribute);
                }
            }
            else {
                this.content.setAttribute(item.attribute, this._getStringValue(item.source, false, item.otherComponentId) || '');
            }
        }
        if (this._valueAttribute) {
            // Calls setFormFieldValue behind the scenes.
            this.value = this._getUntypedValue(this._valueAttribute.source, this._valueAttribute.otherComponentId);
        }
        if (this._cssClasses) {
            this.content.className = this._getStringValue(this._cssClasses.cssClass, false, this._cssClasses.otherComponentId) || '';
        }
        for (const item of this._cssClassSwitches) {
            // If truthy, add class, else delete it.
            let val = !!this._getUntypedValue(item.source, item.otherComponentId);
            if (item.negative) {
                val = !val;
            }
            if (val) {
                this.content.classList.add(item.class);
            }
            else {
                this.content.classList.remove(item.class);
            }
        }
        if (this._cssStyle) {
            const val = this._getStringValue(this._cssStyle.style, false, this._cssStyle.otherComponentId) || '';
            this.content.style.cssText = val;
            if (val && !this.content.style.cssText) {
                // tslint:disable-next-line:no-console
                console.warn(`Invalid style text in component: ${val}`);
            }
        }
        if (this._loop) {
            const iterable = this._getUntypedValue(this._loop.source, this._loop.otherComponentId);
            if (iterable && typeof iterable[Symbol.iterator] === 'function') {
                const previousContent = ExtractNodeContent_1.extractNodeContent(this.content);
                for (const row of iterable) {
                    const clone = document.importNode(this._loop.fragment, true);
                    // As soon as we add the clone to content, childNodes loses reference to its child nodes, so copy it.
                    const nodes = Array.from(clone.childNodes).slice();
                    this.content.appendChild(clone);
                    if (this._loop.postProcess) {
                        this.loopPostProcess(row, nodes, iterable, previousContent);
                    }
                }
            }
        }
        if (this._cssDisplay) {
            // If falsy, set display: none (saving previous value). If truthy, restore previous value (if block, flex, but not if none)
            let val = this._getUntypedValue(this._cssDisplay.source, this._cssDisplay.otherComponentId);
            if (this._cssDisplay.negative) {
                val = !val;
            }
            if (val) {
                this.content.style.setProperty('display', this._previousCssDisplaySetting || '');
            }
            else {
                if (this.content.style.display !== 'none') {
                    this._previousCssDisplaySetting = this.content.style.display || undefined;
                }
                this.content.style.setProperty('display', 'none');
            }
        }
        this._updateHtmlReplacements();
        return this;
    }
    setTemplate(templateText, update = false) {
        if (!templateText) {
            return this;
        }
        // This method is executed in the constructor. The update param should not be set.
        if (update && !this._initialized) {
            throw new Error('Update should not be true when called internally.');
        }
        // Since we're creating an element that's not on the page, we probably could avoid using a fragment,
        // but this is what fragments are for.
        const template = CreateElement_1.createElement(ElementType_1.elementType.HTMLTemplateElement);
        template.innerHTML = templateText;
        const clone = document.importNode(template.content, true);
        // If this is used to replace the existing template, we need to wipe out the previous values
        this._replacements.length = 0;
        // Working on a clone here, so we don't see the body being built step by step in the browser.
        for (const repl of clone.querySelectorAll('i-v')) {
            // Allow 3 ways to reference a component, either by #id (for people who like quickness), by component (for people who like
            // compliance), or by data-component (for people who REALLY like compliance)
            let relatedComponentId = '';
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < repl.attributes.length; i++) {
                const tmpName = repl.attributes[i].nodeName;
                if (tmpName.startsWith('#')) {
                    relatedComponentId = tmpName.slice(1);
                    break;
                }
            }
            if (!relatedComponentId && repl.hasAttribute('component')) {
                relatedComponentId = (repl.getAttribute('component') || '');
            }
            if (!relatedComponentId) {
                relatedComponentId = repl.dataset.component || '';
            }
            // If component is specified, this component must have that as an id
            if (this._id && relatedComponentId && relatedComponentId.toLowerCase() !== this._id.toLowerCase()) {
                continue;
            }
            const noescape = repl.hasAttribute('noescape') && repl.getAttribute('noescape') !== 'false';
            const otherComponentId = repl.getAttribute('i5_source') || repl.getAttribute('source') || repl.dataset.i5_source || repl.dataset.source || repl.getAttribute(':source');
            this._replacements.push({
                element: repl,
                source: repl.innerHTML,
                noescape: noescape,
                otherComponentId: otherComponentId || undefined
            });
        }
        // In the original build of the object, f any replacements start with "this." we need to defer.
        if (!this._initialized && !this._defer) {
            this._defer = this._defer || !!this._replacements.find(f => f.source.startsWith('this.'));
        }
        // See if we need to defer rendering until after initialization.
        // Note that this will lead to a FOUC, maybe milliseconds, maybe longer.
        if (!this._defer || this._initialized) {
            // Replace the completed values before adding to the visible page. This is slightly redundant, because this happens in the render()
            // step, but I hate it when I see a flash of unreplaced content on sites.
            // The reason this works is because _replacements references clone, which isn't visible until almost the last line.
            this._updateHtmlReplacements();
        }
        // Populate the front-end text. Only do this if there is at least one thing to replace. Otherwise, you're just wiping out perfectly
        // valid HTML5 references for no reason.
        if (this._replacements.length) {
            this.content.innerHTML = '';
            this.content.appendChild(clone);
        }
        // Do a full update if requested to
        if (update) {
            this.render();
        }
        return this;
    }
    setHtmlTemplate(templateProperty = '.', update = false) {
        return this.setTemplate('<i-v noescape>' + templateProperty + '</i-v>', update);
    }
    setTextTemplate(templateProperty = '.', update = false) {
        return this.setTemplate('<i-v>' + templateProperty + '</i-v>', update);
    }
    setLoop(source = '.', fragment, skipPostProcess = false, update = false, otherComponentId) {
        if (!source || !fragment) {
            throw new Error('Invalid arguments');
        }
        if (typeof fragment === 'string') {
            fragment = CreateElement_1.createFragment(fragment);
        }
        this._loop = { source, postProcess: !skipPostProcess, fragment, otherComponentId };
        if (update) {
            this.render();
        }
        return this;
    }
    removeLoop(update = false) {
        this._loop = undefined;
        if (update) {
            this.render();
        }
        return this;
    }
    setValueAttribute(source = '.', update = false, otherComponentId) {
        this._valueAttribute = { source, otherComponentId };
        if (update) {
            this.render();
        }
        return this;
    }
    setVisibility(source = '.', negative = false, update = false, otherComponentId) {
        if (!source) {
            this._cssDisplay = undefined;
        }
        else {
            this._cssDisplay = { source, negative, otherComponentId };
        }
        if (update) {
            this.render();
        }
        return this;
    }
    addAttributeMapping(attribute, source = '.', update = false, otherComponentId) {
        if (!source || !attribute) {
            throw new Error('Invalid arguments');
        }
        // Don't bind a single property to multiple things
        if (!this._attributeBindings.find(f => f.attribute === attribute)) {
            this._attributeBindings.push({ attribute, source, bool: false, negative: false, otherComponentId });
        }
        if (update) {
            this.render();
        }
        return this;
    }
    addBooleanAttributeMapping(attribute, source = '.', negative = false, update = false, otherComponentId) {
        if (!source || !attribute) {
            throw new Error('Invalid arguments');
        }
        // Don't bind a single property to multiple things
        if (!this._attributeBindings.find(f => f.attribute === attribute)) {
            this._attributeBindings.push({ attribute, source, bool: true, negative, otherComponentId });
        }
        if (update) {
            this.render();
        }
        return this;
    }
    removeAttributeMapping(attribute, update = false) {
        if (!attribute) {
            throw new Error('Invalid argument');
        }
        const filtered = this._attributeBindings.filter(f => f.attribute !== attribute);
        this._attributeBindings.length = 0;
        this._attributeBindings.push(...filtered);
        if (update) {
            this.render();
        }
        return this;
    }
    setCssClass(cls = '.', update = false, otherComponentId) {
        this._cssClasses = { cssClass: cls, otherComponentId };
        if (update) {
            this.render();
        }
        return this;
    }
    setCssStyle(style = '.', update = false, otherComponentId) {
        this._cssStyle = { style, otherComponentId };
        if (update) {
            this.render();
        }
        return this;
    }
    addCssClassSwitch(cls, source = '.', negative = false, update = false, otherComponentId) {
        if (!cls || !source) {
            throw new Error('Invalid arguments');
        }
        // Don't bind a single property to multiple things
        if (!this._cssClassSwitches.find(f => f.class === cls)) {
            this._cssClassSwitches.push({ class: cls, source, negative, otherComponentId });
        }
        if (update) {
            this.render();
        }
        return this;
    }
    removeCssClassSwitch(cls, update = false) {
        if (!cls) {
            throw new Error('Invalid argument');
        }
        const filtered = this._cssClassSwitches.filter(f => f.class !== cls);
        this._cssClassSwitches.length = 0;
        this._cssClassSwitches.push(...filtered);
        if (update) {
            this.render();
        }
        return this;
    }
    addWriteEvent() {
        this.content.addEventListener('input', this.write.bind(this));
        return this;
    }
    addWriteTarget(target = '.', update = false) {
        if (!target) {
            throw new Error('Invalid argument');
        }
        // Don't bind a single property to multiple things
        if (!this._writeTargets.find(f => f === target)) {
            this._writeTargets.push(target);
        }
        if (update) {
            this.render();
        }
        return this;
    }
    removeWriteTarget(target, update = false) {
        if (!target) {
            throw new Error('Invalid argument');
        }
        const filtered = this._writeTargets.filter(f => f !== target);
        this._writeTargets.length = 0;
        this._writeTargets.push(...filtered);
        if (update) {
            this.render();
        }
        return this;
    }
    /**
     *
     * Auto-Inject calls the default injectBind() on the default BoundComponent class, with no options except selector.
     * If you pass no inputs, it seeks out all child elements that have at least one ichigo custom property. Keep in mind
     * that when you have nested objects, this will usually mean something will blow up because you tried to bind an element
     * twice. It also will perform much worse.
     *
     * If you pass a selector, it acts the same as BoundComponent.injectBind() with that selector.
     *
     * In my experience, this is almost completely useless. Either the lack of options breaks it (pretty useless if you can't
     * observe an observable) or the simple act of binding breaks stuff.
     */
    autoInject(selector) {
        if (selector) {
            BoundComponent.injectBind(this.viewModel, selector, { parent: this.content });
        }
        else {
            for (const e of this.content.querySelectorAll('*')) {
                for (const attr of Array.from(e.attributes)) {
                    if (attr.name.startsWith('i5_') || attr.name.startsWith(':') || attr.name.startsWith('data-i5_')) {
                        BoundComponent.injectBind(this.viewModel, e);
                        break;
                    }
                }
            }
        }
        return this;
    }
    /**
     * Override this method to unbind a view from an observable.
     */
    dispose() {
        if (ComponentMap_1.ComponentMap.components) {
            ComponentMap_1.ComponentMap.components.delete(this.content);
        }
    }
    /**
     * Override this if you need to do something else after the loop is added to the DOM.
     */
    loopPostProcess(row, addedContent, allRows, previousContent) {
        if (!addedContent.length) {
            return;
        }
        // If the typescript part of the following were important, this would be a problem
        // if this were a derived class.
        const thisclass = this;
        const nodes = QuerySelectorNodeList_1.nodeListSelectorAll(addedContent, '[i5_item], [\\00003Aitem], [data-i5_item]');
        // If no i5_item matches, then grab the first element.
        if (!nodes.length) {
            const firstNode = QuerySelectorNodeList_1.nodeListSelector(addedContent, '*');
            if (firstNode) {
                nodes.push(firstNode);
            }
        }
        if (!nodes.length) {
            return;
        }
        this._loopItemClass.injectBind(row, nodes, {
            replace: false,
            loopParent: this,
            async: this._async
        });
    }
    _getStringValue(name, skipEscape = false, sourceComponentId) {
        const value = this._getUntypedValue(name, sourceComponentId);
        if (NoneType_1.isNone(value)) {
            return value;
        }
        else if (typeof value === 'string') {
            return skipEscape ? value : EscapeHtml_1.escapeHtml(value);
        }
        else {
            return skipEscape ? value.toString() : EscapeHtml_1.escapeHtml(value.toString());
        }
    }
    _getUntypedValue(name, sourceComponentId) {
        let component = this;
        let source;
        if (sourceComponentId) {
            component = ComponentMap_1.getComponent(sourceComponentId) || component;
        }
        // I'm pretty sure this is being validated during construction but be safe
        if (!name) {
            return;
        }
        let thisArg = component.viewModel;
        // If VM is a state, get the current state value.
        if (ObservableState_1.observableStateCheck(thisArg)) {
            thisArg = thisArg.value;
        }
        if (name.startsWith('this.')) {
            thisArg = component;
            name = name.slice(5);
            if (!(name in component)) {
                // tslint:disable-next-line:no-console
                console.warn(`this.${name} does not exist on view.`);
                return;
            }
            source = component[name];
        }
        else if (name.startsWith('^') && Elvis_1.e_(component.loopParent).viewModel && typeof Elvis_1.e_(component.loopParent).viewModel === 'object') {
            // Note: Not doing a '^' by itself because that's a pretty BS case. If this is the loop child, the parent is probably
            // an object or an iterable, not really something you'll read or write to directly.
            // Might do a shortcut to the parent component's 'this'
            thisArg = component.loopParent.viewModel;
            if (!(name.slice(1) in thisArg)) {
                // tslint:disable-next-line:no-console
                console.warn(`${name} does not exist on viewModel parent view model.`);
                return {};
            }
            source = thisArg[name.slice(1)];
        }
        else if (name === '.') {
            source = thisArg;
        }
        else if (typeof thisArg === 'object') {
            if (!(name in thisArg)) {
                // tslint:disable-next-line:no-console
                console.warn(`this.${name} does not exist on viewModel.`);
                return {};
            }
            source = thisArg[name];
        }
        // CONSIDER: Consider adding custom attributes to allow executing method with string parameters. i5_param01="val 1", i5_param02="val 2"
        if (typeof source === 'function') {
            return source.call(thisArg);
        }
        else if (ObservableProperty_1.observablePropertyCheck(source)) {
            return source.value;
        }
        else {
            return source;
        }
    }
    _updateHtmlReplacements() {
        for (const repl of this._replacements) {
            const newValue = this._getStringValue(repl.source, repl.noescape, repl.otherComponentId) || '';
            const element = repl.element;
            const currentValue = element.innerHTML;
            if (newValue !== currentValue) {
                element.innerHTML = newValue;
            }
        }
    }
    _configureComponentBindings() {
        const currentAttributes = Array.from(this.content.attributes)
            .filter(f => f.value || f.name === 'i5_input' || f.name === ':input')
            .map(m => ({
            name: m.name,
            value: m.value || ''
        }));
        // Technically it's invalid to add custom attributes to regular elements, so technically <replace-me :switch:redtext="warning">
        // is legal but if if it were a div, that would be illegal. So we'll allow <div data-i5_switch_redtext="warning">.
        // Note that the weird name handling of data attributes could break your code if you try to use this. You may need to do extra
        // work to make your code work, all in the name of strict adherence to standards. It's up to you.
        for (const attr of Object.getOwnPropertyNames(this.content.dataset)) {
            const value = this.content.dataset[attr];
            if (value || attr === 'i5_input') {
                currentAttributes.push({ name: attr, value: value || '' });
            }
        }
        // Get the alternate source Id
        const otherComponentId = Elvis_1.e_(currentAttributes.find(f => f.name === 'i5_source' || f.name === ':source')).value;
        let textHtmlSet = false;
        for (const prop of currentAttributes) {
            const type = this._parseAttributeName(prop.name);
            let negative = false;
            // Regular attributes will all match this.
            if (!type) {
                continue;
            }
            switch (type.type) {
                case "boolNegative":
                    negative = true;
                // fall through
                case "bool":
                    if (!type.detail) {
                        throw new Error('Programming error');
                    }
                    this.addBooleanAttributeMapping(type.detail, prop.value, negative, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "attr":
                    if (!type.detail) {
                        throw new Error('Programming error');
                    }
                    this.addAttributeMapping(type.detail, prop.value, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "switchClassNegative":
                    negative = true;
                // fall through
                case "switchClass":
                    if (!type.detail) {
                        throw new Error('Programming error');
                    }
                    this.addCssClassSwitch(type.detail, prop.value, negative, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "text":
                    if (textHtmlSet) {
                        throw new Error("Can't set i5_text and i5_html at same time");
                    }
                    textHtmlSet = true;
                    this.content.innerHTML = `<i-v>${prop.value}</i-v>`; // Use this as the template
                    deferIfNeeded.call(this);
                    break;
                case "html":
                    if (textHtmlSet) {
                        throw new Error("Can't set i5_text and i5_html at same time");
                    }
                    textHtmlSet = true;
                    this.content.innerHTML = `<i-v noescape>${prop.value}</i-v>`; // Use this as the template
                    deferIfNeeded.call(this);
                    break;
                case "value":
                    this.setValueAttribute(prop.value, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "ifNegative":
                    negative = true;
                // fall through
                case "if":
                    this.setVisibility(prop.value, negative, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "style":
                    this.setCssStyle(prop.value, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "class":
                    this.setCssClass(prop.value, false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "input":
                    this.addWriteEvent();
                    if (!prop.value) {
                        break;
                        // Else fall through, using the value of the input attribute as a target attribute
                        // Shortcut i5_input_foo is the same as i5_target="foo" i5_value="foo"
                        // But only write to the local view model, not another component's
                    }
                    else if (type.detail) {
                        this.setValueAttribute(prop.value, false);
                    }
                case "target":
                    this.addWriteTarget(prop.value, false);
                    deferIfNeeded.call(this);
                    break;
                case "loop":
                    // Grab the base content for the loop, pulling it out of the DOM.
                    this.setLoop(prop.value, ExtractNodeContent_1.extractNodeContent(this.content), type.detail === 'null', false, otherComponentId);
                    deferIfNeeded.call(this);
                    break;
                case "item":
                    // Only used as a selector. Has no functionality
                    break;
                default:
                    throw new Error("Not Implemented Ichigo attribute: " + type.type);
            }
            function deferIfNeeded() {
                this._defer = this._defer || prop.value.startsWith('this.');
            }
        }
    }
    _parseAttributeName(name) {
        if (name.startsWith(':')) {
            // General ichigo shortcut
            name = 'i5_' + name.slice(1);
        }
        if (name === 'i5_item') {
            // This is used to indicate an item component, nothing else.
            return;
        }
        else if (name === 'i5_source') {
            // This is used to indicate a source component. It's read separately.
            return;
        }
        else if (name === 'i5_event') {
            // This is used only in Component.addInlineEventListeners().
            return;
        }
        else if (!name.startsWith('i5_')) {
            return;
        }
        if (name.startsWith('i5_attr')) {
            if (name[7] !== ':' && name[7] !== '_') {
                throw new Error('Invalid attribute binding syntax');
            }
            if (name.length < 9) {
                throw new Error("Binding attribute name is missing.");
            }
            return { type: 'attr', detail: name.slice(8) };
        }
        else if (name.startsWith('i5_bool')) {
            let negative = false;
            if (name[7] !== ':' && name[7] !== '_' && name[7] !== '-' && name[7] !== '0') {
                throw new Error('Invalid attribute binding syntax');
            }
            if (name[7] === '-' || name[7] === '0') {
                negative = true;
                name = name.slice(0, 7) + name.slice(8);
            }
            if (name.length < 9) {
                throw new Error("Binding attribute name is missing.");
            }
            return { type: negative ? 'boolNegative' : 'bool', detail: name.slice(8) };
        }
        else if (name.startsWith('i5_switch')) {
            let negative = false;
            if (name[9] !== ':' && name[9] !== '_' && name[9] !== '-' && name[9] !== '0') {
                throw new Error('Invalid switch binding syntax');
            }
            if (name[9] === '-' || name[9] === '0') {
                negative = true;
                name = name.slice(0, 9) + name.slice(10);
            }
            if (name.length < 11) {
                throw new Error("Class switch name is missing.");
            }
            return { type: negative ? 'switchClassNegative' : 'switchClass', detail: name.slice(10) };
        }
        else if (name.startsWith('i5_if')) {
            let negative = false;
            if (name.slice(-1) === '-' || name.slice(-1) === '0') {
                negative = true;
            }
            return { type: negative ? 'ifNegative' : 'if' };
        }
        else if (name.startsWith('i5_loop')) {
            if (name === 'i5_loop:null') {
                return { type: 'loop', detail: 'null' };
            }
            return { type: 'loop' };
        }
        else if (name.startsWith('i5_target')) {
            return ({ type: 'target' });
        }
        else if (name.startsWith('i5_input')) {
            const twoWay = name.endsWith('_value') || name.endsWith(':');
            return ({ type: 'input', detail: twoWay ? '2way' : '' });
        }
        return { type: name.slice(3) };
    }
}
exports.BoundComponent = BoundComponent;
// Use a custom element to create a replacement tag that is not limited, as span is, to containing no block elements.
// No logic, no special display details.
// tslint:disable-next-line:max-classes-per-file
class TemplateReplacementValue extends HTMLElement {
    constructor() {
        super();
    }
}
exports.TemplateReplacementValue = TemplateReplacementValue;

},{"../Html/CreateElement":12,"../Html/ElementType":14,"../Html/EscapeHtml":15,"../Html/ExtractNodeContent":16,"../Html/FormFieldValue":18,"../Html/QuerySelectorNodeList":19,"../Observable/IObservable":29,"../Observable/ObservableProperty":36,"../Observable/ObservableState":38,"../System/Types/Constructable":51,"../System/Types/KeywordArguments":52,"../System/Types/NoneType":53,"../System/Utility/Elvis":57,"./Component":22,"./ComponentMap":23}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CreateElement_1 = require("../Html/CreateElement");
const ElementType_1 = require("../Html/ElementType");
const FormFieldValue_1 = require("../Html/FormFieldValue");
const QuerySelectorNodeList_1 = require("../Html/QuerySelectorNodeList");
const KeywordArguments_1 = require("../System/Types/KeywordArguments");
const GetUniqueId_1 = require("../System/Utility/GetUniqueId");
const ComponentMap_1 = require("./ComponentMap");
/**
 * A class with a content property that points to something on the page, along with some of helper methods.
 *
 * This class is intended to be used as a base class for other classes, so it's marked abstract. It just doesn't
 * make sense to me to create Component with nothing customized. Just create an HTMLElement. The helpers aren't really
 * that impressive, when you consider that the tradeoff is having to reference obj.content to modify the DOM.
 */
class Component {
    constructor(args) {
        // Typescript doesn't understand that this.content is set in ALL of the private ctor functions.
        this.content = null;
        if (args && typeof args === 'string') {
            _ctor_string.call(this, args);
        }
        else if (args && args.selector) {
            if (args.innerHtml) {
                args.properties = Object.assign(args.properties || {}, { innerHTML: args.innerHtml });
            }
            _ctor_lookup.call(this, args);
        }
        else if (!args) {
            _ctor_empty.call(this);
        }
        else if (args.element) {
            if (args.innerHtml) {
                args.properties = Object.assign(args.properties || {}, { innerHTML: args.innerHtml });
            }
            _ctor_existingElement.call(this, args);
        }
        else if (args.outerHtml) {
            _ctor_outerHtml.call(this, args);
        }
        else {
            _ctor_innerHtml.call(this, args);
        }
        this._checkInlineEventListeners();
        // Angular material does something like this. In this case, there's no functionality behind it, but it does make it
        // useful for a developer to see that an element is a component and what type it is.
        try {
            const snake_case = 'iv_' + this.constructor.name.charAt(0).toLowerCase() + this.constructor.name.slice(1)
                .replace(/\W+/g, ' ')
                .replace(/([a-z])([A-Z])([a-z])/g, "$1 $2$3")
                .split(/\B(?=[A-Z]{2,})/)
                .join(' ')
                .split(' ')
                .join('_')
                .toLowerCase();
            this.content.setAttribute(snake_case, '');
        }
        catch (err) {
            // If the component has some weird name, no problem. This is just an info field anyway.
        }
        this.mapComponent();
        function _ctor_empty() {
            // No arguments
            // This is fine as long as TElement is DIV. No way to verify that as it's a typescript illusion. JS doesn't see type parameters.
            this.content = CreateElement_1.createElement(ElementType_1.elementType.HTMLDivElement, { id: GetUniqueId_1.getUniqueId() });
        }
        function _ctor_lookup(existingElement) {
            // Shortcut for existingElement.
            // The main reason it exists is that document.getElementById doesn't return the correct type (it's not generic),
            // so typescript freaks out and thinks it should be a STRING, in spite of the type definition not being anything
            // like that. It's just easier to use this than to remember "oh, right, i have to use document.querySelector(), which is generic".
            const element = (existingElement.parent || document).querySelector(existingElement.selector);
            if (!element) {
                throw new Error('Element selector could not find element.');
            }
            // This is nasty but it makes TypeScript happy without creating a new object copy
            existingElement.element = element;
            _ctor_existingElement.call(this, existingElement);
        }
        function _ctor_existingElement(existingElement) {
            this.content = existingElement.element;
            // First try attributes (which are the initial values)
            if (existingElement.attributes) {
                for (const attr of Object.getOwnPropertyNames(existingElement.attributes)) {
                    this.content.setAttribute(attr, existingElement.attributes[attr]);
                }
            }
            // Then overwrite with properties (which are current)
            if (existingElement.properties) {
                Object.assign(this.content, existingElement.properties);
            }
        }
        function _ctor_innerHtml(newElement) {
            // New element. User specifies the inner HTML for the content.
            // This could be an empty object like {}, practically the same as calling it with no args
            const props = { innerHTML: newElement.innerHtml || '' };
            Object.assign(props, newElement.properties);
            this.content = CreateElement_1.createElement(newElement.type || ElementType_1.elementType.HTMLDivElement, props, newElement.attributes);
            if (newElement.id) {
                this.content.id = newElement.id;
            }
            else if (!this.content.id) {
                this.content.id = GetUniqueId_1.getUniqueId();
            }
        }
        function _ctor_outerHtml(newElement) {
            // User specifies the full HTML for the content.
            // Note that it can't be type checked. JS can't see what TElement is.
            const tmpdiv = CreateElement_1.div(newElement.outerHtml.trim());
            if (tmpdiv.childNodes.length !== 1 || !tmpdiv.firstElementChild) {
                throw new Error('OuterHtml must contain exactly one HTMLElement');
            }
            this.content = tmpdiv.firstElementChild;
            // First try attributes (which are the initial values)
            if (newElement.attributes) {
                for (const attr of Object.getOwnPropertyNames(newElement.attributes)) {
                    this.content.setAttribute(attr, newElement.attributes[attr]);
                }
            }
            // Then overwrite with properties (which are current)
            if (newElement.properties) {
                Object.assign(this.content, newElement.properties);
            }
            // Specified ID takes precedence
            if (newElement.id) {
                this.content.id = newElement.id;
            }
        }
        function _ctor_string(newElement) {
            // String by itself is a shortcut for outerHtml
            _ctor_outerHtml.call(this, { outerHtml: newElement });
        }
    }
    /**
     * Use this to convert elements to components. It's most useful for custom tags, for example, <my-component></my-component>.
     * It will become <div id="foo">Whatever the component content is</div>.
     *
     * It doesn't have to be a custom tag. It could be a class, like <p class='bind-to-model"> (selector='.bind-to-model')
     * or <p ichigo> (selector='[ichigo]').
     *
     * To completely replace the existing element (copying existing attributes) send the relevant options, plus {replace: true}.
     *
     * Accepts Keyword Arguments.
     */
    static inject(selector = '[ichigo]', options, constructor) {
        ({ selector = '[ichigo]', options, constructor } = KeywordArguments_1.Kwarg.parseArgs({ selector, options, constructor })); // kwargline
        const newConstructor = constructor || this;
        const opt = this._getOptions(options);
        const replacerFunction = (element) => {
            return this._replaceElementWithComponent(element, opt, newConstructor);
        };
        const converterFunction = (element) => {
            return this._convertElementToComponent(element, newConstructor);
        };
        return this._inject(selector, opt, replacerFunction, converterFunction);
    }
    static _inject(selector = '[ichigo]', options, replacerFunction, converterFunction) {
        const results = [];
        const containers = this._lookUpContainersToInject(selector, options.parent);
        for (const container of containers) {
            if (options.replace) {
                // Can't have dupe IDs being created if there are multiple containers. There are 3 places where ID can be set.
                if (containers.length > 1) {
                    delete options.id;
                    if ('properties' in options) {
                        delete options.properties.id; // DOM property
                    }
                    if ('attributes' in options) {
                        delete options.attributes.id; // HTML attribute
                    }
                }
                results.push(replacerFunction(container));
            }
            else {
                results.push(converterFunction(container));
            }
        }
        return results;
    }
    static _mergePropertiesAndAttributes(existingElement, options) {
        // This attempts to preserve the attributes set on the replaced element. That opens an ugly can of worms,
        // but it should make replacement components more useful because it allows them to vary.
        // It does make a brutal juggling act:
        // If the existing element has innerHTML, we want to take it.
        // If outerHTML is provided, the outerHTML's innerHTML should override the existing element's.
        // If the existing element has attributes, we want to take them.
        // If outerHTML is provided, the outerHTML's attributes should override them.
        // For any attributes passed in OPTIONS, they should override anything that came before.
        // For any properties passed in OPTIONS, they should override anything that came before.
        // Only the last 2 are handled in the component constructor. And if we're not careful, we could break them.
        const properties = { innerHTML: existingElement.innerHTML };
        const attributes = {};
        for (const attr of Array.from(existingElement.attributes)) {
            attributes[attr.name] = attr.value;
        }
        const opt = Object.assign({}, options);
        // This is ugly because it happens again in the constructor. No other clean way to parse the element attributes, though.
        if (opt.outerHtml) {
            const tmp = CreateElement_1.div(opt.outerHtml.trim());
            if (tmp.childNodes.length !== 1 || !tmp.firstElementChild) {
                throw new Error('OuterHtml must contain exactly one HTMLElement');
            }
            const tmp2 = tmp.firstElementChild;
            // The outer HTML attributes get picked up automatically when added to the DOM, so we really
            // just need to discard the matching properties and attributes of the existing element.
            delete properties.innerHTML;
            for (const attr of Array.from(tmp2.attributes)) {
                if (attr.name in attributes) {
                    delete attributes[attr.name];
                }
            }
        }
        opt.properties = Object.assign(properties, opt.properties);
        opt.attributes = Object.assign(attributes, opt.attributes);
        return opt;
    }
    static _getOptions(options) {
        let opt;
        if (options && typeof options === 'string') {
            // Shortcut for replacing the outer HTML
            opt = { replace: true, outerHtml: options };
        }
        else if (options) {
            // Typescript doesn't know that options !== 'string' (can't read "else if" clause)
            opt = options;
        }
        else {
            opt = { replace: false };
        }
        return opt;
    }
    static _replaceElement(existingElement, component) {
        if (existingElement.parentNode) {
            existingElement.parentNode.replaceChild(component.content, existingElement);
        }
        else {
            document.replaceChild(component.content, existingElement);
        }
    }
    static _replaceElementWithComponent(existingElement, options, constructor) {
        const opt = this._mergePropertiesAndAttributes(existingElement, options);
        const component = new constructor(options);
        this._replaceElement(existingElement, component);
        return component;
    }
    static _convertElementToComponent(existingElement, constructor) {
        return new constructor({ element: existingElement });
    }
    static _lookUpContainersToInject(selector = '[ichigo]', parent) {
        if (selector === null) {
            // I've done this myself, which results in a silent failure if accidental.
            // tslint:disable-next-line:no-console
            console.warn('Injection selector is null.');
        }
        selector = selector || '[ichigo]';
        // Look up the elements to either replace or convert
        let containers;
        if (parent && typeof selector === 'string') {
            parent = parent || document;
            containers = Array.from(parent.querySelectorAll(selector));
        }
        else if (typeof selector === 'string') {
            containers = Array.from(document.querySelectorAll(selector));
        }
        else if (selector instanceof NodeList) {
            containers = Array.from(selector);
        }
        else if (Array.isArray(selector)) {
            containers = selector;
        }
        else {
            containers = [selector];
        }
        return containers;
    }
    get id() {
        return this.content.id;
    }
    set id(value) {
        this.content.id = value;
    }
    get innerHTML() {
        return this.content.innerHTML;
    }
    set innerHTML(value) {
        this.content.innerHTML = value;
    }
    get value() {
        // Will return undefined if content is not a form field type
        return FormFieldValue_1.getFormFieldValue(this.content);
    }
    set value(value) {
        // Will log a warning if content is not a form field type
        FormFieldValue_1.setFormFieldValue(this.content, value);
    }
    get className() {
        return this.content.className;
    }
    set className(value) {
        this.content.className = value;
    }
    get classList() {
        return this.content.classList;
    }
    get style() {
        return this.content.style;
    }
    /**
     * Add an HTML event listener on the Component content. Fluent.
     */
    addEventListener(eventType, event, options) {
        this.content.addEventListener(eventType, event, options);
        return this;
    }
    /**
     * Search the HTML for i5_event or :event attributes and add event listeners according to inline custom attributes.
     * Filter by matching the componentFilter input with an attribute like component="componentFilter".
     * Enclose the event type in parentheses, and for the value, enter the name of a method in this component.
     * Example: <form :event (click)="submitTheForm"></form>
     * This is also allowed: <form :event _click_="submitTheForm"></form>
     */
    addInlineEventListeners(componentFilter) {
        // It would be nice if we could skip this initial filter, like angular does. But there is no CSS selector for
        // attribute name begins with or ends with. [attr^=] is for the VALUE beginning with something.
        // This includes the content itself in its check.
        for (const ele of QuerySelectorNodeList_1.nodeListSelectorAll([this.content], '[i5_event], [\\00003Aevent], [data-i5_event]')) {
            if (componentFilter && ele.getAttribute('component') !== componentFilter) {
                continue;
            }
            const currentAttributes = Array.from(ele.attributes);
            let eventDefinition = currentAttributes.find(f => f.name.startsWith('(') && f.name.endsWith(')') && f.name.length > 2);
            if (!eventDefinition) {
                // Try to find by alternate syntax. This one works better with setAttribute().
                eventDefinition = currentAttributes.find(f => f.name.startsWith('_') && f.name.endsWith('_') && f.name.length > 2);
            }
            if (!eventDefinition || !eventDefinition.value) {
                throw new Error(`Event definition not declared for element ${ele.id || ele.tagName}`);
            }
            const method = this[eventDefinition.value];
            if (typeof method !== 'function') {
                throw new Error(`Handler method for element ${ele.id || ele.tagName} ${eventDefinition.value} does not exist`);
            }
            ele.addEventListener(eventDefinition.name.slice(1, -1), method.bind(this));
        }
        return this;
    }
    append(newChild) {
        if (guard(newChild)) {
            this.content.appendChild(newChild.content);
        }
        else {
            this.content.appendChild(newChild);
        }
        return this;
        function guard(obj) {
            return obj && 'content' in obj && obj.content instanceof Node;
        }
    }
    appendChild(newChild) {
        if (guard(newChild)) {
            return this.content.appendChild(newChild.content);
        }
        else {
            return this.content.appendChild(newChild);
        }
        function guard(obj) {
            return obj && 'content' in obj && obj.content instanceof Node;
        }
    }
    appendToParent(parent) {
        if (guard(parent)) {
            parent.content.appendChild(this.content);
        }
        else {
            parent.appendChild(this.content);
        }
        return this;
        function guard(obj) {
            return obj && 'content' in obj && obj.content instanceof Node;
        }
    }
    /**
     * Add the component to ComponentMap.
     */
    mapComponent() {
        // Throw an error if the content has already been related to a different component
        if (ComponentMap_1.getComponent(this.content)) {
            throw new Error('Content already referenced by a component');
        }
        ComponentMap_1.ComponentMap.components.set(this.content, this);
        return this;
    }
    /**
     * Remove the component from ComponentMap. Sometimes you might need to use this. But hopefully rarely, because it's using a WeakMap,
     */
    unmapComponent() {
        ComponentMap_1.ComponentMap.components.delete(this.content);
        return this;
    }
    /**
     * Return a list of components that are nested inside this component.
     */
    *getAllChildComponents() {
        for (const e of this.content.querySelectorAll('*')) {
            const component = ComponentMap_1.getComponent(e);
            if (component) {
                yield component;
            }
        }
    }
    setStyle(property, value) {
        if (typeof property === 'string' && value) {
            this.content.style.setProperty(property, value);
        }
        else {
            for (const prop of Object.getOwnPropertyNames(property)) {
                // TS just forgot that property is Record<string, string>.
                const val = property[prop];
                this.content.style.setProperty(prop, val);
            }
        }
        return this;
    }
    addClass(classNames) {
        if (!classNames) {
            return this;
        }
        if (typeof classNames === "string" && classNames.includes(" ")) {
            classNames = classNames.split(" ").filter(q => q !== "");
        }
        else if (typeof classNames === "string") {
            classNames = [classNames];
        }
        for (const name of classNames) {
            this.content.classList.add(name);
        }
        return this;
    }
    /**
     * Because addInlineEventListeners() searches all the way down, into nested components, it can't be called
     * by default. It just throws errors on all but simple test cases. But because these events almost always exist
     * internal to the component (e.g. on buttons), it can't be limited. This can be confusing without some kind of
     * message.
     */
    _checkInlineEventListeners() {
        for (const ele of QuerySelectorNodeList_1.nodeListSelectorAll([this.content], '[i5_event], [\\00003Aevent], [data-i5_event]')) {
            if (!window.__event_warning__) {
                // tslint:disable-next-line:no-console
                console.info('Inline event listeners are configured. Remember to call addInlineEventListeners().');
                window.__event_warning__ = true;
            }
            setTimeout(() => delete window.__event_warning__, 1000);
        }
    }
}
exports.Component = Component;

},{"../Html/CreateElement":12,"../Html/ElementType":14,"../Html/FormFieldValue":18,"../Html/QuerySelectorNodeList":19,"../System/Types/KeywordArguments":52,"../System/Utility/GetUniqueId":58,"./ComponentMap":23}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The question needs to be asked: if you can add a component to a page by doing element.appendChild(component.content),
 * how do you do from document.getElementById('foo') and get to component, not component.content? This is how.
 *
 * var component = ComponentMap.components.get(document.getElementById('foo'));
 *
 * This will work as long as ComponentMap.components.set(content, component) has been called at some point.
 *
 * This is the approved way of doing it. Another possible solution would be the use of expando properties,
 * for example document.getElementById('foo').relatedComponent = component. This works and it's super simple,
 * but seems to be frowned upon ... it has been known to create memory leaks in the past. WeakMap is the object
 * specifically created for this use case, so that is used here.
 *
 * If extension methods are loaded, you can use the element.getComponent() shortcut.
 */
class ComponentMap {
}
ComponentMap.components = new WeakMap();
exports.ComponentMap = ComponentMap;
function getComponent(element) {
    if (typeof element === 'string') {
        const e = document.getElementById(element);
        if (!e) {
            return;
        }
        return ComponentMap.components.get(e);
    }
    else {
        return ComponentMap.components.get(element);
    }
}
exports.getComponent = getComponent;

},{}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:max-classes-per-file
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class ComponentBindingOptions {
    constructor(opt) {
        Object.assign(this, opt);
    }
}
exports.ComponentBindingOptions = ComponentBindingOptions;
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class ExistingElementBindingOptions extends ComponentBindingOptions {
    constructor(opt) {
        super(opt);
        Object.assign(this, opt);
        this.element = opt.element;
    }
}
exports.ExistingElementBindingOptions = ExistingElementBindingOptions;
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class ExistingLookupBindingOptions extends ComponentBindingOptions {
    constructor(opt) {
        super(opt);
        Object.assign(this, opt);
        this.selector = opt.selector;
    }
}
exports.ExistingLookupBindingOptions = ExistingLookupBindingOptions;
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class InnerHtmlBindingOptions extends ComponentBindingOptions {
    constructor(opt) {
        super(opt);
        Object.assign(this, opt);
    }
}
exports.InnerHtmlBindingOptions = InnerHtmlBindingOptions;
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class OuterHtmlBindingOptions extends ComponentBindingOptions {
    constructor(opt) {
        super(opt);
        Object.assign(this, opt);
        this.outerHtml = opt.outerHtml;
    }
}
exports.OuterHtmlBindingOptions = OuterHtmlBindingOptions;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class ExistingElementOptions {
    constructor(opt) {
        Object.assign(this, opt);
        this.element = opt.element;
    }
}
exports.ExistingElementOptions = ExistingElementOptions;

},{}],26:[function(require,module,exports){
"use strict";
/**
 * Look up an existing element in the DOM and convert it to a component. This is just a way to simplify the lookup process vs doing
 * it manually before using IExistingElementOptions.
 * Note: Typescript can't verify your type annotations if you do it this way.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class ExistingLookupOptions {
    constructor(opt) {
        Object.assign(this, opt);
        this.selector = opt.selector;
    }
}
exports.ExistingLookupOptions = ExistingLookupOptions;

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class InnerHtmlOptions {
    constructor(opt) {
        Object.assign(this, opt);
    }
}
exports.InnerHtmlOptions = InnerHtmlOptions;

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Try to provide some custom classes to help clean up the mess that TypeScript and VSCode provides whenever
 * the mess they call overloading explodes. If you mess up a property, the error message complains that
 * the object you provided doesn't include the various properties of the string object, which isn't helpful.
 */
class OuterHtmlOptions {
    constructor(opt) {
        Object.assign(this, opt);
        this.outerHtml = opt.outerHtml;
    }
}
exports.OuterHtmlOptions = OuterHtmlOptions;

},{}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventHandler_1 = require("../System/EventHandler/EventHandler");
function observableCheck(obj) {
    // Not an exhaustive test but it's the important bit.
    return obj && typeof obj === 'object' && 'changeHandler' in obj && obj.changeHandler instanceof EventHandler_1.EventHandler;
}
exports.observableCheck = observableCheck;

},{"../System/EventHandler/EventHandler":49}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ArrayChangedEventArgs_1 = require("../../System/EventHandler/ArrayChangedEventArgs");
const ObjectFullAssign_1 = require("../../System/Utility/ObjectFullAssign");
const ObservableBase_1 = require("../ObservableBase");
class TraitSource extends ObservableBase_1.ObservableBase {
    constructor(disableAsync) {
        super({ name: 'ArrayProxy', disableAsync });
    }
}
// tslint:disable-next-line:max-classes-per-file
class ArrayObservable extends Array {
    constructor(...args) {
        super(...args);
    }
    static getMergedObservable(args, disableAsync) {
        // This is where I really need multiple inheritance. This needs to inherit from Array
        // because it's extending a built-in class. It also needs to inherit from ObservableBase.
        // Three choices:
        // 1) 50 lines of clipboard inheritance.
        // 2) Cheat heavily by taking a trait approach. This means hackery to make TS happy.
        // 3) Do the same as 2 with the built-in Array class. Not a problem but with #2 the class name acts
        // as a hint that it's not a default array, which is better.
        // #2 wins.
        const arr = new ArrayObservable(...args);
        const result = ObjectFullAssign_1.objectFullAssign(arr, new TraitSource(disableAsync));
        Object.defineProperty(result, 'changeHandler', { enumerable: false });
        return result;
    }
    // Objects created through map, filter, etc, should be generic arrays.
    static get [Symbol.species]() {
        return Array;
    }
    // Needs to be public so the proxy can call it, but should not be called outside the API. Imagine it's internal.
    publishCollectionChanged(type, propertyName, args, oldValue, newValue, sender) {
        // This requires a cheat. It will fail if the object is created with new();
        this.changeHandler.invoke(new ArrayChangedEventArgs_1.ArrayChangedEventArgs({ type, propertyName, args, oldValue, newValue, sender }));
    }
    toJSON() {
        return this.slice();
    }
}
exports.ArrayObservable = ArrayObservable;

},{"../../System/EventHandler/ArrayChangedEventArgs":47,"../../System/Utility/ObjectFullAssign":61,"../ObservableBase":35}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IsInteger_1 = require("../../System/Utility/IsInteger");
class ArrayProxyHandler {
    get(target, key, proxy) {
        if (key in target) {
            const methodCalled = Reflect.get(target, key, proxy);
            // Silent pass-through of other methods
            if (ArrayProxyHandler.methodsToWatch.indexOf(key.toString()) === -1) {
                return methodCalled;
            }
            return (...args) => {
                // TODO: Need to evaluate performance of copies
                const before = target.slice(); // This could be useful but it could also be a performance problem.
                const returnVal = methodCalled.apply(target, args);
                const after = target.slice(); // This could be useful but it could also be a performance problem.
                target.publishCollectionChanged('call', key, args, before, after, proxy);
                return returnVal;
            };
        }
    }
    set(target, key, value, proxy) {
        // Problem: We want to capture only length and [indexer] calls, but JS has no consistent
        // way of defining [indexer]. What makes it worse is that if a string is an integer, it is
        // converted to a number. And JS does not include a built-in way to test if a number is an integer.
        // Solution: A regex-based check. Ick. Way to remind me I'm using JS.
        if (key && (key.toString() === 'length' || typeof key === 'number' || IsInteger_1.isPositiveIntegerString(key))) {
            // TODO: Need to evaluate performance of copies
            const before = target.slice(); // This could be useful but it could also be a performance problem.
            Reflect.set(target, key, value, proxy);
            const after = target.slice(); // This could be useful but it could also be a performance problem.
            target.publishCollectionChanged('set', key, [value], before, after, proxy);
            return true;
        }
        else {
            Reflect.set(target, key, value, proxy);
            return true;
        }
    }
    deleteProperty(target, key) {
        const before = target.slice(); // This could be useful but it could also be a performance problem.
        Reflect.deleteProperty(target, key);
        const after = target.slice(); // This could be useful but it could also be a performance problem.
        // Cannot report proxy as sender because proxy not sent to this method
        target.publishCollectionChanged('delete', key, [], before, after, null);
        return true;
    }
}
// These are all the methods, not counting custom setters, that mutate an array.
ArrayProxyHandler.methodsToWatch = ['copyWithin', 'fill', 'pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'];
exports.ArrayProxyHandler = ArrayProxyHandler;

},{"../../System/Utility/IsInteger":59}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const PropertyChangedEventArgs_1 = require("../../System/EventHandler/PropertyChangedEventArgs");
const ObservableBase_1 = require("../ObservableBase");
const ObjectFullAssign_1 = require("../../System/Utility/ObjectFullAssign");
class ObjectObservable extends ObservableBase_1.ObservableBase {
    /**
     * This is the only way to produce an object observable, for reasons of safety.
     */
    static getMergedObservable(data, disableAsync) {
        // We need something with all the properties of the input object merged with the properties of this.
        // I don't want to actually modify the input object. Even though it SHOULD be throwaway, I don't know.
        // And I don't want to take the risk that something in the input, an unknown factor, will make this blow up.
        // I know that this class has only 2 levels of inheritance (currently) and contains nothing very complex at any level.
        const result = ObjectFullAssign_1.objectFullAssign(data, new ObjectObservable(disableAsync), true);
        Object.defineProperty(result, 'changeHandler', { enumerable: false });
        return result;
    }
    constructor(disableAsync) {
        super({ name: "ObjectProxy", disableAsync });
    }
    // Needs to be public so the proxy can call it, but should not be called outside the API. Imagine it's internal.
    publishPropertyChanged(type, propertyName, oldValue, newValue, sender) {
        this.changeHandler.invoke(new PropertyChangedEventArgs_1.PropertyChangedEventArgs({ type, propertyName, oldValue, newValue, sender }));
    }
    toJSON() {
        // This filters out the troublesome changeHandler field.
        return super.toJSON();
    }
}
exports.ObjectObservable = ObjectObservable;

},{"../../System/EventHandler/PropertyChangedEventArgs":50,"../../System/Utility/ObjectFullAssign":61,"../ObservableBase":35}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ObjectProxyHandler {
    constructor(_methodsToWatch, _watchSet, _watchDelete, _triggerOnlyOnChange) {
        this._methodsToWatch = _methodsToWatch;
        this._watchSet = _watchSet;
        this._watchDelete = _watchDelete;
        this._triggerOnlyOnChange = _triggerOnlyOnChange;
    }
    get(target, key, proxy) {
        if (key in target) {
            const methodCalled = Reflect.get(target, key, proxy);
            // Silent pass-through of non-watched methods
            if (this._methodsToWatch.indexOf(key.toString()) === -1 || typeof methodCalled !== 'function') {
                return methodCalled;
            }
            // Return a wrapper around the method that publishes the change
            return (...args) => {
                const returnVal = methodCalled.apply(target, args);
                target.publishPropertyChanged('call', key, undefined, args, proxy);
                return returnVal;
            };
        }
    }
    set(target, key, value, proxy) {
        if (this._watchSet) {
            const oldValue = Reflect.get(target, key, proxy);
            Reflect.set(target, key, value, proxy);
            // If to be triggered only on change, check oldValue and newValue
            if (this._triggerOnlyOnChange && oldValue === value) {
                return true;
            }
            target.publishPropertyChanged('set', key, oldValue, value, proxy);
            return true;
        }
        else {
            Reflect.set(target, key, value, proxy);
            return true;
        }
    }
    deleteProperty(target, key) {
        if (this._watchDelete) {
            const oldValue = Reflect.get(target, key);
            Reflect.deleteProperty(target, key);
            // Cannot report proxy as sender because proxy not sent to this method
            target.publishPropertyChanged('delete', key, oldValue, undefined, null);
            return true;
        }
        else {
            Reflect.deleteProperty(target, key);
            return true;
        }
    }
}
exports.ObjectProxyHandler = ObjectProxyHandler;

},{}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ObservableProperty_1 = require("./ObservableProperty");
/**
 * This is a simple implementation of Object.assign() that understands ObservableProperty,
 * so that it can update the value of the property without wiping out references to the
 * existing property with that key (which is what would happen if you used regular Object.assign()
 * on a non-proxied object).  It can also be used to read the value of an ObservableProperty.
 */
function observableAssign(target, ...sources) {
    target = target || {};
    for (const src of sources) {
        for (const key of Object.getOwnPropertyNames(src)) {
            const sprop = src[key];
            const tprop = target[key];
            let val;
            if (ObservableProperty_1.observablePropertyCheck(sprop)) {
                val = sprop.value;
            }
            else {
                val = sprop;
            }
            if (ObservableProperty_1.observablePropertyCheck(tprop)) {
                tprop.value = val;
            }
            else {
                target[key] = val;
            }
        }
    }
}
exports.observableAssign = observableAssign;

},{"./ObservableProperty":36}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EventHandler_1 = require("../System/EventHandler/EventHandler");
/**
 * Common logic between the different observable classes. These implement IObservable. The invocation itself varies from class to class.
 */
class ObservableBase {
    constructor({ name, forwardTo, bubbleFrom, disableAsync } = {}) {
        this.changeHandler = new EventHandler_1.EventHandler();
        if (disableAsync) {
            this.changeHandler = new EventHandler_1.EventHandler(true);
        }
        if (forwardTo) {
            this.sendChangeEventsTo(forwardTo);
        }
        if (bubbleFrom) {
            for (const child of bubbleFrom) {
                this.receiveChangeEventsFrom(child);
            }
        }
        this.tagDelegate(name);
    }
    subscribe(callback, thisArg) {
        // Typescript has forgotten that EventHandler can accept an array.
        // In spite if the fact that this signature is identical.
        return this.changeHandler.subscribe(callback, thisArg);
    }
    /**
     * Subscribe the input's delegate to this object's changes.
     */
    sendChangeEventsTo(forwardTo) {
        // Join the other event handler to this, so that when this is invoked, so is the other.
        this.subscribe(forwardTo.changeHandler.delegate);
    }
    /**
     * Subscribe this object's delegate to the input object's changes.
     */
    receiveChangeEventsFrom(bubbleFrom) {
        // Subscribe to events raised on the other handler, so that when that is invoked, so is this
        // The same as forwardChangeEventsTo except that this is the target, not the source.
        bubbleFrom.subscribe(this.changeHandler.delegate);
    }
    unsubscribeCallback(callback) {
        return this.changeHandler.unsubscribeCallback(callback);
    }
    unsubscribeSender(sender) {
        return this.changeHandler.unsubscribeListener(sender);
    }
    unsubscribeDelegate(delegate) {
        return this.changeHandler.unsubscribeDelegate(delegate);
    }
    /**
     * This is probably frowned upon (see how TS doesn't like it), but it's valid JS.
     * It's only intended for troubleshooting, not real logic. There are times when you're
     * trying to identify exactly which delegates are subscribed, and this is really hard when
     * nothing has human-readable names.
     */
    tagDelegate(name) {
        if (name) {
            this.changeHandler.delegate._tag = name;
        }
    }
    dispose() {
        this.changeHandler.dispose();
    }
    toJSON() {
        const result = {};
        for (const x in this) {
            if (x !== "changeHandler" && x !== "privateProperty2") {
                result[x] = this[x];
            }
        }
        return result;
    }
}
exports.ObservableBase = ObservableBase;

},{"../System/EventHandler/EventHandler":49}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EscapeHtml_1 = require("../Html/EscapeHtml");
const PropertyChangedEventArgs_1 = require("../System/EventHandler/PropertyChangedEventArgs");
const NoneType_1 = require("../System/Types/NoneType");
const IsPrimitive_1 = require("../System/Utility/IsPrimitive");
const IObservable_1 = require("./IObservable");
const ObservableBase_1 = require("./ObservableBase");
/**
 * An ObservableProperty is a property that automatically raises a PropertyChanged event when it is modified. This is more
 * convenient than having to do it manually every time you need it.
 */
class ObservableProperty extends ObservableBase_1.ObservableBase {
    constructor(value, options = {}) {
        super(options);
        this.propertyName = "";
        this._triggerOnlyOnChange = false;
        options = options || {};
        this._value = value;
        this.propertyName = options.name || '';
        this._triggerOnlyOnChange = options.onlyWhenChanged || false;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        const old = this._value;
        this._value = value;
        if (this._triggerOnlyOnChange && old === value) {
            return;
        }
        this.publishPropertyChanged('set', this.propertyName, old, value, this);
    }
    /**
     * Get the value (if a string) that has had special HTML characters escaped.
     */
    get safeValue() {
        if (NoneType_1.isNone(this._value) || !IsPrimitive_1.isPrimitive(this._value)) {
            return "";
        }
        return EscapeHtml_1.escapeHtml(String(this._value));
    }
    toString() {
        return JSON.stringify(this._value);
    }
    toJSON() {
        return this._value;
    }
    publishPropertyChanged(type, propertyName, oldValue, newValue, sender) {
        this.changeHandler.invoke(new PropertyChangedEventArgs_1.PropertyChangedEventArgs({ type, propertyName, oldValue, newValue, sender }));
    }
}
exports.ObservableProperty = ObservableProperty;
function observablePropertyCheck(obj) {
    if (!IObservable_1.observableCheck(obj)) {
        return false;
    }
    // I don't like this because it should be checking if value is a setter,
    // and it isn't, because there is no way to check.
    // Object.getOwnPropertyDescriptor() doesn't catch inherited properties, of
    // which this is almost always one.
    // I have to fall back to a basic instance check.
    return obj && obj instanceof ObservableProperty;
}
exports.observablePropertyCheck = observablePropertyCheck;

},{"../Html/EscapeHtml":15,"../System/EventHandler/PropertyChangedEventArgs":50,"../System/Types/NoneType":53,"../System/Utility/IsPrimitive":60,"./IObservable":29,"./ObservableBase":35}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ArrayObservable_1 = require("./Internal/ArrayObservable");
const ArrayProxyHandler_1 = require("./Internal/ArrayProxyHandler");
const ObjectObservable_1 = require("./Internal/ObjectObservable");
const ObjectProxyHandler_1 = require("./Internal/ObjectProxyHandler");
class ObservableProxy {
    static proximate(model, disableAsync, onlyIfChanged) {
        if (typeof model === 'function') {
            // We can't do functions, not that they would be very useful.
            // Yes, technically you should be able to define properties on a function. They are actual
            // objects.  In practice, however, Object.defineProperty() still makes them undefined.
            throw new Error('Unsupported type: function');
        }
        else if (Array.isArray(model)) {
            // An array proxy allows changes to an array to be observed. The down-side is that performance
            // is an order of magnitude slower than using an ObservableList.  The up-side is that it uses
            // more than an order of magnitude less code.
            return this.proximateArray(model, disableAsync, onlyIfChanged);
        }
        else if (typeof model === 'object') {
            return this.proximateObject(model, disableAsync, onlyIfChanged);
        }
        else {
            // If a simple value is returned, return a proxy having a value property.
            return this.proximateObject({ value: model }, disableAsync, onlyIfChanged);
        }
    }
    /**
     * A configurable version of proximate() called on an object. By making it generalized and configurable, this allows the caller to
     * track methods that are called, based on a configurable list.
     *
     * If the object is a complex object, where child objects are modified, not the main object, changes would not be caught.
     * One way to handle that is to make the child object a proxy. Another way is to access the child object only through methods
     * and use this.
     */
    static proximateObject(model, disableAsync, onlyIfChanged, methodsToWatch = [], watchSet = true, watchDelete = true) {
        if (typeof model === 'function') {
            // We can't do functions, not that they would be very useful.
            // Yes, technically you should be able to define properties on a function. They are actual
            // objects.  In practice, however, Object.defineProperty() still makes them undefined.
            throw new Error('Unsupported type: function');
        }
        // Add IObservable methods to the model so that it can raise events.
        // We must extend the original class (or at least the object).
        const target = ObjectObservable_1.ObjectObservable.getMergedObservable(model, disableAsync);
        const handler = new ObjectProxyHandler_1.ObjectProxyHandler(methodsToWatch || [], watchSet || false, watchDelete || false, onlyIfChanged || false);
        const proxy = new Proxy(target, handler);
        ObservableProxy._models.set(proxy, target);
        return proxy;
    }
    /**
     * Proximate an array.
     */
    static proximateArray(model, disableAsync, onlyIfChanged) {
        // Add IObservable methods to the model so that it can raise events.
        // We must extend the original array class (or at least the array object).
        const target = ArrayObservable_1.ArrayObservable.getMergedObservable(model, disableAsync);
        // The type here isn't accurate, but I have no good way to pass the key type without making this class only work for arrays.
        const handler = new ArrayProxyHandler_1.ArrayProxyHandler();
        const proxy = new Proxy(target, handler);
        ObservableProxy._models.set(proxy, target);
        return proxy;
    }
}
// The original target object needs to be stored somewhere so that the proxy can work.
// There's no reason that the user can't keep a copy but we shouldn't force that.
ObservableProxy._models = new WeakMap();
exports.ObservableProxy = ObservableProxy;

},{"./Internal/ArrayObservable":30,"./Internal/ArrayProxyHandler":31,"./Internal/ObjectObservable":32,"./Internal/ObjectProxyHandler":33}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const EscapeHtml_1 = require("../Html/EscapeHtml");
const PropertyChangedEventArgs_1 = require("../System/EventHandler/PropertyChangedEventArgs");
const NoneType_1 = require("../System/Types/NoneType");
const CloneDeep_1 = require("../System/Utility/CloneDeep");
const IsPrimitive_1 = require("../System/Utility/IsPrimitive");
const IObservable_1 = require("./IObservable");
const ObservableBase_1 = require("./ObservableBase");
/**
 * An observable state that should only be accessed using the relevant methods, allowing atomic changes to multiple properties
 * in multiple objects, raising a single event.
 */
class ObservableState extends ObservableBase_1.ObservableBase {
    constructor(value, options = {}) {
        super(options);
        this.propertyName = "";
        if (value instanceof ObservableState) {
            this._value = CloneDeep_1.cloneDeep(value.value);
        }
        else {
            this._value = CloneDeep_1.cloneDeep(value);
        }
        options = options || {};
        this.propertyName = options.name || 'setState';
    }
    get value() {
        // I would prefer that this return Readonly<T> but getter and setter have to be the same type.
        // That means you would have to cast any value you set as a readonly, which is a PITA.
        return CloneDeep_1.cloneDeep(this._value);
    }
    /**
     * Overwrites the entire value.
     */
    set value(value) {
        this.setState(value, true);
    }
    getSafeValue(property) {
        // If value is primitive, then call this with no arguments.
        // That is the only case where it is allowed.
        if (!property) {
            if (!NoneType_1.isNone(this._value) && IsPrimitive_1.isPrimitive(this._value)) {
                return EscapeHtml_1.escapeHtml(String(this._value));
            }
            return "";
        }
        const tmp = this.value[property];
        if (NoneType_1.isNone(tmp) || !IsPrimitive_1.isPrimitive(tmp)) {
            return "";
        }
        return EscapeHtml_1.escapeHtml(String(tmp));
    }
    getValue(property) {
        // If value is primitive, then call this with no arguments.
        // That is the only case where it is allowed.
        if (!property) {
            if (!NoneType_1.isNone(this._value) && IsPrimitive_1.isPrimitive(this._value)) {
                return CloneDeep_1.cloneDeep(this._value);
            }
            return undefined;
        }
        return this.value[property];
    }
    getState() {
        // The Readonly type works fine and it's fast ... in typescript.
        // In javascript, if you just return the value, nothing prevents it from being edited.
        return CloneDeep_1.cloneDeep(this.value);
    }
    setState(value, overWriteAll = false) {
        const oldValue = CloneDeep_1.cloneDeep(this._value);
        let newValue;
        let returnValue;
        // If the type is primitive, then a full overwrite is allowed
        if (IsPrimitive_1.isPrimitive(this._value)) {
            // Functions will execute but they won't change the value. The reason is the same reason that this makes no permanent change to bar:
            // var foo = function(str) { str = str.toUpperCase(); }; var bar = 'abc'; foo(bar); console.log(bar === 'abc');
            if (typeof value === 'function') {
                throw new Error('Cannot call setState with a function if state is primitive.');
            }
            overWriteAll = true;
        }
        if (overWriteAll) {
            newValue = _ovr1_overwriteAll.call(this, value);
        }
        else if (typeof value === 'function') {
            [newValue, returnValue] = _ovr3_functionArg.call(this, value);
        }
        else {
            if (!value || typeof value !== 'object') {
                throw new Error('value is not a partial state or a function');
            }
            newValue = _ovr2_partial.call(this, value);
        }
        this.publishPropertyChanged('call', this.propertyName, oldValue, newValue, this);
        return { oldValue, newValue, returnValue };
        function _ovr1_overwriteAll(_value) {
            // Overwrite the entire object.
            this._value = CloneDeep_1.cloneDeep(_value);
            return _value;
        }
        function _ovr2_partial(_value) {
            // Partial object: Overwrite only the keys provided
            const tmp = CloneDeep_1.cloneDeep(this._value);
            for (const key of Object.getOwnPropertyNames(_value)) {
                tmp[key] = _value[key];
            }
            this._value = CloneDeep_1.cloneDeep(tmp);
            return tmp;
        }
        function _ovr3_functionArg(_value) {
            // Execute the function provided and update the object as dictated
            // Maybe unnecessary but we want to avoid the caller exfiltrating the state using a function,
            // by accident. Of course, they can just access _value by casting as any,
            // but that's not accidental.
            const tmp = CloneDeep_1.cloneDeep(this._value);
            const _returnValue = _value.call(tmp, tmp);
            this._value = CloneDeep_1.cloneDeep(tmp);
            return [tmp, _returnValue];
        }
    }
    toString() {
        return JSON.stringify(this._value);
    }
    toJSON() {
        return this.value;
    }
    publishPropertyChanged(type, propertyName, oldValue, newValue, sender) {
        this.changeHandler.invoke(new PropertyChangedEventArgs_1.PropertyChangedEventArgs({ type, propertyName, oldValue, newValue, sender }));
    }
}
exports.ObservableState = ObservableState;
function observableStateCheck(obj) {
    if (!IObservable_1.observableCheck(obj)) {
        return false;
    }
    // I don't know if I should check for this or for getState() and setState()
    return obj && obj instanceof ObservableState;
}
exports.observableStateCheck = observableStateCheck;

},{"../Html/EscapeHtml":15,"../System/EventHandler/PropertyChangedEventArgs":50,"../System/Types/NoneType":53,"../System/Utility/CloneDeep":55,"../System/Utility/IsPrimitive":60,"./IObservable":29,"./ObservableBase":35}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CreateElement_1 = require("../Html/CreateElement");
const DeleteNodeContent_1 = require("../Html/DeleteNodeContent");
const ElementType_1 = require("../Html/ElementType");
const ArrayUtilities_1 = require("../System/Collections/ArrayUtilities");
const Constructable_1 = require("../System/Types/Constructable");
const Elvis_1 = require("../System/Utility/Elvis");
/**
 * If you click a link in a real web site, the browser asks the server for a page and it routes you to the relevant
 * page. But if you have a single page app running on a file, with no web server, like the one this framework
 * was built for, you need something to simulate that.
 *
 * The Advanced version of the router was created to provide the recursively-nested routes that you can get with Angular.
 * It functions. But I hate it. I don't like setting up routes in Angular because it takes editing too many files even
 * for simple sites. That said, for a very large and complex site it's nice to have the organization, so there's that.
 *
 * I found this to be complex and brittle and if you want to use the advanced features (it's pretty trivial to have three
 * columns, each populated via the route, for example), it can get hard to set up and easy to break (be careful not
 * to try to populate a router-outlet you just replaced). In terms of real use cases, I would prefer simple routes
 * and do the work in components.
 *
 * But this is here, if you want to use it.
 *
 * This class clears the route container, which is expected to be a static container in the wrapper HTML page, or the body.
 * When you give it the relevant route, it executes the callback or returns the view/HTML element you defined for the route,
 * and sticks it inside the container. Then it searches for child routes to put into child route containers, etc,
 * until it runs out of children.
 */
class AdvancedPageRouter {
    static get matchedRoute() {
        return this._matchedRoute || { route: '', params: new Map() };
    }
    static get params() {
        return this.matchedRoute.params;
    }
    static get historyMaxLength() {
        return this._historyMaxLength;
    }
    static set historyMaxLength(value) {
        if (this._history.length > value) {
            this._history.length = value;
        }
        this._historyMaxLength = value;
    }
    static get history() {
        return this._history;
    }
    static set notFound(value) {
        this._notFound = value;
    }
    static configure(routes) {
        this._routes = routes;
    }
    /**
     * Set up a top-level route, which is expected to route to the main app container. This is expected to contain
     * a child-container element, which contains lower level routes that are stored as children, added using the addRoute()
     * method.
     */
    static addAppRoute(payload, route = '*', urlRoutingEnabled = true) {
        if (urlRoutingEnabled) {
            // By default, allows going to a new page by changing the URL instead of having to issue route() commands.
            this.turnOnUrlRouting();
        }
        if (Constructable_1.constructorTypeGuard(payload) || typeof payload === 'function') {
            this.addRoute({
                route: route,
                payload: payload,
                routeContainer: 'page-router',
                staticRouterContainer: true
            });
        }
        else {
            this.addRoute({
                route: route,
                payload: () => payload,
                routeContainer: 'page-router',
                staticRouterContainer: true
            });
        }
    }
    static addRoute(route) {
        if (this._routes.find(q => q.route === route.route &&
            (q.routeContainer || 'child-container') === (route.routeContainer || 'child-container'))) {
            throw new Error("Route and container already exists.");
        }
        this._routes.push(route);
    }
    static deleteRoute(route) {
        if (!this._routes.find(q => q.route === route)) {
            throw new Error("Route not found.");
        }
        // Removing items is such a pain.
        const routes = this._routes;
        for (let i = 0; i < routes.length; i++) {
            if (routes[i].route === route) {
                routes.splice(i, 1);
                continue;
            }
        }
    }
    static route(route, updateUrl = true) {
        if (!route) {
            // Allow actual links via the hash. Hash links don't force a page reload and they work w/o a web server.
            // To avoid having to call route() manually, you must call turnOnUrlRouting();
            route = window.location.hash.slice(1);
            // There is a problem, which is that setting the hash will trigger ANOTHER route chainge via the hashchange operation.
            // Removing the hash change and then restoring it later does nothing. It's still triggered.
            // This requires hackwork. So you see why this router is my least favorite part of this framework. It's a pile of hacks:
            // If this was triggered by a hash change and the route is the same, then don't do anything.
            // Clear the last route so that it doesn't interfere with the next hash change.
            if (route === this._lastRoute) {
                this._lastRoute = undefined;
                return;
            }
        }
        else if (updateUrl) {
            // If a route is sent in, then set the hash.
            window.location.hash = route;
            this._lastRoute = route;
        }
        else {
            this._lastRoute = route;
        }
        // Get a copy of routes, because (1) the list will be modified and (2) reduce accesses to static properties.
        // I'm not sure if async hash update events will all be in the same thread, but this isn't thread-safe.
        const routeCopy = this._routes.slice(0).map(m => ({ route: m }));
        // Find matching routes. Typically there will be 0 to 1 but the router allows multiples, one per container.
        const matches = [];
        const params = [];
        for (const r of routeCopy) {
            const searchResult = this._searchRoutes(route, r.route, routeCopy);
            if (searchResult) {
                params.push(searchResult);
                matches.push(r);
            }
        }
        if (!matches.length) {
            // tslint:disable-next-line:no-console
            console.log(`Route ${route} not found.`);
            this._renderNotFound();
            return;
        }
        // If parameters are found in multiple routes, the params are merged, but ONLY THE FIRST value for any param is kept
        // Params will be stored in a global collection. I'm not going to split them up and make the programmer hunt for them.
        const merged = new Map();
        for (const p of params) {
            for (const entry of p.entries()) {
                if (!merged.has(entry[0])) {
                    merged.set(entry[0], entry[1]);
                }
            }
        }
        /* Start writing data */
        this._matchedRoute = { route: route, params: merged };
        // Add route to history if it's different from the previous latest history
        if (this.history.length === 0 || this.history[this.history.length - 1] !== route) {
            this._history.push(route);
        }
        if (this.history.length > this.historyMaxLength) {
            this._history.shift();
        }
        const rcClone = this._routeContainers.slice(0);
        // Any containers from the previous iteration that are not matched in this one should be removed
        // Only keep ones where the staticRouterContainer flag is set
        for (const prev of rcClone
            .filter(rc => !matches.find(m => m.route === rc.route) || !rc.route.staticRouterContainer)) {
            if (prev.container) {
                prev.container.remove();
            }
            const index = rcClone.findIndex(f => f === prev);
            rcClone.splice(index, 1);
        }
        // Add route containers that aren't still there from the last iteration
        rcClone.push(...matches
            .filter(m => !rcClone.find(rc => rc.route === m.route)));
        // The containers need to be in order of matches, but previous iterations are there earlier.
        // This is too weird to work in the sort command, afaik
        const source = rcClone.slice(0);
        const sortedTarget = [];
        for (const match of matches) {
            const r = source.find(q => q.route === match.route);
            if (!r) {
                throw new Error('How did a route not get added to routeContainers?');
            }
            sortedTarget.push(r);
        }
        this._routeContainers = sortedTarget;
        for (const match of matches) {
            let routeGuards = [];
            if (Array.isArray(match.route.routeGuards)) {
                routeGuards = match.route.routeGuards;
            }
            else if (match.route.routeGuards) {
                routeGuards.push(match.route.routeGuards);
            }
            for (const rg of routeGuards) {
                const test = rg.checkValid(match.route);
                if (test === false) {
                    // tslint:disable-next-line:no-console
                    console.warn('Route permission denied');
                    continue;
                }
            }
            this._renderRoute(match);
        }
    }
    static back() {
        // If there isn't any history to go back to, don't go back.
        if (this.history.length < 2) {
            return;
        }
        this._history.pop(); // Current route sits at the top of the stack
        const route = this._history.pop(); // previous route
        if (route !== undefined) {
            this.route(route);
        }
    }
    static turnOnUrlRouting() {
        this._hashChange = (evt) => { this.route(); };
        window.addEventListener('hashchange', this._hashChange);
    }
    static _searchRoutes(url, route, routesToSearch) {
        let search = [];
        if (Array.isArray(route.route)) {
            search = route.route;
        }
        else {
            search = [route.route];
        }
        // Search the route strings and if you find one, return the match.
        // Note that if you have multiple routes in the array, with different params, the results will be only the first.
        // Seriously, don't do that. At least one of those routes is gibberish.
        for (const sch of search) {
            const matchResult = this._testRoute(sch, url || '');
            if (matchResult) {
                // If the route has children, then add them to the end of the match list to be tested
                // This works because JS is perfectly OK with modifying an array that you are iterating, unlike C#
                if (route.children) {
                    for (const child of route.children) {
                        routesToSearch.push({ route: child, parent: route });
                    }
                }
                return matchResult;
            }
        }
        return false;
    }
    static _testRoute(routeString, urlString) {
        const params = new Map();
        if (!routeString || !urlString) {
            return false;
        }
        routeString = routeString.toLowerCase();
        if (routeString.endsWith('/')) {
            routeString = routeString.slice(0, -1);
        }
        if (urlString.endsWith('/')) {
            urlString = urlString.slice(0, -1);
        }
        const routeArray = routeString.split('/');
        const urlArray = urlString.split('/');
        // If route ends in *, don't check anything further than that in the URL
        if (routeArray[routeArray.length - 1] === '*') {
            routeArray.length--;
            if (routeArray.length <= urlArray.length) {
                urlArray.length = routeArray.length;
            }
        }
        // Same number of / characters required.
        if (routeArray.length !== urlArray.length) {
            return false;
        }
        for (const [routeSegment, urlSegment] of ArrayUtilities_1.zip(routeArray, urlArray)) {
            // Parameters are allowed. Optional parameters are not.
            // The reason for no optional parameters is that finding a match between /a/:?param/b and /a/b is too complex.
            // Is 'b' a param value or part of the route. Basically, optional parameters only work at the route end.
            // I noticed that ASP.NET works that way, and I found it confusing that optional parameters only work at the end.
            // Just create a new route with the optional param left out.
            if (routeSegment.startsWith(':')) {
                if (params.has(urlSegment.slice(1))) {
                    throw new Error(`Route ${routeString} contains duplicates of the same parameter.`);
                }
                params.set(routeSegment.slice(1), urlSegment);
            }
            else if (routeSegment !== '*' && routeSegment !== urlSegment.toLowerCase()) {
                return false;
            }
        }
        return params;
    }
    static _renderRoute({ route, parent }) {
        const container = this._prepareRouterContainer(route, parent);
        if (!container) {
            return;
        }
        let view;
        if (Constructable_1.constructorTypeGuard(route.payload)) {
            view = new route.payload();
        }
        else if (route.payload) {
            view = route.payload();
        }
        // If a view was returned
        if (view && viewTypeGuard(view)) {
            container.appendChild(view.content);
        }
        else if (view) {
            container.appendChild(view);
        }
        function viewTypeGuard(test) {
            if ("content" in test && test.content instanceof HTMLElement) {
                return true;
            }
            return false;
        }
    }
    static _renderNotFound() {
        const container = CreateElement_1.createElement('not-found', { id: 'not-found' });
        DeleteNodeContent_1.deleteNodeContent(document.body);
        document.body.appendChild(container);
        container.appendChild(CreateElement_1.createElement(ElementType_1.elementType.HTMLDivElement, { innerHTML: this._notFound || "Quoth the Raven, 404" }));
    }
    static _prepareRouterContainer(route, parentRoute) {
        if (!this._matchedRoute) {
            throw new Error('ProgrammingError: _prepareRouterContainer called out of order.');
        }
        // Look for the route container for the route. If it exists, exit doing nothing. We'll keep it.
        const routeContainer = this._routeContainers.find(f => f.route === route);
        if (!routeContainer) {
            throw new Error("ProgrammingError: Forgot to add routes to route containers.");
        }
        let parent;
        // See if this route has a parent that is on the page
        parent = Elvis_1.e_(this._routeContainers.find(q => q.route === parentRoute)).container;
        if (parent && !document.body.contains(parent)) {
            parent = undefined;
        }
        // If the route has a container, that container exists in the dom, and the staticRouterContainer setting is true, exit
        if (route.staticRouterContainer && routeContainer.container && (parent || document.body).contains(routeContainer.container)) {
            return;
        }
        const containerId = Elvis_1.e_(route).routeContainer || 'child-container';
        // If the parent container doesn't exist in the dom, add to the body.
        if (!parent || !document.body.contains(parent)) {
            // I would think there's always a body element, but typescript seems to think it could be undefined
            // This didn't actually fix the TS error, though.
            if (!document.body) {
                document.createElement('body');
            }
            parent = document.body;
        }
        const currentIndex = this._routeContainers.findIndex(q => q.route === route);
        if (this._routeContainers
            .slice(0, currentIndex) // Only check earlier containers
            .find(q => !!q.container
            && q.container.tagName.toLowerCase() === containerId.toLowerCase()
            && !!parent.querySelector(containerId))) {
            // tslint:disable-next-line:no-console
            console.log(`Route: [${route.route}]. Container [${containerId}] added to DOM by another route. Skipping.`);
            return;
        }
        const newRouter = CreateElement_1.createElement(containerId); /* { id: containerId } */
        const oldRouter = parent.querySelector(containerId);
        if (oldRouter) {
            (oldRouter.parentElement || parent).replaceChild(newRouter, oldRouter);
        }
        else {
            parent.appendChild(newRouter);
        }
        // Update the route container record with the routing container we created.
        routeContainer.container = newRouter;
        return newRouter;
    }
}
AdvancedPageRouter._routes = [];
AdvancedPageRouter._history = [];
AdvancedPageRouter._historyMaxLength = 50;
AdvancedPageRouter._routeContainers = [];
exports.AdvancedPageRouter = AdvancedPageRouter;

},{"../Html/CreateElement":12,"../Html/DeleteNodeContent":13,"../Html/ElementType":14,"../System/Collections/ArrayUtilities":45,"../System/Types/Constructable":51,"../System/Utility/Elvis":57}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CreateElement_1 = require("../Html/CreateElement");
const DeleteNodeContent_1 = require("../Html/DeleteNodeContent");
const ElementType_1 = require("../Html/ElementType");
const ArrayUtilities_1 = require("../System/Collections/ArrayUtilities");
const Constructable_1 = require("../System/Types/Constructable");
const KeywordArguments_1 = require("../System/Types/KeywordArguments");
const NoneType_1 = require("../System/Types/NoneType");
/**
 * If you click a link in a real web site, the browser asks the server for a page and it routes you to the relevant
 * page. But if you have a single page app running on a file, with no web server, like the one this framework
 * was built for, you need something to simulate that.
 *
 * This class clears the route container, which is expected to be a static container in the wrapper HTML page, or the body.
 * When you give it the relevant route, it executes the callback or returns the view/HTML element you defined for the route,
 * and sticks it inside the container. The element returned can be wrapped in a layout view, like in ASP.Net.
 *
 * This is a simple version, without the recursive routes found in the advanced router. It was based more on ASP.Net or node.js
 * routing, where you have a flat set of routes and once you find a route, you're done.
 */
class PageRouter {
    static get allRoutes() {
        return this._routes;
    }
    static get matchedRoute() {
        return this._matchedRoute || { route: '', params: new Map(), config: { route: '' } };
    }
    static get params() {
        return this.matchedRoute.params;
    }
    static get historyMaxLength() {
        return this._historyMaxLength;
    }
    static set historyMaxLength(value) {
        if (this._history.length > value) {
            this._history.length = value;
        }
        this._historyMaxLength = value;
    }
    static get history() {
        return this._history;
    }
    static set notFound(value) {
        this._notFound = value;
    }
    /**
     * This must be called first before using it, because JS doesn't have static constructors like C#. It sets up the
     * route container, custom elements, and also allows one-step configuration of several other properties.
     *
     * Accepts Keyword Arguments.
     */
    static configure(routes = [], defaultLayout, defaultStaticLayout, notFound, defaultRoute, urlRoutingEnabled = true) {
        ({ routes, defaultLayout, defaultStaticLayout, notFound, defaultRoute, urlRoutingEnabled = true } = KeywordArguments_1.Kwarg.parseArgs({ routes, defaultLayout, defaultStaticLayout, notFound, defaultRoute, urlRoutingEnabled })); // kwargline
        this._configured = true;
        if (notFound) {
            this._notFound = notFound;
        }
        for (const rte of routes) {
            if (defaultLayout) {
                rte.layout = rte.layout || defaultLayout;
            }
            if (!NoneType_1.isNone(defaultStaticLayout) && NoneType_1.isNone(rte.staticLayout)) {
                rte.staticLayout = defaultStaticLayout;
            }
            this.addRoute(rte);
        }
        if (urlRoutingEnabled) {
            // By default, allows going to a new page by changing the URL instead of having to issue route() commands.
            this.turnOnUrlRouting();
        }
        this.routeContainer = document.querySelector('page-router') || document.body;
        try {
            if (!window.customElements.get('page-router')) {
                window.customElements.define('page-router', DivPage, { extends: 'div' });
            }
            if (!window.customElements.get('layout-body')) {
                window.customElements.define('layout-body', DivLayout, { extends: 'div' });
            }
            if (!window.customElements.get('not-found')) {
                window.customElements.define('not-found', DivNotFound, { extends: 'div' });
            }
        }
        catch (err) {
            // customElements isn't officially part of an ES version yet so won't work even in some recent-ish browsers
        }
        if (defaultRoute) {
            this.defaultRoute(defaultRoute);
        }
    }
    // Note: there is no removeRoute. There could be, but it's never needed.
    static addRoute(route) {
        let routes;
        if (Array.isArray(route.route)) {
            routes = route.route;
        }
        else {
            routes = [route.route];
        }
        for (const rte of routes) {
            if (this._routes.find(q => q.route === rte)) {
                throw new Error("Route already exists.");
            }
            const tmp = Object.assign({}, route);
            tmp.route = rte;
            this._routes.push(tmp);
        }
    }
    /**
     * If linked to a particular page (on the hash), go to it. Else, go to the route specified.
     */
    static defaultRoute(route) {
        if (window.location.hash) {
            PageRouter.route();
        }
        else {
            PageRouter.route(route);
        }
    }
    static route(route, updateUrl = true) {
        if (!this._configured) {
            throw new Error('PageRouter not configured. Call configure() first.');
        }
        if (!route) {
            // Allow actual links via the hash. Hash links don't force a page reload and they work w/o a web server.
            // To avoid having to call route() manually, you must call turnOnUrlRouting();
            route = window.location.hash.slice(1);
            // There is a problem, which is that setting the hash will trigger ANOTHER route chainge via the hashchange operation.
            // Removing the hash change and then restoring it later does nothing. It's still triggered.
            // This requires hackwork. Even the simple router has more hacks than I like.
            // If this was triggered by a hash change and the route is the same, then don't do anything.
            // Clear the last route so that it doesn't interfere with the next hash change.
            if (route === this._lastRoute) {
                this._lastRoute = undefined;
                return;
            }
        }
        else if (updateUrl) {
            // If a route is sent in, then set the hash.
            window.location.hash = route;
            this._lastRoute = route;
        }
        else {
            this._lastRoute = route;
        }
        let match;
        let searchResult = false;
        for (const rte of this._routes) {
            searchResult = this._testRoute(rte.route, route || '');
            if (searchResult) {
                match = rte;
                break;
            }
        }
        if (!match) {
            // tslint:disable-next-line:no-console
            console.log(`Route ${route} not found.`);
            this._renderNotFound();
            return;
        }
        const previousRoute = (this._matchedRoute || {}).config;
        this._matchedRoute = { route, params: searchResult || new Map(), config: match };
        // Add route to history if it's different from the previous latest history
        if (this.history.length === 0 || this.history[this.history.length - 1] !== route) {
            this._history.push(route);
        }
        if (this.history.length > this.historyMaxLength) {
            this._history.shift();
        }
        let routeGuards = [];
        if (Array.isArray(match.routeGuards)) {
            routeGuards = match.routeGuards;
        }
        else if (match.routeGuards) {
            routeGuards.push(match.routeGuards);
        }
        for (const rg of routeGuards) {
            const test = rg.checkValid(match);
            if (test === false) {
                // tslint:disable-next-line:no-console
                console.warn('Route permission denied');
                return;
            }
        }
        this._renderRoute(match, previousRoute);
    }
    static back() {
        // If there isn't any history to go back to, don't go back.
        if (this.history.length < 2) {
            return;
        }
        this._history.pop(); // Current route sits at the top of the stack
        const route = this._history.pop(); // previous route
        if (route !== undefined) {
            this.route(route);
        }
    }
    static turnOnUrlRouting() {
        this._hashChange = (evt) => { this.route(); };
        window.addEventListener('hashchange', this._hashChange);
    }
    static _testRoute(routeString, urlString) {
        const params = new Map();
        if (!routeString || !urlString) {
            return false;
        }
        routeString = routeString.toLowerCase();
        if (routeString.endsWith('/')) {
            routeString = routeString.slice(0, -1);
        }
        if (urlString.endsWith('/')) {
            urlString = urlString.slice(0, -1);
        }
        const routeArray = routeString.split('/');
        const urlArray = urlString.split('/');
        // Same number of / characters required.
        if (routeArray.length !== urlArray.length) {
            return false;
        }
        for (const [routeSegment, urlSegment] of ArrayUtilities_1.zip(routeArray, urlArray)) {
            // Parameters are allowed. Optional parameters are not.
            // The reason for no optional parameters is that finding a match between /a/:?param/b and /a/b is too complex.
            // Is 'b' a param value or part of the route. Basically, optional parameters only work at the route end.
            // I noticed that ASP.NET works that way and I found it confusing that optional parameters only work at the end.
            // Just create a new route with the optional param left out.
            if (routeSegment.startsWith(':')) {
                let name = routeSegment.slice(1);
                if (!name.includes('=')) {
                    if (params.has(name)) {
                        throw new Error(`Route ${routeString} contains duplicates of the same parameter.`);
                    }
                    params.set(name, urlSegment);
                }
                else {
                    // Handle the mapped static param case.
                    const val = name.split('=')[1];
                    name = name.split('=')[0];
                    if (val !== urlSegment) {
                        return false;
                    }
                    if (params.has(name)) {
                        throw new Error(`Route ${routeString} contains duplicates of the same parameter.`);
                    }
                    params.set(name, urlSegment);
                }
            }
            else if (routeSegment !== urlSegment.toLowerCase()) {
                return false;
            }
        }
        return params;
    }
    static _renderRoute(route, previous) {
        // Calling PageRouter.route('the same url') will reload the contents from scratch.
        // Adjusting window.location will do nothing if the route is the same.
        // I think this is fine, after struggling in angular to reload the page and finding
        // it much harder.
        // Note if you change the location bar, Chrome forces a reload of Program.ts, nothing you can do
        // about it because Chrome is the one that discarded your state.
        let container = this.routeContainer;
        const keepLayout = route.layout && previous && route.staticLayout && route.layout === previous.layout;
        if (!keepLayout) {
            // Delete contents of page-router
            DeleteNodeContent_1.deleteNodeContent(container);
        }
        if (keepLayout) {
            container = document.querySelector('layout-body');
            if (!container) {
                throw new Error('<layout-body> element not found');
            }
        }
        else if (route.layout) {
            let layoutView;
            if (Constructable_1.constructorTypeGuard(route.layout)) {
                layoutView = new route.layout();
            }
            else if (route.payload) {
                layoutView = route.layout();
            }
            if (layoutView && viewTypeGuard(layoutView)) {
                container.appendChild(layoutView.content);
            }
            else if (layoutView) {
                container.appendChild(layoutView);
            }
            container = document.querySelector('layout-body');
            if (!container) {
                throw new Error('<layout-body> element not found');
            }
        }
        if (keepLayout) {
            // Delete contents of layout-body (but keep layout)
            DeleteNodeContent_1.deleteNodeContent(container);
        }
        let view;
        if (Constructable_1.constructorTypeGuard(route.payload)) {
            view = new route.payload();
        }
        else if (typeof route.payload === 'function') {
            view = route.payload();
        }
        else if (route.payload) {
            view = route.payload.cloneNode(true);
        }
        if (view && viewTypeGuard(view)) {
            container.appendChild(view.content);
        }
        else if (view) {
            container.appendChild(view);
        }
        function viewTypeGuard(test) {
            if ("content" in test && test.content instanceof HTMLElement) {
                return true;
            }
            return false;
        }
    }
    static _renderNotFound() {
        DeleteNodeContent_1.deleteNodeContent(this.routeContainer);
        this.routeContainer.appendChild(CreateElement_1.createElement(ElementType_1.elementType.HTMLDivElement, { id: 'not-found', innerHTML: this._notFound || "Quoth the Raven, 404" }));
    }
}
PageRouter.routeContainer = document.body;
PageRouter._configured = false;
PageRouter._routes = [];
PageRouter._history = [];
PageRouter._historyMaxLength = 50;
exports.PageRouter = PageRouter;
// tslint:disable:max-classes-per-file
// A class is required but you're not allowed to use the existing class because it can't
// be constructed (invalid constructor). And you are ONLY allowed to extend HTMLElement.
// AND they must be unique.
class DivPage extends HTMLElement {
    constructor() {
        super();
    }
}
class DivLayout extends HTMLElement {
    constructor() {
        super();
    }
}
class DivNotFound extends HTMLElement {
    constructor() {
        super();
    }
}

},{"../Html/CreateElement":12,"../Html/DeleteNodeContent":13,"../Html/ElementType":14,"../System/Collections/ArrayUtilities":45,"../System/Types/Constructable":51,"../System/Types/KeywordArguments":52,"../System/Types/NoneType":53}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A deferred promise is a wrapper around a promise that allows it to be triggered later. In pure JS, this is harder
 * than it needs to be, and it takes a weird hack to make it work. This class is little more than a wrapper around
 * said hack.
 *
 * Otherwise, this uses a real promise internally, so aside from the wrapping object, it has no special logic. I chose
 * not to re-implement the Promise API synchronously, so it uses the same microtask queue.
 *
 * The wrapping API is tweaked a little to avoid some common pitfalls that are caused by flaws in the Promise
 * design. For example, having onfulfilled and onrejected in the same step means that errors in the fulfilled
 * half will not be caught by the error handler.  Rather than say "don't use that input" like most instructors,
 * I just got rid of it (it's still accessible on the output property, if you want to use it ... but don't).
 */
class DeferredPromise {
    constructor(onfulfilled, throwOnUnhandledError = false) {
        this.throwOnUnhandledError = throwOnUnhandledError;
        /** Use this to invoke the callback */
        // tslint:disable-next-line:no-empty TS doesn't know that the properties are replaced in the promise in the constructor
        this.resolve = function _dummy() { };
        /** Use this to reject the promise right out. Which is probably useless but you never know. */
        // tslint:disable-next-line:no-empty TS doesn't know that the properties are replaced in the promise in the constructor
        this.reject = function _dummy() { };
        // This is the weird hack that is the basis of this class. It's a closure, but reversed, as the
        // enclosed property is an internal reference accessed outside rather than an outside reference
        // accessed inside.
        this._promise = new Promise((_resolve, _reject) => {
            this.resolve = _resolve;
            this.reject = _reject;
        });
        // Make sure that there is always something at the first level, even if it's just returning the result.
        // We want the default behavior to allow the following:
        // const waitable = new DeferredPromise(); event.subscribe(waitable.resolve); const r = await waitable.output; console.log(r);
        // If you leave out the initial callback, you'll get undefined instead of what the event sends.
        if (onfulfilled) {
            this.then(onfulfilled, throwOnUnhandledError);
        }
        else {
            this.then(res => res, throwOnUnhandledError);
        }
    }
    /**
     * Use in async/await code. The following will work if a result is returned.
     * const result = await deferred.output;
     * console.log(result);
     */
    get output() {
        return this._promise;
    }
    /** Then() only has one option, because it's too easy to forget that the onrejected callback doesn't handle the onfulled callback. */
    then(onfulfilled, throwOnUnhandledError = this.throwOnUnhandledError) {
        if (onfulfilled) {
            this._promise = this._promise.then(onfulfilled);
        }
        // This is to keep a promise from, by default, eating up all errors. It's ugly.
        // It means a lot of extra steps. It makes sure that by default, the last step is always a catch.
        if (throwOnUnhandledError) {
            this._promise = this._promise.catch(err => { throw (err); });
        }
        return this;
    }
    catch(onrejected, throwOnUnhandledError = this.throwOnUnhandledError) {
        if (onrejected) {
            this._promise = this._promise.catch(onrejected);
        }
        // Again this is a mess, but the catch handler above could throw
        if (throwOnUnhandledError) {
            this._promise = this._promise.catch(err => { throw (err); });
        }
        return this;
    }
}
exports.DeferredPromise = DeferredPromise;

},{}],42:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function delay(time) {
    return (result) => new Promise(resolve => setTimeout(() => resolve(result), time));
}
exports.delay = delay;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DeferredPromise_1 = require("./DeferredPromise");
/**
 * Creates a dedicated web worker that communicates via deferreds. It can execute whatever function
 * you give it. TaskStart() acts kind of like doing new Thread() and Thread.Start() in one step.
 * It is possible to do all this manually, but this helper class makes it a fairly trivial operation.
 *
 * Hackwork is used to avoid the need to create a specialized web worker js file. The worker created takes a
 * function and arguments, executes them in its own thread, and returns the result.
 *
 * Further hackwork is needed because web works have no access to modules, no access to closures, and can only
 * communiate in strings. The function to be executed needs to be passed as a string in the message between
 * threads.
 *
 * While it is possible to create a version that does not need to eval() the function string on every execution,
 * this requires the caller to manually code everything that you see in here the constructor. No helpers are allowed
 * (no access to other objects). If you wanted to do everything yourself, you could just make a web worker the right
 * way, without the helper.
 */
class DynamicWebWorker {
    constructor() {
        this.deferredId = 0;
        this.deferreds = new Map();
        function setupFunc() {
            const ctx = self;
            // Set up what happens when a message is sent to the worker.
            // If you're willing to write all this, but remember to define your fn function
            // before onmessage, you can skip the eval() step.
            ctx.onmessage = function (evt) {
                const { id, fn, args } = evt.data;
                try {
                    // This hack allows a single dedicated web worker to handle any function. Because
                    // the worker has no access to closures, it has no access to complex objects. It
                    // can only get the function to execute in the message, which contains simple objects
                    // only, strings and numbers. So it has to be serialized and then deserialized.
                    // The only way to deserialize it is to eval() it. Pretty horriffic.
                    // tslint:disable-next-line:prefer-const
                    let inputFunc;
                    // tslint:disable-next-line:no-eval
                    eval("inputFunc = " + fn + ";");
                    const argarray = JSON.parse(args) || [];
                    const result = inputFunc(...argarray); // Evaluate the function
                    // Send the response back.
                    ctx.postMessage({ id, result: JSON.stringify(result) });
                }
                catch (err) {
                    ctx.postMessage({ id, error: err });
                }
            };
        }
        this._setUpWorker(setupFunc);
    }
    /**
     * Starting a task returns a deferred promise that is resolved when the worker thread has completed its task.
     *
     * Remember that closures DO NOT WORK. Pass your arguments (which must be JSON.stringifiable).
     */
    taskStart(fn, ...args) {
        const id = this.deferredId++;
        const msg = {
            id,
            fn: fn.toString(),
            args: JSON.stringify(args)
        };
        const deferred = new DeferredPromise_1.DeferredPromise();
        this.deferreds.set(id, deferred);
        this.worker.postMessage(msg);
        return deferred.output
            .then(resp => JSON.parse(resp || ''))
            .catch(err => { throw (err || new Error('Unknown error')); });
    }
    _setUpWorker(callback) {
        // Here's the main hack and it's a doozy.
        // Normally, you are required to create a special worker.js file for web workers and link
        // to them when loading the page. Obviously that makes it impossible to define them at runtime.
        // To get around the limitation, this encodes the worker as an object URL (which requires conversion
        // to a string) and loads that.
        this.worker = new Worker(URL.createObjectURL(new Blob(['(' + callback.toString() + ')();'])));
        this.worker.onmessage = evt => {
            const { id, result, error } = evt.data;
            const deferred = this.deferreds.get(id);
            if (!deferred) {
                throw new Error("Deferred promise is missing.");
            }
            if (error) {
                deferred.reject(error);
            }
            else {
                deferred.resolve(result);
            }
            this.deferreds.delete(id);
        };
    }
}
exports.DynamicWebWorker = DynamicWebWorker;

},{"./DeferredPromise":41}],44:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const DeferredPromise_1 = require("./DeferredPromise");
/**
 * The promise API is nice, mostly, but the main thing preventing use of a promise as an event handler is that
 * it only executes once. After that point, it is resolved, and there is no way to flip it back.
 *
 * The repeatable promise keeps the promise API and creates the illusion that the promise is repeated by
 * rebuilding the chain each time. It's really a deferred factory but it pretends to be a deferred. I'm sure
 * this has a performance penalty.
 *
 * You should not attach actual promises into the then() chain, because they can't be repeated. The Promise type isn't
 * allowed but there are ways to get around the TS compiler. The TS type definition for Promise and PromiseLike isn't
 * completely correct, anyway, so it's easy to get used to using the any type and make broken code.
 *
 * You cannot async/await a repeatable promise itself but you can await a single resolution. Async/await is sugar that
 * creates a regular, non-repeatable, promise.
 */
class RepeatablePromise {
    constructor(onfulfilled, onUnhandledError, // This adds a callback at the end (or 2nd from the end, see next option)
    throwOnUnhandledError = false // This keeps a promise from, by default, eating up all errors. It adds a final catch that throws if hit.
    ) {
        this.onUnhandledError = onUnhandledError;
        this.throwOnUnhandledError = throwOnUnhandledError; // This keeps a promise from, by default, eating up all errors. It adds a final catch that throws if hit.
        this.callbacks = [];
        // Make sure that there is always something at the first level, even if it's just returning the result. Useful for async/await code.
        if (onfulfilled) {
            this.then(onfulfilled);
        }
        else {
            this.then(res => res);
        }
    }
    // The following should work:
    // const repeatable = new RepeatablePromise(); const r = await repeatable.resolve(); console.log(r);
    resolve(args) {
        const promise = this.build();
        promise.resolve(args);
        return promise.output;
    }
    reject(args) {
        const promise = this.build();
        promise.reject(args);
        return promise.output;
    }
    // Then() only has one option, because it's too easy to forget that the onrejected callback doesn't handle the onfulled callback.
    then(onfulfilled) {
        this.callbacks.push({ onfulfilled: onfulfilled });
        return this;
    }
    catch(onrejected) {
        this.callbacks.push({ onrejected: onrejected });
        return this;
    }
    build() {
        let promise;
        for (const cb of this.callbacks) {
            if (!promise) {
                // We know that the first is always onfulfilled and is never undefined
                if (!cb.onfulfilled) {
                    throw new Error("Bug in RepeatablePromise constructor. First onfulfilled is null.");
                }
                promise = new DeferredPromise_1.DeferredPromise(cb.onfulfilled, false);
            }
            else if (cb.onfulfilled) {
                promise.then(cb.onfulfilled);
            }
            else if (cb.onrejected) {
                promise.catch(cb.onrejected);
            }
        }
        if (!promise) {
            throw new Error("Bug in RepeatablePromise constructor. No callbacks, not even the default first onfulfilled.");
        }
        if (this.onUnhandledError) {
            promise.catch(this.onUnhandledError);
        }
        if (this.throwOnUnhandledError) {
            promise.catch(err => { throw (err); });
        }
        return promise;
    }
}
exports.RepeatablePromise = RepeatablePromise;

},{"./DeferredPromise":41}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Return elements of array a lined up with elements of array b. Both arrays don't have to be the same length.
 */
function zip(a, b) {
    if (a.length >= b.length) {
        return a.map((element, index) => [element, b[index]]);
    }
    else {
        return b.map((element, index) => [a[index], b]);
    }
}
exports.zip = zip;
/**
 * Return a cartesian join (cross join) between arrays a and b.
 */
function cartesian(a, b) {
    /// typescript prevents a direct use of concat, so do this manually with a loop
    const results = [];
    for (const item of a) {
        results.push(...b.map(q => [item, q]));
    }
    return results;
}
exports.cartesian = cartesian;
/**
 * Generate a range of integers, counting up by 1, for the given length. Stolen from Python.
 */
function range(length) {
    return Array.from({ length: length }, (value, key) => key);
}
exports.range = range;
/**
 * Given an array of items and other arrays, flatten them out into a single array.
 */
function* traverse(arr) {
    if (!Array.isArray(arr)) {
        yield arr;
    }
    else {
        for (const row of arr) {
            yield* traverse(row);
        }
    }
}
exports.traverse = traverse;

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Make it easier to create simple comparison functions on (possibly complex) objects. Typical use: arr.sort(orderBy(o => o.id))
 */
function orderBy(propertyFn) {
    return function (first, second) {
        const firstValue = propertyFn(first);
        const secondValue = propertyFn(second);
        if (firstValue < secondValue) {
            return -1;
        }
        if (firstValue > secondValue) {
            return 1;
        }
        return 0;
    };
}
exports.orderBy = orderBy;

},{}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ArrayChangedEventArgs {
    constructor(args) {
        /**
         * The type of operation (method, set, delete)
         */
        this.type = '';
        this.propertyName = '';
        this.args = [];
        Object.assign(this, args);
    }
}
exports.ArrayChangedEventArgs = ArrayChangedEventArgs;

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RepeatablePromise_1 = require("../Async/RepeatablePromise");
/**
 * A delegate object is used by the EventHandler. It contains enough information to execute a callback synchronously or asynchronously
 * (using a promise). It also adds some strings to help in troubleshooting, because searching a recursive array of complex objects can make
 * it a bear to find out why a callback isn't being executed.
 */
class Delegate {
    constructor(callback, thisArg) {
        // In many cases (for example, when using fat arrow functions), thisArg is
        // not needed. But in most others, it is an annoying bug that requires troubleshooting
        // to figure out what the caller forgot. I've wavered between making it required and not.
        if (!thisArg) {
            // tslint:disable-next-line:no-console
            console.warn('Delegate created without thisArg. Did you mean to?');
        }
        this.thisArg = thisArg;
        if (thisArg && typeof thisArg === 'object' && 'constructor' in thisArg) {
            this.callbackOwnerName = thisArg.constructor.name;
        }
        if (!callback) {
            throw new Error("callback is required");
        }
        // The typescript compiler should handle this check but can't at runtime.
        if (typeof callback !== 'function') {
            throw new Error("callback must be a callback function");
        }
        this.callback = callback;
        this.callbackName = callback.name;
        if (this.callbackOwnerName && this.callbackName) {
            this.name = `${this.callbackOwnerName}.${this.callbackName}()`;
        }
        else if (this.callbackName) {
            this.name = this.callbackName + '()';
        }
        else if (this.callbackOwnerName) {
            this.name = this.callbackOwnerName + '.__lambda__()';
        }
        this.promise = new RepeatablePromise_1.RepeatablePromise(callback.bind(thisArg));
    }
}
exports.Delegate = Delegate;

},{"../Async/RepeatablePromise":44}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ArrayUtilities_1 = require("../Collections/ArrayUtilities");
const Delegate_1 = require("./Delegate");
/**
 * I chose to use C# style events, not JS/TS, because the JS/TS way of doing delegates/custom events is a NIGHTMARE. Sure,
 * CustomEvent works, but on the TS side the code required to make TSC happy with valid javascript is awful and non-intuitive.
 * On the JS side, you have the problem that every handler picks it up, not just the ones that are bound to the relevant HTML
 * element, so elements need to pass the source as an argument and check it (like jquery and $(document).on()).
 *
 * After getting it working, all I could think about was how bad the code was, so I rewrote it avoiding the JS pattern entirely.
 *
 * This can be synchronous (callbacks) or asynchronous (promises).  When it is async, the code executes after the current synchronous
 * events run to completion. This could create bugs in synchronous code, but is best for browser events. This handler is primarily used for
 * browser events, so async is default.
 *
 * But if you're triggering async events in code and stepping through it in Chrome, what you see won't make sense, because the async
 * events won't occur until right away. It can be hard to troubleshoot.
 */
// tslint:disable-next-line:ban-types
class EventHandler {
    constructor(_disableAsync = false) {
        this._disableAsync = _disableAsync;
        this.delegate = [];
    }
    subscribe(callback, thisArg) {
        // If this receives a delegate (which is an array of delegates), add it.
        // When this is invoked, that delegate will also be invoked.
        if (Array.isArray(callback)) {
            _ovr1_delegate.call(this, callback);
            return;
        }
        // Got a single callback
        // Only allow a single instance of the same callback.
        if (this.find({ callback, thisArg, firstMatch: true }).length) {
            return;
        }
        const newDele = new Delegate_1.Delegate(callback, thisArg);
        this.delegate.push(newDele);
        // IF this is asynchronous, return the promise so it can be chained.
        // Chaining won't work on sync code, so do not in that case.
        if (!this._disableAsync) {
            return newDele.promise;
        }
        function _ovr1_delegate(delegate) {
            // Only allow a single instance of the same delegate.
            if (this.delegate.find(q => q === delegate)) {
                return;
            }
            this.delegate.push(delegate);
            return;
        }
    }
    unsubscribeCallback(callback) {
        // Only searches non-delegates
        let i = 0;
        while (i < this.delegate.length) {
            const q = this.delegate[i];
            if (!Array.isArray(q) && q.callback === callback) {
                this.delegate.splice(i, 1);
                continue;
            }
            i++;
        }
    }
    unsubscribeListener(sender) {
        // First try to unsubscribe the default delegate. Can't do anything if it has a different name, though.
        if ("delegate" in sender) {
            this.unsubscribeDelegate(sender.delegate);
        }
        // Only searches non-delegates
        let i = 0;
        while (i < this.delegate.length) {
            const q = this.delegate[i];
            if (!Array.isArray(q) && q.thisArg === sender) {
                this.delegate.splice(i, 1);
                continue;
            }
            i++;
        }
    }
    unsubscribeDelegate(delegate) {
        let i = 0;
        while (i < this.delegate.length) {
            const q = this.delegate[i];
            if (q === delegate) {
                this.delegate.splice(i, 1);
                continue;
            }
            i++;
        }
    }
    invoke(args) {
        for (const listener of ArrayUtilities_1.traverse(this.delegate)) {
            if (!this._disableAsync) {
                // Async version. Does not work well with the chrome debugger.
                listener.promise.resolve(args);
            }
            else {
                listener.callback.call(listener.thisArg, args);
            }
        }
    }
    find({ callback, thisArg, firstMatch } = {}) {
        const results = [];
        for (const listener of ArrayUtilities_1.traverse(this.delegate)) {
            if (match(listener)) {
                results.push(listener);
                if (firstMatch) {
                    break;
                }
            }
        }
        return results;
        function match(listener) {
            if (callback && thisArg) {
                return listener.callback === callback && listener.thisArg === thisArg;
            }
            if (callback) {
                return listener.callback === callback;
            }
            if (thisArg) {
                return listener.thisArg === thisArg;
            }
            return true;
        }
    }
    clear() {
        this.delegate.length = 0;
    }
    dispose() {
        this.clear(); // Clears the delegate
        this.delegate = undefined; // Makes sure this can't be used again
    }
}
exports.EventHandler = EventHandler;

},{"../Collections/ArrayUtilities":45,"./Delegate":48}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Event arguments expected on any Change event.
 */
class PropertyChangedEventArgs {
    constructor(args) {
        /**
         * The type of change operation (set, delete) (potentially method)
         */
        this.type = '';
        Object.assign(this, args);
    }
}
exports.PropertyChangedEventArgs = PropertyChangedEventArgs;

},{}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determine if an object is a constructor that is newable.
 * THIS CANNOT DETECT ANONYMOUS CLASSES. Sorry, but JS doesn't have a non-destructive way
 * to check if any function is a constructor other than to try to new() it and blow up/not blow up.
 * This function depends on there being a prototype with a named constructor.
 */
function constructorTypeGuard(obj) {
    return obj && obj.prototype && obj.prototype.constructor.name;
}
exports.constructorTypeGuard = constructorTypeGuard;

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const IsInteger_1 = require("../Utility/IsInteger");
/**
 * This module provides an implementation of keyword arguments, as seen in Python and C#. It makes configurable
 * functions so much quicker and easier than flat arguments (forcing you to put undefined manually in different
 * slots) or options objects (takes more time to produce, especially if you need to new it up).
 *
 * Call functions having keyword arguments using this syntax:
 * callme(arg1, arg2, kw('something', kw1), kw('somethingElse', kw2))
 *
 * To make them work, in the function itself, you need to copy and paste. For example:
 * ({ arg1, arg2, something, somethingElse } = Kwarg.parse({ arg1, arg2, something, somethingElse }));
 */
class Kwarg {
    constructor(a, b) {
        if (!a) {
            throw new Error('Argument null exception');
        }
        this.name = a;
        this.value = b;
    }
    /**
     * Remember this template:
     * ({ } = Kwarg.parseArgs({ }));
     * Include default values in the first object, not the second.
     *
     * If you want to capture rest parameters, use this:
     * ({ $rest$ } = Kwarg.parseArgs({ , ...rest }));
     *
     * If you want allowUnknownKeyword to be true, use this:
     * ({ $$kw$$ } = Kwarg.parseArgs({ }, true));
     */
    static parseArgs(args, allowUnknownKeyword = false) {
        // It would be nice if this could take the arguments object, but sadly arguments stores only an array of values,
        // no keys. If JS were sane, it would be a Map, not an array. Two steps forward, one step back.
        // Parsing the string definition for the function is not my cup of tea, so just no.
        const obj = {};
        const names = Object.getOwnPropertyNames(args);
        // Get data by argument order
        for (const arg of names) {
            if (args[arg] instanceof Kwarg) {
                obj[arg] = undefined;
            }
            else {
                obj[arg] = args[arg];
            }
        }
        const kwvar = {};
        obj['$$kw$$'] = kwvar;
        // Check for rest parameters.
        // I was going to have this on/off configurable, but it shouldn't hurt performance.
        const arr = [];
        obj['$rest$'] = arr;
        // Rest parameters are stored as array keys, { '0': a, '1': b, 'nonRest': 'something else'}
        for (const arg of Object.getOwnPropertyNames(args).filter(f => IsInteger_1.isPositiveIntegerString(f))) {
            if (!(args[arg] instanceof Kwarg)) {
                arr.push(args[arg]);
            }
        }
        const keywordsUsed = {};
        // Get data by keyword name
        // Have to iterate the list twice, to avoid wiping out data if the order is swapped
        for (const arg of names) {
            if (args[arg] instanceof Kwarg) {
                const tmp = args[arg];
                if (tmp.name in obj) {
                    obj[tmp.name] = tmp.value;
                }
                else {
                    if (allowUnknownKeyword) {
                        kwvar[tmp.name] = tmp.value;
                    }
                    else {
                        throw new Error(`Got an unexpected keyword argument '${tmp.name}'`);
                    }
                }
                if (tmp.name in keywordsUsed) {
                    throw new Error(`Got multiple values for keyword argument + '${tmp.name}'`);
                }
                keywordsUsed[tmp.name] = true;
            }
        }
        return obj;
    }
    // Turn an object into an array of keyword arguments.
    // Needs to return any[] because it's going to be shoved into arbitrary argument lists
    static unpack(args) {
        const results = [];
        for (const arg of Object.getOwnPropertyNames(args)) {
            results.push(kw(arg, args[arg]));
        }
        return results;
    }
    isMatch(key) {
        return this.name === key;
    }
}
exports.Kwarg = Kwarg;
function kw(a, b) {
    if (!a) {
        throw new Error('Argument null exception');
    }
    if (typeof a === 'string') {
        // Overload 1
        return new Kwarg(a, b);
    }
    else if (Array.isArray(a)) {
        // Overload 2
        return new Kwarg(a[0], a[1]);
    }
    else {
        // Overload 3
        // This should be an object with only one key/value pair.
        const props = Object.getOwnPropertyNames(a);
        if (!props.length) {
            throw new Error('Argument null exception');
        }
        if (props.length > 1) {
            throw new Error('Invalid map object: multiple keys');
        }
        return new Kwarg(props[0], a[props[0]]);
    }
}
exports.kw = kw;
function kwargsToObject(arr) {
    const options = {};
    for (const arg of arr) {
        options[arg.name] = options[arg.value];
    }
    return options;
}
exports.kwargsToObject = kwargsToObject;

},{"../Utility/IsInteger":59}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isNone(test) {
    return (test == null || test === undefined);
}
exports.isNone = isNone;

},{}],54:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Dead simple assertion that'll work anywhere. This is NOT the difficult part of unit testing.
 */
function assert(test, message) {
    if (!test) {
        throw new Error(message || 'Failed');
    }
}
exports.assert = assert;

},{}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function cloneDeep(obj, hash = new WeakMap()) {
    if (Object(obj) !== obj) {
        return obj; // primitive types
    }
    if (hash.has(obj)) {
        return hash.get(obj); // reference to object previously seen
    }
    let result;
    if (obj instanceof Set) {
        result = new Set();
        Array.from(obj, val => result.add(cloneDeep(val, hash)));
    }
    else if (obj instanceof Map) {
        result = new Map();
        Array.from(obj, ([key, val]) => result.add(cloneDeep(key, hash), cloneDeep(val, hash)));
    }
    else if (Array.isArray(obj)) {
        result = Array.from(obj);
    }
    else if (obj instanceof Date) {
        result = new Date(obj);
    }
    else if (obj instanceof RegExp) {
        result = new RegExp(obj.source, obj.flags);
    }
    else if (typeof obj === 'function') {
        // This is awful code, but it's the only way to clone a standalone function (vs a method which has a descriptor).
        // In general, you probably don't want to use cloneDeep on functions. You'll see it's NOT used on internal methods.
        result = new Function('return ' + obj.toString())();
    }
    else if (Object.getPrototypeOf(obj)) {
        result = Object.create(Object.getPrototypeOf(obj));
    }
    else {
        result = Object.create(null);
    }
    hash.set(obj, result); // Keep track of objects previously cloned
    for (const key of Object.getOwnPropertyNames(obj)) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor && descriptor.writable === false) {
            continue;
        }
        if (typeof obj[key] === 'function' && !(key in result)) {
            // Handle methods that aren't in the prototype.
            // This doesn't recursively follow because there's nothing recursive to do.
            if (descriptor) {
                Object.defineProperty(result, key, descriptor);
                hash.set(obj[key], result[key]);
                // NOTE that cloneDeep is NOT called recursively here. It all ends at the method.
                // If extra keys are thrown onto a function, they probably will not be cloned.
                // In my experience, extra keys on functions didn't work right, so no big loss.
            }
        }
        else if (descriptor && (descriptor.get || descriptor.set)) {
            // Handle custom getters/setters. These are local and hopefully work just like methods.
            // In many cases, this is redundant with Object.create(), but is necessary to allow objects with manually-added custom getters.
            Object.defineProperty(result, key, descriptor);
            // NOTE that cloneDeep is NOT called recursively here. It all ends at the getter/setter.
            // ALSO hash not updated; this is not possible, because it will map the value it gets, not the getter.
        }
        else {
            result[key] = cloneDeep(obj[key], hash);
        }
    }
    return result;
}
exports.cloneDeep = cloneDeep;

},{}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// I don't know for sure if this will work in all cases.
// It gets deeper into the guts of JS object than I have experience with.
function cloneObject(obj) {
    if (!obj || typeof obj !== 'object') {
        return;
    }
    const result = Object.create(Object.getPrototypeOf(obj));
    for (const key of Object.getOwnPropertyNames(obj)) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        if (descriptor) {
            Object.defineProperty(result, key, descriptor);
        }
    }
    return result;
}
exports.cloneObject = cloneObject;

},{}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const NoneType_1 = require("../Types/NoneType");
/**
 * Recent Typescript has added a null coalescing operator (?., aka the Elvis operator) but NPM issues
 * prevent me from upgrading.  But this returns undefined if you access anything that doesn't exist.
 *
 * Naturally this breaks VSCode intellisense, because it returns any. Only MS can do keep the right type.
 *
 * If you do return a partial version of the type, TS throws an error because it could be missing (umm... that's what Partial means...).
 *
 * A true elvis operator would also work on strings/numbers/etc. This cannot do that, because JS can't tell the difference between a
 * null string and a null object. Null is null.
 */
function e_(item) {
    if (NoneType_1.isNone(item)) {
        return {};
    }
    return item;
}
exports.e_ = e_;

},{"../Types/NoneType":53}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ArrayUtilities_1 = require("../Collections/ArrayUtilities");
/**
 * A pseudo-random prefix plus the number of seconds since the unix epoch. The random part should be random enough to cover
 * multiple ids created in a millisecond.
 */
function getUniqueId() {
    const chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_';
    let result = 'u' + String(new Date().getTime()) + '-';
    for (const _ of ArrayUtilities_1.range(8)) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}
exports.getUniqueId = getUniqueId;

},{"../Collections/ArrayUtilities":45}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Tell if a given string is a positive integer.
 * Use for detecting array keys.
 */
function isPositiveIntegerString(str) {
    if (!str || typeof str !== 'string') {
        return false;
    }
    if (str === '0') {
        return true;
    }
    return /^[1-9]\d*$/.test(str);
}
exports.isPositiveIntegerString = isPositiveIntegerString;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * I don't know how accurate this is but it seems pretty good
 */
function isPrimitive(obj) {
    return Object(obj) !== obj;
}
exports.isPrimitive = isPrimitive;

},{}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const CloneObject_1 = require("./CloneObject");
const NoneType_1 = require("../Types/NoneType");
/**
 * Object.assign() can be used for simple copies of properties, but it misses getters,
 * setters, and inherited properties. It only gets the local values.
 *
 * This should hopefully resolve that, but I don't know for sure. This is very sketchy.
 * The results are completely flat, because you can't have multiple inheritance hierarchy
 * in a language without multiple inheritance. Because this flattens objects, it is guaranteed
 * to break anything that makes super calls.
 *
 * If returnClone is true, a clone of the target object will be modified and returned, leaving
 * the original untouched.
 */
function objectFullAssign(target, source, returnClone = false) {
    if (NoneType_1.isNone(target)) {
        target = {};
    }
    if (!source || typeof source !== 'object' || typeof target !== 'object') {
        return target;
    }
    if (returnClone) {
        target = CloneObject_1.cloneObject(target);
    }
    const names = Array.from(new Set(findThePropertyNames(source)));
    for (const key of names) {
        const descriptor = findThePropertyDescriptor(source, key);
        if (descriptor) {
            Object.defineProperty(target, key, descriptor);
        }
    }
    return target;
    function findThePropertyNames(obj) {
        const result = [];
        result.push(...Object.getOwnPropertyNames(obj).filter(f => f !== 'constructor'));
        const proto = Object.getPrototypeOf(obj);
        if (proto && proto.constructor.name !== 'Object') {
            result.push(...findThePropertyNames(proto));
        }
        return result;
    }
    function findThePropertyDescriptor(obj, key) {
        const result = Object.getOwnPropertyDescriptor(obj, key);
        if (result) {
            return result;
        }
        const proto = Object.getPrototypeOf(obj);
        if (proto && proto.constructor.name !== 'Object') {
            return findThePropertyDescriptor(proto, key);
        }
    }
}
exports.objectFullAssign = objectFullAssign;

},{"../Types/NoneType":53,"./CloneObject":56}],62:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestbenchView_1 = require("../tests/TestbenchView");
const Test000_1 = require("./Test000");
const Test001_1 = require("./Test001");
const Test002_1 = require("./Test002");
const Test003_1 = require("./Test003");
const Test004_1 = require("./Test004");
const Test005_1 = require("./Test005");
const Test006_1 = require("./Test006");
const Test007_1 = require("./Test007");
const Test008_1 = require("./Test008");
const Test009_1 = require("./Test009");
const Test010_1 = require("./Test010");
const Test011_1 = require("./Test011");
const Test012_1 = require("./Test012");
const Test013_1 = require("./Test013");
const Test014_1 = require("./Test014");
/**
 * This is a very basic page that I use to see if everything is working. It's what passes for unit tests without
 * an installable unit testing framework.
 */
function main() {
    Api_1.PageRouter.configure([
        { route: 'test/:id=0', payload: Test000_1.Test000 },
        { route: 'test/:id=1', payload: Test001_1.Test001 },
        { route: 'test/:id=2', payload: Test002_1.Test002 },
        { route: 'test/:id=3', payload: Test003_1.Test003 },
        { route: 'test/:id=4', payload: Test004_1.Test004 },
        { route: 'test/:id=5', payload: Test005_1.Test005 },
        { route: 'test/:id=6', payload: Test006_1.Test006 },
        { route: 'test/:id=7', payload: Test007_1.Test007 },
        { route: 'test/:id=8', payload: Test008_1.Test008 },
        { route: 'test/:id=9', payload: Test009_1.Test009 },
        { route: 'test/:id=10', payload: Test010_1.Test010 },
        { route: 'test/:id=11', payload: Test011_1.Test011 },
        { route: 'test/:id=12', payload: Test012_1.Test012 },
        { route: 'test/:id=13', payload: Test013_1.Test013 },
        { route: 'test/:id=14', payload: Test014_1.Test014 },
    ], TestbenchView_1.TestbenchView, true, '<div>There is no page here.</div>', 'test/0');
    // TODO: How can I unit test the router itself? Can't use this test harness, obviously.
}
main();

},{"../src/Api":1,"../tests/TestbenchView":81,"./Test000":63,"./Test001":64,"./Test002":65,"./Test003":66,"./Test004":67,"./Test005":68,"./Test006":69,"./Test007":70,"./Test008":71,"./Test009":72,"./Test010":73,"./Test011":74,"./Test012":75,"./Test013":76,"./Test014":77}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Test the TestCase base classes',
            descriptionHtml: `<p>This test case base class runs tests and outputs stuff to the console, which can be
            included in the actual page (so it's not necessary to open the dev tools console, though
            that's still pretty useful.)</p>
            <p>If you don't see "Test successful," then it failed, with an error in the log. Hard to
            show the log in the page if the page is broken, so have to check the log after all.</p>`
        });
    }
}
class Test000 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            let logElement = document.getElementById('consoleLog');
            if (logElement === null) {
                throw new Error("Rendering failed.");
            }
            this.console.log("Hello world.");
            // Component rendering is asynchronous (on the microtask queue), so the assert has to be later
            setTimeout(() => {
                try {
                    logElement = document.getElementById('consoleLog');
                    if (logElement === null) {
                        throw new Error("Rendering failed.");
                    }
                    Api_1.assert(logElement.innerHTML.includes("Hello world."), "Log should update the page.");
                    this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
                }
                catch (err) {
                    this.log("ERROR: " + err);
                    throw err;
                }
            }, 100);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test000 = Test000;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Assorted HTML helpers',
            descriptionHtml: `<p>Create various elements using createElement and its related functions div(), span(), etc.
                You can easily create any element using createElement() and then add it using the vanilla JS appendChild().</p>

                <p>A few other assorted HTML helpers are here. Some of these are redundant because pieces of the test bench
            depend on them. But what the hey.</p>`
        });
    }
}
class Test001 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // Add elements using the createElement helper
            this.testArea.appendChild(Api_1.createElement("div", { id: 'div1', innerHTML: 'DIV' }));
            test('div1', 'DIV', 'createElement should create div.');
            this.testArea.appendChild(Api_1.createElement("span", { id: 'span1', innerHTML: 'SPAN' }));
            test('span1', 'SPAN', 'createElement should create span.');
            // Add elements using frequently used element creation helpers. DIV and SPAN can take inner html or an element
            const nestedParagraph = Api_1.createElement(Api_1.elementType.HTMLParagraphElement, { id: "divChild", innerHTML: "Nested paragraph" });
            this.testArea.appendChild(Api_1.div(nestedParagraph, { id: 'divParent' }));
            test('divParent', 'DIV', 'div() helper should create a div');
            Api_1.assert(!!nestedParagraph, 'Div should be created and appended with appendChild.');
            Api_1.assert(nestedParagraph.parentElement === this.testArea.querySelector('#divParent'), 'Parent of child should be the target of appendChild');
            this.testArea.appendChild(Api_1.span('Span helper', { id: 'spanHelper' }));
            test('spanHelper', 'SPAN', 'span() helper should create a span');
            // Other helpers just take inner html
            this.testArea.appendChild(Api_1.paragraph('Paragraph helper', { id: 'paragraphHelper' }));
            test('paragraphHelper', 'P', 'paragraph() helper should create a p');
            this.testArea.appendChild(Api_1.anchor('github', 'https://github.com/', { id: 'anchorHelper' }));
            test('anchorHelper', 'A', 'anchor() helper should create an a');
            Api_1.assert(Api_1.e_(this.testArea.querySelector('#anchorHelper')).href === 'https://github.com/', 'Anchor href should take the second argument');
            this.testArea.appendChild(Api_1.button('Click me and nothing will happen', { id: 'buttonHelper', style: 'display: block;' }, { readonly: true }));
            test('buttonHelper', 'BUTTON', 'button() helper should create a button');
            const btn = document.getElementById('buttonHelper');
            if (!btn) {
                throw new Error('Where did the button go?');
            }
            Api_1.assert(btn.style.display === 'block', 'Style property should set style');
            Api_1.assert(btn.getAttribute('readonly') === 'true', 'Attributes input should set attributes');
            // Create HTML by providing a raw HTML string
            const foo = 12345;
            this.testArea.appendChild(Api_1.createHtml(`<p id="rawwr">Element ${foo} created through raw HTML.</p>`));
            test('rawwr', 'P', 'Raw element should create the html element provided');
            // Escape some HTML
            this.viewModel.str = Api_1.escapeHtml('<br>');
            Api_1.assert(this.viewModel.str === '&lt;br&gt;', 'escapeHtml() should escape the HTML');
            // Extract content and put it elsewhere
            const fromEle = Api_1.createHtml('<div><p id="e1">I am some content</p></div>');
            const toEle = Api_1.div({ id: 'e2' });
            this.testArea.appendChild(fromEle);
            this.testArea.appendChild(toEle);
            const extracted = Api_1.extractNodeContent(fromEle);
            toEle.appendChild(extracted);
            const tgt1 = document.getElementById('e2');
            if (!tgt1) {
                throw new Error();
            }
            const tgt2 = tgt1.querySelector('#e1');
            Api_1.assert(!!tgt2, 'extractNodeContent() should remove the html from the source location, and appendChild should add them into the new location.');
            Api_1.assert(Api_1.e_(tgt2).innerHTML === 'I am some content', 'The content moved to the new location should match the original content.');
            // Delete content
            const delEle = Api_1.createHtml('<div><p id="e3">Something that should be deleted</p></div>');
            this.testArea.appendChild(delEle);
            Api_1.deleteNodeContent(delEle);
            Api_1.assert(!document.getElementById('e3'), "deleteNodeContent() should remove the html from the source location.");
            // Create a raw document fragment and add it
            const fragment = Api_1.createFragment(`<p id="rawwr">Fragment created through raw HTML.</p>`);
            this.testArea.appendChild(fragment);
            Api_1.assert(Api_1.e_(this.testArea.querySelector('#rawwr')).tagName === 'P', 'Raw fragment should create the html element provided');
            this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
            function test(id, tag, error) {
                Api_1.assert(Api_1.e_(document.getElementById('testArea').querySelector('#' + id)).tagName === tag, error);
            }
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test001 = Test001;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Miscellaneous Helpers',
            descriptionHtml: `<p>Various misc helper functions, such as range(), zip(), cartesian(),
            isNone(), and getUniqueId. The biggest thing on this page is the best possible implementation
            of keyword arguments, which isn't quite awful. Keyword arguments are a good compromise between
            quick entry and configurability, while JS's two options are only one or the other.</p>`
        });
    }
}
class Test002 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            Api_1.assert(Api_1.isNone(null), "isNone() should return true for null.");
            Api_1.assert(Api_1.isNone(undefined), "isNone() should return for undefined.");
            Api_1.assert(!Api_1.isNone("abc"), "isNone() should return false for truthy values.");
            Api_1.assert(!Api_1.isNone(""), "isNone() should return false for an empty string (a falsy value).");
            // TODO: The elvis helper is no longer needed in TS (you can use ?.). Except I can't get typescript updated.
            Api_1.assert(Api_1.e_(null).something === undefined, "null reference should not throw");
            Api_1.assert(Api_1.e_(undefined).something === undefined, "undefined reference should not throw");
            const z = Api_1.zip(['a', 'b', 'c'], ['d', 'e']);
            this.log(z);
            Api_1.assert(z[0][0] === 'a', 'zip() should combine element 0 from both arrays');
            Api_1.assert(z[0][1] === 'd', 'zip() should combine element 0 from both arrays');
            Api_1.assert(z[2][0] === 'c', 'zip() should combine element 1 from both arrays');
            Api_1.assert(z[2][1] === undefined, "If an array isn't long enough, undefined should be used.");
            const c = Api_1.cartesian(['a', 'b', 'c'], ['d', 'e']);
            this.log(c);
            Api_1.assert(c[0][0] === 'a', 'cartesian() should combine element 0 from both arrays');
            Api_1.assert(c[0][1] === 'd', 'cartesian() should combine element 0 from both arrays');
            Api_1.assert(c[1][0] === 'a', 'cartesian() should combine element 0 from array 1 and element 1 from array 2');
            Api_1.assert(c[1][1] === 'e', 'cartesian() should combine element 0 from array 1 and element 1 from array 2');
            Api_1.assert(c[2][0] === 'b', 'cartesian() should combine element 1 from array 1 and element 0 from array 2');
            Api_1.assert(c[2][1] === 'd', 'cartesian() should combine element 1 from array 1 and element 0 from array 2');
            Api_1.assert(c[3][0] === 'b', 'cartesian() should combine element 1 from both arrays');
            Api_1.assert(c[3][1] === 'e', 'cartesian() should combine element 1 from both arrays');
            const r = Api_1.range(10);
            this.log(r);
            Api_1.assert(r.length === 10, 'range() should create a range with the length given');
            Api_1.assert(r[0] === 0, 'range() should start at 0');
            Api_1.assert(r[9] === 9, 'range() should end at length - 1');
            const t = Array.from([...Api_1.traverse([0, 1, 2, [3, 4], [5, [6, 7, [8]]], 9])]);
            this.log(t);
            Api_1.assert(t[0] === 0, 'traverse() should start at the first item in the nested array');
            Api_1.assert(t[9] === 9, 'traverse() should end at the last item in the nested array (not the deepest)');
            // This is not an exhaustive test, but that would be impossible.
            const id1 = Api_1.getUniqueId();
            const id2 = Api_1.getUniqueId();
            Api_1.assert(id1 !== id2, "getUniqueId() should not produce the same id twice");
            const sortMe = ['a', 'Z', 'B', 'x', 'c', 'Y'];
            sortMe.sort(Api_1.orderBy(a => a.toUpperCase()));
            this.log(sortMe);
            Api_1.assert(JSON.stringify(sortMe) === '["a","B","c","x","Y","Z"]', "orderBy can be used to sort an array");
            // Assertion helper for the next test
            let assertYourself = "";
            const log = (arg) => {
                // tslint:disable-next-line:no-console
                console.log(arg);
                this.testArea.appendChild(Api_1.span(arg));
                this.testArea.appendChild(Api_1.createElement('br'));
                assertYourself += arg;
            };
            // And now, the main event....
            // Keyword arguments in JS.
            // It isn't as clean in TS but can be made to work.
            // Functions can be called using keyword arguments using the kw() function. For instance, consider the following function:
            function parrot(voltage, state = 'a stiff', action = 'voom', type = 'Norwegian Blue') {
                // Three redundant items here.
                // This redundantly has to list the parameters (in JS, a simple copy/paste from above) at the start.
                // It then has to list the parameters again, on the right.
                // On the left, the default values need to be repeated.
                // This sucks but it's the cleanest I can get in JS. If the reflection were a little better, I could do more.
                ({ voltage, state = 'a stiff', action = 'voom', type = 'Norwegian Blue' } = Api_1.Kwarg.parseArgs({ voltage, state, action, type }));
                assertYourself = ""; // Clear the test assertion.
                log("-- This parrot wouldn't " + action + " ");
                log("if you put " + voltage + " volts through it.");
                log("-- Lovely plumage, the " + type);
                log("-- It's " + state + "!");
                log('---------------------------------------');
            }
            // Parrot() could be called in any of the following ways:
            // (The function kw() takes an one-key object, a 2 element array, or a string and a value.)
            parrot(1000);
            Api_1.assert(assertYourself.includes('put 1000 volts'), "Normal JS positional arguments work as usual");
            parrot(Api_1.kw({ action: 'VOOOOOM' }), Api_1.kw('voltage', 1000000));
            Api_1.assert(assertYourself.includes("wouldn't VOOOOOM") && assertYourself.includes("put 1000000 volts"), "Keyword arguments can be used and can be specified as one-key objects or as two arguments");
            parrot('a thousand', Api_1.kw(['state', 'pushing up the daisies']));
            Api_1.assert(assertYourself.includes("It's pushing up the daisies!") && assertYourself.includes("put a thousand volts"), "Keyword arguments can be combined with positional arguments and tuple keyword arguments can be used");
            parrot('a million', 'bereft of life', 'jump');
            Api_1.assert(assertYourself.includes("It's bereft of life!") && assertYourself.includes("put a million volts") && assertYourself.includes("parrot wouldn't jump"), "Multiple positional arguments can be filled");
            // The following 3 cases would be invalid:
            // parrot();                                                // required argument missing caught in Typescript
            //                                                          JS is fine with an undefined argument so don't ask it for help.
            // parrot(kw({ voltage: 110 }), kw({ voltage: 220 }));      // duplicate keyword
            // parrot(kw({ actor: 'John Cleese' }));                    // unknown keyword (control with allowUnknownKeyword)
            // The following are valid but you really shouldn't do them, as they are bad practice.
            // It's not possible to catch them as errors, though. It's based on info unknown to JavaScript (specifically, argument details).
            parrot(Api_1.kw({ voltage: 5.0 }), 'dead'); // non-keyword argument following keyword
            // This works as written, but it's ugly. Code has no idea about order of arguments so cannot trap it.
            parrot(Api_1.kw({ type: 'Finnish Pink' }), 'dead'); // non-keyword argument following keyword
            // This passes undefined for voltage, because that slot has a keyword in it.
            // Code has no idea about order of arguments so cannot trap it.
            parrot(110, Api_1.kw({ voltage: 220 })); // duplicate value for argument
            // The later keyword overrides the non-keyword argument.
            // If the function has defaults in the header, throwing would cause unexpected exceptions on valid code.
            // Code cannot tell if an argument's value is a default set by JS (fine) or a user value (bad), so can't trap the bad case.
            // When Kwargs.parseArgs() is called, a property named $$kw$$ receives an object containing all keyword arguments except for
            // those corresponding to a formal parameter. But if allowUnknownKeyword is false, an error is thrown instead.
            // When Kwargs.parseArgs() is called with rest parameters included in the argument list, a property named $rest$ contains the
            // non-keyword rest arguments. Note that there is no way to indicate in the function signature that keyword
            // arguments are allowed to be included in the rest paramete, so they arer.
            // In JS, rest parameters must appear last.
            function cheeseshop(kind, ...rest) {
                let $rest$;
                let $$kw$$;
                ({ kind, $rest$, $$kw$$ } = Api_1.Kwarg.parseArgs(Object.assign({ kind }, rest), true));
                log('-- Do you have any ' + kind + '?');
                log("-- I'm sorry, we're all out of " + kind);
                for (const arg of $rest$) {
                    log(arg);
                }
                log('------');
                for (const kwvar of Object.getOwnPropertyNames($$kw$$)) {
                    log(kwvar + ' : ' + $$kw$$[kwvar]);
                }
                log('---------------------------------------');
            }
            // It could be called like this:
            cheeseshop("Limburger", "It's very runny, sir.", "It's really very, VERY runny, sir.", Api_1.kw({ shopkeeper: "Michael Palin" }), Api_1.kw({ client: "John Cleese" }), Api_1.kw({ sketch: "Cheese Shop Sketch" }));
            Api_1.assert(assertYourself.includes("Do you have any Limburger?") && assertYourself.includes("It's very runny, sir.") && assertYourself.includes("It's really very, VERY runny, sir.") && assertYourself.includes("sketch : Cheese Shop Sketch"), "Rest arguments ($rest$, acts like *args) and rest keyword arguments ($$kw$$, acts like **kw) can be used");
            // Arbitrary argument lists are supported in JavaScript by ...rest parameters, so do not need special handling.
            // Note that rest parameters MUST be the final argument, so while it is have keyword arguments, it isn't possible
            // to indicate in the function definition that arbitrary keyword arguments are allowed.
            // These lists can be unpacked by the ...spread operator, so again, does not need special handling.
            // In the same fashion, objects can deliver keyword arguments with the ...spread operator and the Kwarg.unpack() function:
            const dict = { action: "VOOM", voltage: "four million", state: "bleedin' demised" };
            // This kind of TypeScript coercion is needed when there is one or more required parameters. It is NOT pretty.
            // On stack overflow, there are several ways given to indicate min-length arrays. NONE are valid TS.
            // In pure JS, these two lines are just parrot(...Kwarg.unpack(dict));
            const unpacked = Api_1.Kwarg.unpack(dict);
            parrot(unpacked[0], ...unpacked.slice(1));
            Api_1.assert(assertYourself.includes("This parrot wouldn't VOOM") && assertYourself.includes("put four million volts") && assertYourself.includes("It's bleedin' demised!"), "Objects can be unpacked into separate keyword arguments using Kwarg.unpack");
            this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test002 = Test002;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],66:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Deferred Promises',
            descriptionHtml: `
            <h2>Intro</h2>
            <p>The deferred promise is like a regular javascript promise, except that the deferred promise can be triggered manually at any point after it's creation. Regular promises start immediately and just hold their response.</p>
            <p>The deferred promise is implemented as a wrapper around a regular promise, so it uses the same microtask queue.</p>
            <p>The API is similar to the Promise() API, but is tweaked a little bit for usability. For example, having onfulfilled() and onrejected() in then() means that errors in onfulfilled() are not caught. Experienced JS programmers recommend not using onrejected(). I left it out ... why invite disaster when catch() exists?</p>

            <h2>Usage</h2>
            <p>Create a new deferred with "new DeferredPromise()." The API is as follows:</p> 

            <pre>
            class DeferredPromise {
                constructor(
                    onfulfilled?: (value: any) => PromiseLike,
                    throwOnUnhandledError: boolean
                );

                then(
                        onfulfilled?: (value: any) => PromiseLike,
                        throwOnUnhandledError: boolean
                    ): this;
                catch(
                        onrejected?: (reason: any) => PromiseLike,
                        throwOnUnhandledError: boolean
                ): this;

                resolve(args?: any): void;
                reject(args?: any): void;

                get output(): Promise;
            }
            </pre>

            <p>The use of then() and catch() should look very familiar to you if you've used promises before. If it doesn't, google it.</p>

            <p>To invoke the promise, call resolve() on the deferred promise with whatever args you want to pass it.</p>
            <p>Promise.resolve('Something').then(s => someFunction(s))<br />
            is almost the same as <br />
            new DeferredPromise().then(s => someFunction(s)),<br />
            except that the latter is not executed until you call promise.resolve(). Actually, I lie. In that example, resolve() is called somewhere in both cases. It's a garbage example. The point is, in a deferred someFunction() is executed later.</p>

            <h3>Construction</h3>

            <p>Unlike with an unwrapped Promise, you can actually create a DeferredPromise by using new DeferredPromise(). This resolves one of the inconsistencies in the Promise API. One of the things I like about where JS is going is that classes are generally newable.</p>

            <p>The deferred promise takes an optional callback as an input, so that new DeferredPromise(() => console.log('Got it')) is the same as "new DeferredPromise().then(() => console.log('Got it'))."</p>

            <p>Promises, except when used in an async/await context, have an issue with unhandled exceptions. In normal code, an unhandled exception throws in the browser console. In promises, an unhandled exception is silently swallowed. The only way of handling this is to include a catch() step, which will force errors to drop to the catch, and all is good ... unless an error is thrown in the catch. Oops. Having the opposite error handling behavior is a flaw in the promise API, so by default, throwOnUnhandledError adds an extra catch onto every step to throw an error in the browser console.</p>

            <small>I would have preferred to add this only at the end of the chain, but the DeferredPromise doesn't know where the end of the chain is, only the beginning.</small>

            <small>This is messy but it means you don't need to worry that exceptions will be swallowed. It breaks the then().then().catch() pattern so it's not enabled by default.</small>

            <p>It is possible to set throwOnUnhandledError on a step-by-step basis, but it's probably not extremely useful.</p>

            <h3>Async/await</h3>
            <p>Async/await in JS is syntactic sugar around promises, so to make this work, you need access to the actual inner promise that is being wrapped in the DeferredPromise(). This is made accessible through the "output" accessor. You can use it like this:</p>

            <pre>
                this.deferred = new DeferredPromise().then(() => fetchSomething());
                const result = await this.deferred.output;
                setSomethingEqualTo(result);
            </pre>

            <p>Then when something else, such as a mouse-click or the result of some other async operation triggers this.deferred.resolve(), the code picks up again at the await.</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test003 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            new Api_1.DeferredPromise(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 1", { id: 'waitTest1' }))).resolve();
            new Api_1.DeferredPromise().then(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 2", { id: 'waitTest2' }))).resolve();
            const waitDefer = new Api_1.DeferredPromise().then(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 3", { id: 'waitTest3' })));
            setTimeout(() => waitDefer.resolve(), 500);
            // Testing errors is hard in a pattern where you don't want to see exceptions
            const none = null;
            new Api_1.DeferredPromise(() => {
                none.nullReferenceException();
            })
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest1' })))
                .catch(() => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR", { id: 'catchTest1' })))
                .resolve();
            new Api_1.DeferredPromise(() => {
                none.nullReferenceException();
            }, true)
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest2' })))
                .catch(s => this.testArea.appendChild(Api_1.paragraph('Automatic message: ' + s.message, { id: 'catchTest2' })))
                .resolve();
            new Api_1.DeferredPromise(() => {
                none.nullReferenceException();
            })
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest3' })), true)
                .catch(s => this.testArea.appendChild(Api_1.paragraph('Automatic message: ' + s.message, { id: 'catchTest3' })))
                .resolve();
            new Api_1.DeferredPromise(() => {
                none.nullReferenceException();
            }, true)
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest4' })))
                .catch(() => none.nullReferenceException()) // error thrown in catch
                .catch(() => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR IN CATCH", { id: 'catchTest4' })))
                .resolve();
            new Api_1.DeferredPromise(() => {
                none.nullReferenceException();
            })
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest5' })))
                .catch(() => none.nullReferenceException(), true) // error thrown in catch
                .catch(() => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR IN CATCH", { id: 'catchTest5' })))
                .resolve();
            new Api_1.DeferredPromise(() => this.log("This should never be called"))
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'rejectTest1' })))
                .catch(s => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR: " + s, { id: 'rejectTest1' })))
                .reject('REJECTED MANUALLY');
            // This isn't a perfect test because this project is currently generating ES2015, and TSC turns async/await into a generator.
            const waitAsync = new Api_1.DeferredPromise(() => "AWAITED");
            // Async/await test
            function test() {
                return __awaiter(this, void 0, void 0, function* () {
                    const awaited = yield waitAsync.output;
                    document.getElementById('testArea').appendChild(Api_1.paragraph("ASYNC/AWAIT: " + awaited, { id: 'awaitTest1' }));
                });
            }
            setTimeout(() => test(), 0);
            setTimeout(() => waitAsync.resolve(), 10);
            this.log('Async test initiated (2 test sets).');
            // Testing async stuff, ick
            setTimeout(() => {
                try {
                    // 100ms after creation, waitDefer should not have been invoked.
                    const wait1 = document.getElementById('waitTest3');
                    Api_1.assert(!wait1, "Waitable should wait before resolution.");
                    this.log(`TEST ${this.viewModel.testNumber}: Test set 1 successful.`);
                }
                catch (err) {
                    this.log("ERROR: " + err);
                    throw err;
                }
            }, 10);
            setTimeout(() => {
                try {
                    const wait1 = document.getElementById('waitTest1');
                    Api_1.assert(!!wait1, "Waitable constructor should activate when resolve() called.");
                    const wait2 = document.getElementById('waitTest2');
                    Api_1.assert(!!wait2, "Waitable then() should activate when resolve called().");
                    const wait3 = document.getElementById('waitTest3');
                    Api_1.assert(!!wait3, "Deferred should not need to be resolved immediately.");
                    const error1 = document.getElementById('catchTest1');
                    Api_1.assert(Api_1.e_(error1).innerHTML === "CAUGHT ERROR", "Catch() should be executed on an error");
                    const error2 = document.getElementById('catchTest2');
                    Api_1.assert(Api_1.e_(error2).innerHTML.includes('nullReferenceException'), "Automatic throwOnUnhandledError should be thrown with the default error message text");
                    const error3 = document.getElementById('catchTest3');
                    Api_1.assert(Api_1.e_(error3).innerHTML.includes('nullReferenceException'), "Instance-level automatic throwOnUnhandledError should be executed on error");
                    const error4 = document.getElementById('catchTest4');
                    Api_1.assert(Api_1.e_(error4).innerHTML === "CAUGHT ERROR IN CATCH", "throwOnUnhandledError should catch errors thrown in a catch() statement");
                    const error5 = document.getElementById('catchTest5');
                    Api_1.assert(Api_1.e_(error5).innerHTML === "CAUGHT ERROR IN CATCH", "Error in catch() should be caught with instance-level throwOnUnhandledError");
                    const error6 = document.getElementById('rejectTest1');
                    Api_1.assert(Api_1.e_(error6).innerHTML === "CAUGHT ERROR: REJECTED MANUALLY", "Reject() should force execution of catch() block");
                    const asyncawait = document.getElementById('awaitTest1');
                    Api_1.assert(Api_1.e_(asyncawait).innerHTML === "ASYNC/AWAIT: AWAITED", "Async/await() should act as expected (note: implementation varies by TypeScript ES version)");
                    this.log(`TEST ${this.viewModel.testNumber}: Test set 2 successful.`);
                }
                catch (err) {
                    this.log("ERROR: " + err);
                    throw err;
                }
            }, 1000);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test003 = Test003;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],67:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Repeatable Promises',
            descriptionHtml: `
            <h2>Intro</h2>
            <p>The promise is almost like an event emitter, and with the introduction of the DeferredPromise class,
            which allows invocation at a later point in time, this is more true. But there is one thing that makes
            promises inadequate as event emitters: promises can only be resolved once. The resolve once behavior is
            fundamental to the entire concept of the promise.</p>

            <p>But they're so nice, otherwise. The promise API is so useful for chaining asynchronous event handlers,
            and it makes the async/await syntax possible, and as much as I like the promise API, the async/await API
            is far better. You can't have it without promises, though.</p>

            <p>And so the RepeatablePromise was born. The repeatable promise is a fiction that pretends to be a promise
            by showing a similar API. In fact, it is a factory class. Wwhat it does is build a new promise every time you
            call it, which involves a performance hit but is better than nothing it all. Sure, nothing at all is really darn
            fast, but it has a tendency to be useless.</p>

            <h2>Usage</h2>
            <p>Create a new repeatable with "new RepeatablePromise()." The API is as follows:</p>

            <pre>
            class RepeatablePromise {
                constructor(
                    onfulfilled?: (value: any) => PromiseLike,
                    onUnhandledError?: (value: any) => PromiseLike,
                    throwOnUnhandledError: boolean
                );

                then(
                        onfulfilled?: (value: any) => PromiseLike
                    ): this;
                catch(
                        onrejected?: (reason: any) => PromiseLike
                ): this;

                resolve(args?: any): Promise;
                reject(args?: any): Promise;

                build(): DeferredPromise;
            }
            </pre>

            <p>The use of then() and catch() should look very familiar to you if you've used promises before. If it doesn't, google it.</p>

            <p>To invoke the promise, call resolve() on the repeatable promise with whatever args you want to pass it. You can do this as many times as you need to.</p>

            <p>The build() method gives a hint about how the RepeatablePromise class works, as it is a DeferredPromise factory. The build() method is public so that if you want to use it as a promise builder, you can go right on and do it.</p>

            <h3>Construction</h3>

            <p>The repeatable promise takes an optional callback as an input, so that new RepeatablePromise(() => console.log('Got it')) is the same as "new RepeatablePromise().then(() => console.log('Got it'))."</p>

            <p>Promises, except when used in an async/await context, have an issue with unhandled exceptions. In normal code, an unhandled exception throws in the browser console. In promises, an unhandled exception is silently swallowed. The only way of handling this is to include a catch() step, which will force errors to drop to the catch, and all is good ... unless an error is thrown in the catch. Oops. Having the opposite error handling behavior is a flaw in the promise API, so by default, throwOnUnhandledError adds an extra catch onto the very end that throws if the error is unhandled.</p>

            <p>If you want to declare, during construction, a catch block to be called on any unhandled error, you can spedify the onUnhandledError input. This is sugar for promise.then().then().catch(myCallback) (this would have been done in the DeferredPromise if it were possible).</p>

            <h3>Async/await</h3>
            <p>Async/await in javascript is syntactic sugar around promises, so to make this work, you need access to the actual inner promise that is being wrapped in the RepeatablePromise.  This is returned from the resolve method. You can use it like this:</p>

            <pre>
                this.repeatable = new RepeatablePromise().then(() => fetchSomething());
                this.someMethod = function() {
                    const result = await this.repeatable.resolve();
                    setSomethingEqualTo(result);
                }
            </pre>

            <p>Then when something else, such as a mouse-click or the result of some other async operation calls someMethod(), the promise is resolved and acted upon.</p>

            <p>Again, tests are async and will keep running. Wait for tests to complete before leaving page. From this point on, most of
            the test cases are async.</p>
            `
        });
    }
}
class Test004 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // The tests for deferred must also work for repeable.
            new Api_1.RepeatablePromise(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 1", { id: 'waitTest1' }))).resolve();
            new Api_1.RepeatablePromise().then(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 2", { id: 'waitTest2' }))).resolve();
            const waitDefer = new Api_1.RepeatablePromise().then(() => this.testArea.appendChild(Api_1.paragraph("Waitable test 3", { id: 'waitTest3' })));
            setTimeout(() => waitDefer.resolve(), 500);
            // Testing errors is hard in a pattern where you don't want to see exceptions
            const none = null;
            new Api_1.RepeatablePromise(() => {
                none.nullReferenceException();
            })
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest1' })))
                .catch(() => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR", { id: 'catchTest1' })))
                .resolve();
            new Api_1.RepeatablePromise(() => {
                none.nullReferenceException();
            }, null, true)
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest2' })))
                .catch(s => this.testArea.appendChild(Api_1.paragraph('Automatic message: ' + s.message, { id: 'catchTest2' })))
                .resolve();
            new Api_1.RepeatablePromise(() => {
                none.nullReferenceException();
            }, null, true)
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest4' })))
                .catch(() => none.nullReferenceException()) // error thrown in catch
                .catch(() => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR IN CATCH", { id: 'catchTest4' })))
                .resolve();
            new Api_1.RepeatablePromise(() => this.log("This should never be called"))
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'rejectTest1' })))
                .catch(s => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR: " + s, { id: 'rejectTest1' })))
                .reject('REJECTED MANUALLY');
            // This isn't a perfect test because this project is currently generating ES2015, and TSC turns async/await into a generator.
            const waitAsync = new Api_1.RepeatablePromise(() => "AWAITED");
            // Async/await test
            function test() {
                return __awaiter(this, void 0, void 0, function* () {
                    const awaited = yield waitAsync.resolve();
                    document.getElementById('testArea').appendChild(Api_1.paragraph("ASYNC/AWAIT: " + awaited, { id: 'awaitTest1' }));
                });
            }
            setTimeout(() => test(), 0);
            // Tests for repeatable functionality
            let i = 1;
            const repeater1 = new Api_1.RepeatablePromise(() => {
                this.testArea.appendChild(Api_1.paragraph("Repeated: " + i, { id: "repeatTest" + i }));
                i++;
            });
            repeater1.resolve();
            repeater1.resolve();
            new Api_1.RepeatablePromise(() => {
                none.nullReferenceException();
            }, () => this.testArea.appendChild(Api_1.paragraph("CAUGHT ERROR", { id: 'catchTest7' })))
                .then(() => this.testArea.appendChild(Api_1.paragraph("FORCED ERROR FAILED", { id: 'catchTest7' })))
                .resolve();
            const repeater3 = new Api_1.RepeatablePromise().then(() => this.testArea.appendChild(Api_1.paragraph("Build test", { id: 'repeatTest3' })));
            const wait4 = repeater3.build();
            wait4.resolve();
            this.log('Async test initiated (2 test sets).');
            // Testing async stuff is super annoying
            setTimeout(() => {
                try {
                    // 100ms after creation, waitDefer should not have been invoked.
                    const wait1 = document.getElementById('waitTest3');
                    Api_1.assert(!wait1, "Waitable should wait before resolution.");
                    this.log(`TEST ${this.viewModel.testNumber}: Test set 1 successful.`);
                }
                catch (err) {
                    this.log("ERROR: " + err);
                    throw err;
                }
            }, 10);
            setTimeout(() => {
                try {
                    const wait1 = document.getElementById('waitTest1');
                    Api_1.assert(!!wait1, "Waitable constructor should activate when resolve() called.");
                    const wait2 = document.getElementById('waitTest2');
                    Api_1.assert(!!wait2, "Waitable then() should activate when resolve called().");
                    const wait3 = document.getElementById('waitTest3');
                    Api_1.assert(!!wait3, "Deferred should not need to be resolved immediately.");
                    const error1 = document.getElementById('catchTest1');
                    Api_1.assert(Api_1.e_(error1).innerHTML === "CAUGHT ERROR", "Catch() should be executed on an error");
                    const error2 = document.getElementById('catchTest2');
                    Api_1.assert(Api_1.e_(error2).innerHTML.includes('nullReferenceException'), "Automatic throwOnUnhandledError should be thrown with the default error message text");
                    const error4 = document.getElementById('catchTest4');
                    Api_1.assert(Api_1.e_(error4).innerHTML === "CAUGHT ERROR IN CATCH", "throwOnUnhandledError should catch errors thrown in a catch() statement");
                    const error6 = document.getElementById('rejectTest1');
                    Api_1.assert(Api_1.e_(error6).innerHTML === "CAUGHT ERROR: REJECTED MANUALLY", "Reject() should force execution of catch() block");
                    const asyncawait = document.getElementById('awaitTest1');
                    Api_1.assert(Api_1.e_(asyncawait).innerHTML === "ASYNC/AWAIT: AWAITED", "Async/await() should act as expected (note: implementation varies by TypeScript ES version)");
                    const repeat1 = document.getElementById('repeatTest1');
                    Api_1.assert(!!repeat1, 'Repeated should execute when resolved');
                    const repeat2 = document.getElementById('repeatTest2');
                    Api_1.assert(!!repeat2, 'Repeated should execute again when resolved again');
                    const repeat3 = document.getElementById('repeatTest3');
                    Api_1.assert(!!repeat3, 'Repeated build() should return a deferred, which should be executable');
                    const error7 = document.getElementById('catchTest7');
                    Api_1.assert(Api_1.e_(error7).innerHTML === "CAUGHT ERROR", "Catch() 7 should be caught by the general exception handler.");
                    this.log(`TEST ${this.viewModel.testNumber}: Test set 2 successful.`);
                }
                catch (err) {
                    this.log("ERROR: " + err);
                    throw err;
                }
            }, 1000);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test004 = Test004;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Event Handler',
            descriptionHtml: `
            <h2>Intro</h2>
            <p>An event handler is an object containing a subscribe() method and an invoke() method.
            When the invoke() method is called, any delegates that are subscribed are executed. At it's heart, that's
            all it is. The basic design comes from C# event handlers, as does the name (personally, I would prefer "event
            emitter", because to me the subscribing delegate listeners are "handling" the event, but who am I to argue
            with Microsoft).</p>

            <h2>Usage</h2>
            <p>The API is as follows:</p>

            <pre>
            type DelegateType = { callback: IAction1<any>, thisArg: any, promise: RepeatablePromise };
            type RepeatablePromise = RecursiveArray<DelegateType>;

            class EventHandler<TArgs> {
                delegate: RecursiveDelegate;

                subscribe(delegate: RecursiveDelegate): void;
                subscribe(callback: IAction1<TArgs>): void;

                invoke(args?: TArgs): void;

                unsubscribeCallback(callback: IAction1<TArgs>): void;
                unsubscribeDelegate(delegate: RecursiveDelegate): void;
                unsubscribeListener(listener: any): void;
                clear(): void;

                dispose(): void;
            }
            </pre>

            <p>You can subscribe one or more callbacks, either individually or all at the same time. You can also subscribe other delegates, which themselves can be made of multiple callbacks. This is useful to have one delegate invocation trigger multiple event handlers.  You can keep going ad-infinitum. You can subscribe a delegate to itself, if you want to crash the browser.</p>

            <p>The RecursiveDelegate is an array of DelegateType, or an array of arrays of DelegateType, or an array of array of arrays of DelegateType, etc.</p>

            <p>You shoulds include thisArg for the listener that should execute the callback. This is not absolutely required for extremely simple callbacks, but the majority of callbacks do require the thisArg to function, and it's really easy to leave out, making for confusing errors. If this were C#, I might have marked that override as obsolete so you'd get a warning.</p>

            <p>By default, the EventHandler is asynchronous, using promises to execute the delegate. To create a synchronous event handler, send false into the constructor, new EventHandler(false).</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test005 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            const handler1 = new Api_1.EventHandler();
            handler1.subscribe(args => this.testArea.appendChild(Api_1.createElement('p', args)), this);
            handler1.invoke({ id: 'handler1', innerHTML: 'TEST 1' });
            handler1.invoke({ id: 'handler2', innerHTML: 'TEST 2' });
            const handler2 = new Api_1.EventHandler(true);
            handler2.subscribe(args => {
                args.id = args.id + 's';
                args.innerHTML = args.innerHTML + ': SYNC';
                this.testArea.appendChild(Api_1.createElement('p', args));
            }, this);
            handler2.invoke({ id: 'handler3', innerHTML: 'TEST 3' });
            // You can subscribe delegates to other delegates, the same as callbacks.
            handler1.subscribe(handler2.delegate);
            handler1.invoke({ id: 'handler4', innerHTML: 'TEST 4' });
            handler1.unsubscribeDelegate(handler2.delegate);
            handler1.invoke({ id: 'handler5', innerHTML: 'TEST 5' });
            const listener1 = {
                callback: function (args) {
                    args.id = args.id + 'c';
                    args.innerHTML = args.innerHTML + ': CALLBACK';
                    document.getElementById('testArea').appendChild(Api_1.createElement('p', args));
                }
            };
            handler1.clear();
            handler1.subscribe(listener1.callback, listener1);
            handler1.invoke({ id: 'handler6', innerHTML: 'TEST 6' });
            handler1.unsubscribeListener(listener1);
            handler1.invoke({ id: 'handler7', innerHTML: 'TEST 7' });
            handler1.subscribe(listener1.callback, listener1);
            handler1.unsubscribeCallback(listener1.callback);
            handler1.invoke({ id: 'handler8', innerHTML: 'TEST 8' });
            // Handler 2 should call handler 1 which calls the callback on handler 1.
            handler1.subscribe(listener1.callback, listener1);
            handler2.subscribe(handler1.delegate);
            handler2.invoke({ id: 'handler9', innerHTML: 'TEST 9' });
            // The delegate is a real reference, not a copy, so if you unsub the callback, it should also unsub from handler2.
            handler1.unsubscribeCallback(listener1.callback);
            handler2.invoke({ id: 'handler10', innerHTML: 'TEST 10' });
            this.log('Async test initiated (1 test set).');
            // Testing async stuff is super annoying
            setTimeout(() => {
                try {
                    const test1 = document.getElementById('handler1');
                    Api_1.assert(!!test1, 'invoke() should execute the callback with the arguments provided.');
                    const test2 = document.getElementById('handler2');
                    Api_1.assert(!!test2, 'invoke() should be repeatable.');
                    const test3 = document.getElementById('handler3s');
                    Api_1.assert(!!test3, 'Synchronous invoke() should execute the listener.');
                    const test4a = document.getElementById('handler4');
                    Api_1.assert(!!test4a, 'invoke() when chained should still function.');
                    const test4b = document.getElementById('handler4s');
                    Api_1.assert(!!test4b, 'invoke() when chained should execute the secondary observable');
                    const test5 = document.getElementById('handler5s');
                    Api_1.assert(!test5, 'Unsubscribed delegates should not be triggered by invoke.');
                    const test6 = document.getElementById('handler6c');
                    Api_1.assert(!!test6, 'Dumb callbacks should be chainable just like observables.');
                    const test6b = document.getElementById('handler6');
                    Api_1.assert(!test6b, 'Clear() should unsubscribe all listeners.');
                    const test7 = document.getElementById('handler7c');
                    Api_1.assert(!test7, 'Should be able to unsubscribe callbacks by listener.');
                    const test8 = document.getElementById('handler8c');
                    Api_1.assert(!test8, 'Should be able to unsubscribe specific callbacks.');
                    const test9 = document.getElementById('handler9sc');
                    Api_1.assert(!!test9, 'When unsubscribing a callback from a secondary listener, it should also be unsubscribed from the primary.');
                    const test10 = document.getElementById('handler10sc');
                    Api_1.assert(!test10, 'When unsubscribing a delegate from a secondary listener, it should also be unsubscribed from the primary.');
                    this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
                }
                catch (err) {
                    this.log('ERROR: ' + err);
                    throw err;
                }
            }, 1000);
        }
        catch (err) {
            this.log('ERROR: ' + err);
            throw err;
        }
    }
}
exports.Test005 = Test005;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Observable Property',
            descriptionHtml: `
            <h2>Usage</h2>
            <p>An observable property is a field that, when you set its value, raises an event on its event handler.</p>
            <p>And really, it's no more complicated than that. You would use it like the following:</p>
            <pre><code>
                var prop = new ObservableProperty<int>(41);
                prop.subscribe(someComponent.render, someComponent);
                prop.value += 1;
            </code></pre>
            <p>Now someComponent refreshes to show the answer to the ultimate question of life, the universe, and everything. You should try to use safeValue, which is a non-null, HTML-escaped string, for any displayed properties. By default, injection
            should not occur. If it is necessary to inject the value directly into the HTML, use value.</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test006 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            const observable1 = new Api_1.ObservableProperty(1, { name: "A Number" });
            Api_1.assert(observable1.value === 1, "Observable value should return initial value");
            observable1.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}. Old:${args.oldValue}`, { id: "test" + args.oldValue })), observable1);
            observable1.value = 2;
            observable1.value = 3;
            // See later for assert
            Api_1.assert(observable1.toString() === "3", "toString should return the string representation of the internal value");
            const observable2 = new Api_1.ObservableProperty("Dog", { name: "Dog Lover" });
            const observable3 = new Api_1.ObservableProperty("Cat", { name: "Cat Lover" });
            const observable4 = new Api_1.ObservableProperty("Hamustaa", { name: "Discordian" });
            function callback(args, id) {
                document.getElementById('testArea').appendChild(Api_1.paragraph(`I am ${this.value}. Event value: ${args.newValue}`, { id: "forwardTest" + id }));
            }
            // Passing around this in javascript is bloody annoying.
            // But usually we aren't linking directly to the observable and trying to manually send in enclosed values.
            // Not THIS redundant all the time.
            observable2.subscribe(args => callback.call(observable2, args, 1), observable2);
            observable3.subscribe(args => callback.call(observable3, args, 2), observable3);
            observable4.subscribe(args => callback.call(observable4, args, 3), observable4);
            observable3.sendChangeEventsTo(observable2);
            observable3.receiveChangeEventsFrom(observable4);
            // 4 is sending to 3, which is sending to 2. So modifying 4 will trigger all 3 callbacks.
            observable4.value = "Boa Constrictor";
            const observable5 = new Api_1.ObservableProperty("");
            observable5.subscribe(args => this.testArea.appendChild(Api_1.createElement("div", { innerHTML: observable5.safeValue, id: "escape1" })), observable5);
            observable5.value = "<p>paragraph should be escaped</p>";
            const observable6 = new Api_1.ObservableProperty("");
            observable6.subscribe(args => this.testArea.appendChild(Api_1.createElement("div", { innerHTML: observable6.value, id: "escape2" })), observable6);
            observable6.value = "<p>paragraph should not be escaped</p>";
            // If OnlyWhenChanged is true, then no event is invoked when the new value is the same as the old value.
            const observable7 = new Api_1.ObservableProperty('Foo', { onlyWhenChanged: true });
            observable7.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}. Old:${args.oldValue}`, { id: "noop" })), observable7);
            observable7.value = 'Foo';
            const observable8 = {
                prop: new Api_1.ObservableProperty("Foo")
            };
            observable8.prop.subscribe((args) => this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}. Old:${args.oldValue}`, { id: "assign" })), observable8);
            Api_1.observableAssign(observable8, { prop: "BAR", notprop: "BAZ" }); // very simple test
            Api_1.assert(observable8.notprop === "BAZ", "All properties copied by observableAssign");
            this.log('Async test initiated (1 test set).');
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
        // Testing async stuff is super annoying
        setTimeout(() => {
            try {
                const test1 = document.getElementById('test1');
                Api_1.assert(!!test1, 'changing value should execute the callback.');
                Api_1.assert(Api_1.e_(test1).innerHTML === "New:2. Old:1", "Correct arguments should be passed");
                const test2 = document.getElementById('test2');
                Api_1.assert(!!test2, 'changing value should execute the callback repeatedly.');
                const test3 = document.getElementById('forwardTest1');
                const test4 = document.getElementById('forwardTest2');
                Api_1.assert(!!test4, "When receiving change events, observable should be invoked by an event on the sender, using the same arguments");
                Api_1.assert(!!test3, "When sending change events, observable invocation should trigger an event on the receiver, using the same arguments");
                Api_1.assert(Api_1.e_(document.getElementById('escape1')).innerHTML === "&lt;p&gt;paragraph should be escaped&lt;/p&gt;", "safeValue should be escaped for string observables");
                Api_1.assert(Api_1.e_(document.getElementById('escape2')).querySelector('p').innerHTML === "paragraph should not be escaped", "value should not be escaped");
                Api_1.assert(document.getElementById('noop') === null, "No update when value not changed if onlyWhenChanged set");
                Api_1.assert(document.getElementById('assign').innerHTML === "New:BAR. Old:Foo", "Observable assign assigns full object without losing subscribers");
                this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
            }
            catch (err) {
                this.log('ERROR: ' + err);
                throw err;
            }
        }, 1000);
    }
}
exports.Test006 = Test006;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Observable (Roxy) by Proxy',
            descriptionHtml: `
            <p>A clean aproach for the programmer is to use ES2015 proxies. Proxies have been around for enough years
            that they should be supported by all browsers.  They have the benefit of being able to trap access to an
            object in a way that is invisible. They have the disadvantage of being orders of magnitude slower than
            direct access. But we're everywhere using promises, which are an order of magnitude slower than callbacks, so
            clearly CPU cycles are cheap these days. For normal GUI operations, high performance isn't needed.</p>

            <p>The way you create proxies in JavaScript is nasty stuff, and requires the original proxied object to
            be stored somewhere. This is hidden way from you by the ObservableProxy.proximate() method, which takes an
            object and returns the proxied observable version.</p>

            <p>Proxied observables do not have any helper methods like the observable property's safeValue. To the user, they
            appear to be simple POJOs, where get just returns a string. You have to remember to escape it yourself (this isn't
            to say I won't make an extension method at some point).</p>

            <pre><code>
                const observable = ObservableProxy.proximate<IUltimateQuestion>({ theAnswer: 41 });
                observable.subscribe(someComponent.render, someComponent);
                observable.theAnswer += 1;
            </code></pre>

            <p>As you can see, other than the factory method needed to create such an observable, you can access the object's keys as normal.  There's no need to access any special value property like there is with the ObservableProperty class.</p>

            <p>The place where it really shines is on arrays.  The amount of code required to create an ObservableList object is
            considerable (I have it right here), and such an object cannot be accessed using the obj[indexer] syntax, because that
            is built-in and can't be overridden. But on the other hand, this looks almost like a normal array:</p>

            <pre><code>
                const observable = ObservableProxy.proximate<number[]>([0, 1, 2]);
                observable.subscribe(someComponent.render, someComponent);
                observable.push(3, 4);
                observable[4] = 42;
            </code></pre>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test007 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // test this as a better-connected way to schedule async asserts, since I'm doing so much of them
            const asyncAsserts = new Api_1.DeferredPromise(Api_1.delay(1000), true);
            // This is the expected way to produce an observable.
            const observable1 = Api_1.ObservableProxy.proximate({ num1: 1, num2: 2 });
            Api_1.assert(observable1.num1 === 1 && observable1.num2 === 2, 'Observable should match initial values');
            observable1.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}. Old:${args.oldValue}.`, { id: "obs1test" + args.oldValue })));
            observable1.num1 = 2;
            observable1.num1 = 3;
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs1test1').innerHTML === 'New:2. Old:1.', 'Callback 1 executed with correct arguments'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs1test2').innerHTML === 'New:3. Old:2.', 'Callback 2 executed with correct arguments'));
            // It is possible to build a proxy of a simple value (anything but an object or function). The proximate() method must still
            // return an object, however. It does this by putting the value into a property named 'value.'
            const observable1a = Api_1.ObservableProxy.proximate(1);
            Api_1.assert(observable1a.value === 1, "Observable.value loaded with initial value.");
            observable1a.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`Key: ${args.propertyName}. New:${args.newValue}. Old:${args.oldValue}.`, { id: "observable1a" })));
            observable1a.value = 111;
            asyncAsserts.then(() => Api_1.assert(document.getElementById('observable1a').innerHTML === 'Key: value. New:111. Old:1.', 'Observable.value triggers callback'));
            // Of course, you could do THIS, but it won't do what you're expecting. proximate() makes a COPY (two actually), so changes
            // do not make it to the original object. So don't do this.
            const dontDoThis = { num1: 1, num2: 2 };
            const dontDoThisObservable = Api_1.ObservableProxy.proximate(dontDoThis);
            dontDoThisObservable.num1 = 3;
            Api_1.assert(dontDoThis.num1 === 1, 'Original object is not affected');
            const observable2 = Api_1.ObservableProxy.proximate({ name: "Dog" });
            const observable3 = Api_1.ObservableProxy.proximate({ name: "Cat" });
            const observable4 = Api_1.ObservableProxy.proximate({ name: "Cactus" });
            function callback(args, id) {
                document.getElementById('testArea').appendChild(Api_1.paragraph(`I am ${this.name}. Event value: ${args.newValue}`, { id: "forwardTest" + id }));
            }
            // Passing around "this" in javascript is bloody annoying.
            // But usually we aren't linking directly to the observable and trying to manually send in enclosed values.
            // Not THIS redundant (using call()) all the time.
            observable2.subscribe(args => callback.call(observable2, args, 1), observable2);
            observable3.subscribe(args => callback.call(observable3, args, 2), observable3);
            observable4.subscribe(args => callback.call(observable4, args, 3), observable4);
            observable3.sendChangeEventsTo(observable2);
            observable3.receiveChangeEventsFrom(observable4);
            // 4 is sending to 3, which is sending to 2. So modifying 4 will trigger all 3 callbacks.
            observable4.name = "Boa Constrictor";
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest1').innerHTML === 'I am Dog. Event value: Boa Constrictor', 'Two subscribe layers deep succeeded'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest2').innerHTML === 'I am Cat. Event value: Boa Constrictor', 'One subscribe layer deep succeeded'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest3').innerHTML === 'I am Boa Constrictor. Event value: Boa Constrictor', 'Original subscribe succeeded'));
            // Key deletions are also trapped
            const observable5 = Api_1.ObservableProxy.proximate({ world: 'Mars' });
            observable5.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`Type:${args.type}. Key:${args.propertyName}.`, { id: "observable5" })));
            delete observable5.world;
            asyncAsserts.then(() => Api_1.assert(document.getElementById('observable5').innerHTML === 'Type:delete. Key:world.', 'Proxy raises event on delete'));
            // A more generalized proximate function can allow you to track arbitrary method calls on an object. This lets you track changes
            // to inner objects without having to proxy those inner objects.
            class ComplexObject {
                constructor() {
                    this._arr = [1, 2, 3, 4, 5];
                }
                add(val) {
                    this._arr.push(val);
                }
                get(i) {
                    return this._arr[i];
                }
            }
            const observable6 = Api_1.ObservableProxy.proximateObject(new ComplexObject(), false, false, ['add']);
            observable6.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`Type:${args.type}. Key:${args.propertyName}. Args:${JSON.stringify(args.newValue)}.`, { className: 'observable6-no' })));
            const observable6a = Api_1.ObservableProxy.proximateObject(new ComplexObject(), false, false, ['add']);
            observable6a.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`Type:${args.type}. Key:${args.propertyName}. Args:${JSON.stringify(args.newValue)}.`, { className: 'observable6-yes' })));
            Api_1.assert(observable6.get(4) === 5, 'get method call returns expected value');
            asyncAsserts.then(() => Api_1.assert(document.querySelector('.observable6-no') === null, "Subscribe not called on unwatched method"));
            observable6a.add(6);
            asyncAsserts.then(() => Api_1.assert(document.querySelector('.observable6-yes').innerHTML === "Type:call. Key:add. Args:[6].", "Subscribe called on watched method"));
            // Arrays are very simple, and each method that modifies the array triggers an event.
            // Note that something that modifies an item contained inside the array, without modifing the array itself,
            // is not trapped. To handle this case, you must load the array with observable children, grandchildren, etc, or
            // use a state observable.
            const arr = Api_1.ObservableProxy.proximate(['a', 'b', 'c']);
            let idx = 0;
            arr.subscribe(args => {
                this.testArea.appendChild(Api_1.paragraph(`Operation:${args.type} ${args.propertyName}. <span>Now:[${args.newValue}]</span>`, { id: 'array' + idx }));
                idx += 1;
            });
            arr[3] = 'd';
            asyncAsserts.then(() => arrayTest(0, 'a,b,c,d', 'set'));
            arr.length = 3;
            asyncAsserts.then(() => arrayTest(1, 'a,b,c', 'length'));
            arr.push('D');
            asyncAsserts.then(() => arrayTest(2, 'a,b,c,D', 'push'));
            arr.splice(1, 1, 'B');
            asyncAsserts.then(() => arrayTest(3, 'a,B,c,D', 'splice'));
            arr.shift();
            asyncAsserts.then(() => arrayTest(4, 'B,c,D', 'shift'));
            arr.unshift('A');
            asyncAsserts.then(() => arrayTest(5, 'A,B,c,D', 'unshift'));
            arr.reverse();
            asyncAsserts.then(() => arrayTest(6, 'D,c,B,A', 'reverse'));
            arr.pop();
            asyncAsserts.then(() => arrayTest(7, 'D,c,B', 'pop'));
            arr.sort();
            asyncAsserts.then(() => arrayTest(8, 'B,D,c', 'sort'));
            arr.fill('Q', 0, 2);
            asyncAsserts.then(() => arrayTest(9, 'Q,Q,c', 'fill'));
            arr.copyWithin(0, 2);
            asyncAsserts.then(() => arrayTest(10, 'c,Q,c', 'copyWithin'));
            delete arr[0];
            asyncAsserts.then(() => arrayTest(11, ',Q,c', 'delete'));
            function arrayTest(int, expected, name) {
                Api_1.assert(document.querySelector(`#array${int} span`).innerHTML === `Now:[${expected}]`, `Array ${name} triggers observable`);
            }
            // To make a proxied observable synchronous, set disableAsync to true. This will execute
            // the callbacks in a synchronous way. Note in this example how the current value matches
            // the newValue, when if this were async, the current value would always be Remus.
            // Note that when a proxy is synchronous, subscribe() does not return a promise (obviously) but
            // instead returns undefined. Synchronous subscribe is not thenable.
            let idx2 = 0;
            const observable7 = Api_1.ObservableProxy.proximate({ name: 'World' }, true);
            observable7.subscribe(args => {
                this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}. Current:${observable7.name}.`, { id: "syncObservable" + idx2 }));
                idx2 += 1;
            });
            observable7.name = 'Vulcan';
            Api_1.assert(document.getElementById('syncObservable0').innerHTML === 'New:Vulcan. Current:Vulcan.', 'Callback called synchronously 1');
            observable7.name = 'Romulus';
            Api_1.assert(document.getElementById('syncObservable1').innerHTML === 'New:Romulus. Current:Romulus.', 'Callback called synchronously 2');
            observable7.name = 'Remus';
            Api_1.assert(document.getElementById('syncObservable2').innerHTML === 'New:Remus. Current:Remus.', 'Callback called synchronously 3');
            const observable8 = Api_1.ObservableProxy.proximate({ name: 'Foo' }, false, true);
            observable8.subscribe(args => {
                this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue}.`, { id: "noop" }));
            });
            observable8.name = 'Foo';
            asyncAsserts.then(() => Api_1.assert(document.getElementById('noop') === null, 'No update when value not changed if onlyWhenChanged set'));
            const arr2 = Api_1.ObservableProxy.proximate([1, 2, 3], true);
            arr2.subscribe(args => {
                this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue.length}. Current:${arr2.length}.`, { id: "syncObservable" + idx2 }));
                idx2 += 1;
            });
            arr2.push(4);
            Api_1.assert(document.getElementById('syncObservable3').innerHTML === 'New:4. Current:4.', 'Callback called synchronously (array 1)');
            arr2.push(5);
            Api_1.assert(document.getElementById('syncObservable4').innerHTML === 'New:5. Current:5.', 'Callback called synchronously (array 2)');
            this.log(`TEST ${this.viewModel.testNumber}: Sync tests succeeded`);
            this.log('Starting async tests');
            asyncAsserts.then(() => this.log(`TEST ${this.viewModel.testNumber}: Async tests succeeded`));
            asyncAsserts.catch(err => {
                this.log('ASYNC TESTS FAILED: ' + err.message);
                throw (err);
            });
            asyncAsserts.resolve();
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test007 = Test007;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Observable State',
            descriptionHtml: `<p>The state observable, an idea I stole from React, solves one of the basic problems of
            observable objects which may have references, using a somewhat clunky convention. This can be a fair tradeoff.
            The trade is such: by only reading the state using designated methods (value, getState, getValue, getSafeValue)
            and only writing to the state using setState(), you can be sure that changes to any referenced object are trapped.</p>

            <p>For example, if you have an object containing an array of objects, normally to raise an event when a property of
            one of those objects is modified, then that object must be observable. That can't always be done, especially if
            you don't control the source of the referenced object. But when every change has to go through setState(),
            it can be trapped there.</p>

            <p>The state in a state observable is an immutable clone of the data provided. Every time you get the object or
            write to the object, it is cloned. In terms of performance, it's probably even slower than a proxy, but in most
            use cases you won't even notice.</p>

            <p>The methods getValue(key) and getSafeValue(key) return the value of the key you provide. The .value getter
            and getState() method return the entire state.</p>

            <p>The setter .value replaces the entire state, as does the setState(val, true) method when overwriteAll is true.
            The method setState( { key: val } ) method replaces only the keys you provide, and the method setState( callback )
            method executes the callback on the value.  In all cases, setState returns the before and after values as
            { oldValue, newValue }.  When a callback is used, a 'returnValue' key returns any value returned from the callback.</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test008 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // this seems to be working out well
            const asyncAsserts = new Api_1.DeferredPromise(Api_1.delay(1000), true);
            const testObject = {
                place: 'motels',
                howMany: 200,
                header: '<h1>200 Motels</h1>',
                caps: function () {
                    return `${this.howMany} ${this.place}`.toUpperCase();
                },
                get getter() {
                    return this.caps();
                },
                voices: [
                    { name: 'Flo' },
                    { name: 'Eddie' },
                    { name: 'Jimmie Carl Black' },
                    { name: 'Jim Pons' }
                ]
            };
            // Demonstrating setState
            testObject.year = 1971;
            const observable1 = new Api_1.ObservableState(testObject);
            // Both for legibility and to avoid pulling the value 4 times
            const v1 = observable1.value;
            Api_1.assert(v1.place === 'motels' && v1.howMany === 200 && v1.voices.length === 4, 'value should return the original data');
            Api_1.assert(v1 !== testObject, 'value should not return the actual referenced object');
            const v1b = observable1.getState();
            Api_1.assert(v1b.place === 'motels' && v1b.howMany === 200 && v1b.voices.length === 4, 'getState should return the original data');
            Api_1.assert(observable1.getSafeValue('header') === '&lt;h1&gt;200 Motels&lt;&#x2F;h1&gt;', 'getSafeValue gets the HTML-escaped value if a string');
            Api_1.assert(observable1.getValue('header') === '<h1>200 Motels</h1>', 'getValue is not HTML-escaped');
            Api_1.assert(Array.isArray(observable1.getValue('voices')), 'getValue gets the value having the supplied key');
            Api_1.assert(observable1.value.caps() === '200 MOTELS', 'Logic such as methods can be stored/cloned');
            Api_1.assert(observable1.value.getter === '200 MOTELS', 'Custom getters can be stored/cloned, though they suck');
            // You can set single keys using a partial object
            const updated1a = observable1.setState({ place: 'Motels' });
            Api_1.assert(observable1.value.place === 'Motels', 'setState updates the key provided');
            Api_1.assert(observable1.value.howMany === 200, 'setState leaves other keys as-is');
            Api_1.assert(updated1a.oldValue.place === 'motels' && updated1a.newValue.place === 'Motels', 'setState returns old and new values');
            // You can also update using a callback, which is good when you need to do incremental modifications.
            // TypeScript is not very good about this, though. It forgets the type of the state object and forces
            // a verbose cast.
            const updated1b = observable1.setState((val) => val.howMany += 1);
            Api_1.assert(observable1.getValue('howMany') === 201, 'Callback was executed');
            Api_1.assert(updated1b.oldValue.howMany === 200 && updated1b.newValue.howMany === 201 && updated1b.returnValue === 201, 'setState returns old, new, and return values for callback input');
            // When setState is called with overwriteAll set to true, or when using the setter, the entire object is replaced.
            observable1.setState({
                place: 'gore motel',
                howMany: 1,
                header: '<h1>Gore Motel</h1>',
                caps: function () {
                    return `${this.howMany} ${this.place}`.toUpperCase();
                },
                get getter() {
                    return this.caps();
                },
                voices: []
            }, true);
            Api_1.assert(observable1.value.place === 'gore motel', 'setState with an entire object');
            Api_1.assert(observable1.value.year === undefined, 'setState with overwriteAll true replaces everything, even unlisted properties');
            observable1.value = {
                place: 'fugitive motel',
                howMany: 1,
                header: '<h1>Fugitive Motel</h1>',
                caps: function () {
                    return `${this.place}`.toUpperCase();
                },
                get getter() {
                    return this.caps();
                },
                voices: [
                    { name: 'Guy Garvey' },
                    { name: 'Craig Potter' },
                    { name: 'Mark Potter' },
                    { name: 'Pete Turner' }
                ]
            };
            Api_1.assert(observable1.value.place === 'fugitive motel', 'value setter');
            // Remember, value is a clone of the internal state. You cannot use it to modify the state.
            observable1.value.howMany = 1000;
            Api_1.assert(observable1.value.howMany === 1, 'Internal state is read-only');
            const observable2 = new Api_1.ObservableState(testObject);
            observable2.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue.howMany}. Old:${args.oldValue.howMany}.`, { id: "obs2test" + args.oldValue.howMany })));
            observable2.setState({ howMany: 300 });
            observable2.setState({ howMany: 400 });
            observable2.setState((prev) => prev.howMany = prev.howMany / 2);
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs2test200').innerHTML === 'New:300. Old:200.', 'Callback 1 executed with correct arguments'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs2test300').innerHTML === 'New:400. Old:300.', 'Callback 2 executed with correct arguments'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs2test400').innerHTML === 'New:200. Old:400.', 'Callback 3 executed with correct arguments'));
            // And now, to demonstrate the reason the state observable exists. The following test would take a bit more work to
            // get functioning using ordinary observables. Voices would need to be an array of observables, not simple objects.
            // We'll also demonstrate the cloning of a state observable.
            const observable3 = new Api_1.ObservableState(observable2);
            observable3.subscribe(args => this.testArea.appendChild(Api_1.paragraph(`Voices:${args.newValue.voices.map((m) => m.name).join(', ')}`, { id: "obs3test" })));
            observable3.setState((obj) => {
                obj.voices[0].name = 'Mark Volman';
                obj.voices[1].name = 'Howard Kaylan';
            });
            asyncAsserts.then(() => Api_1.assert(document.getElementById('obs3test').innerHTML === 'Voices:Mark Volman, Howard Kaylan, Jimmie Carl Black, Jim Pons', 'Callback executed with nested modification'));
            // The same forward/bubble events exist as on other observables
            const observable4 = new Api_1.ObservableState({ name: "Dog" });
            const observable5 = new Api_1.ObservableState({ name: "Cat" });
            const observable6 = new Api_1.ObservableState({ name: "Cactus" });
            function callback(args, id) {
                document.getElementById('testArea').appendChild(Api_1.paragraph(`I am ${this.value.name}. Event value: ${args.newValue.name}`, { id: "forwardTest" + id }));
            }
            // Passing around "this" in javascript is bloody annoying.
            observable4.subscribe(args => callback.call(observable4, args, 1), observable4);
            observable5.subscribe(args => callback.call(observable5, args, 2), observable5);
            observable6.subscribe(args => callback.call(observable6, args, 3), observable6);
            observable5.sendChangeEventsTo(observable4);
            observable5.receiveChangeEventsFrom(observable6);
            // 4 is sending to 3, which is sending to 2. So modifying 4 will trigger all 3 callbacks.
            observable6.value = { name: "Boa Constrictor" };
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest1').innerHTML === 'I am Dog. Event value: Boa Constrictor', 'Two subscribe layers deep succeeded'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest2').innerHTML === 'I am Cat. Event value: Boa Constrictor', 'One subscribe layer deep succeeded'));
            asyncAsserts.then(() => Api_1.assert(document.getElementById('forwardTest3').innerHTML === 'I am Boa Constrictor. Event value: Boa Constrictor', 'Original subscribe succeeded'));
            // To make an observable synchronous, set disableAsync to true. This will execute the callbacks in a synchronous way. Note
            // in this example how the current value matches the newValue, when if this were async, the current value would always be Remus.
            let idx = 0;
            const observable7 = new Api_1.ObservableState({ name: 'World' }, { disableAsync: true });
            observable7.subscribe(args => {
                this.testArea.appendChild(Api_1.paragraph(`New:${args.newValue.name}. Current:${observable7.getSafeValue('name')}.`, { id: "syncObservable" + idx }));
                idx += 1;
            });
            observable7.value = { name: 'Vulcan' };
            Api_1.assert(document.getElementById('syncObservable0').innerHTML === 'New:Vulcan. Current:Vulcan.', 'Callback called synchronously 1');
            observable7.value = { name: 'Romulus' };
            Api_1.assert(document.getElementById('syncObservable1').innerHTML === 'New:Romulus. Current:Romulus.', 'Callback called synchronously 2');
            observable7.value = { name: 'Remus' };
            Api_1.assert(document.getElementById('syncObservable2').innerHTML === 'New:Remus. Current:Remus.', 'Callback called synchronously 3');
            // The observable object can be a primitive object.
            const observable8 = new Api_1.ObservableState("World");
            observable8.value = 'Mars';
            Api_1.assert(observable8.value === 'Mars', 'State can be a primitive object');
            // You can call getValue() and getSaveValue() with no args.
            Api_1.assert(observable8.getValue() === 'Mars', 'getValue() called with no args for a primitive object');
            observable8.value = '<>';
            Api_1.assert(observable8.getSafeValue() === '&lt;&gt;', 'getSafeValue() called with no args for a primitive object');
            // SetState can be used, it cannot be called with either a partial (primitives don't have partial object properties to set) or
            // a method (it will execute, but primitives are immutable and mostly value types, so if you replace them, changes are lost).
            observable8.setState('Jupiter', true);
            Api_1.assert(observable8.getValue() === 'Jupiter', 'setState() called with overwriteAll for a primitive object');
            observable8.setState('Saturn');
            Api_1.assert(observable8.getValue() === 'Saturn', 'On primitive types, overwriteAll is set automatically');
            this.log('Starting async tests');
            asyncAsserts.then(() => this.log(`TEST ${this.viewModel.testNumber}: Async tests succeeded`));
            asyncAsserts.catch(err => {
                this.log('ASYNC TESTS FAILED: ' + err.message);
                throw err;
            });
            asyncAsserts.resolve();
            this.log(`TEST ${this.viewModel.testNumber}: Sync tests succeeded`);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test008 = Test008;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Components',
            descriptionHtml: `<p>A component is the base class that implements IContent, an object whose "content"
            property is an HTMLElement that is the representation of the object on the page. Most of the class
            is made up of helpers to make construction easy and to access common functions, like innerHTML, without
            having to type obj.content.HTML.</p>

            <h2>Usage</h2>
            <pre><code>
            abstract class Component<TElement> {
                content: TElement;
                get id(): string;
                set id(value);
                get innerHTML(): string;
                set innerHTML(value);

                constructor();
                constructor(lookupExistingElement: IExistingLookupOptions);
                constructor(existingElement: IExistingElementOptions<TElement>);
                constructor(newElement: IInnerHtmlOptions);
                constructor(newElement: IOuterHtmlOptions);
                constructor(newElement: string);

                addEventListener(eventType: string, event: (evt: Event) => any, options?: AddEventListenerOptions): this;
                addInlineEventListeners(componentFilter?: string): this;

                append<T>(newChild: T): this;

                appendChild<T>(newChild: T): T;

                setStyle(property: string, value: string): this;
                setStyle(style: { [string]: string }): this;

                setClass(className: string): this;
                setClass(classNames: string[]): this;

                appendToParent(parent: Node): this;
            }
            </code></pre>

            <p>The component is just a base class, so you must inherit from it. All the work is in the constructor. You can pass it an
            existing element, enough info to look up an element, a tag name and the inner HTML, the full outer HTML (either as an object
            or a string). The rest are just helper methods that access the "content" object, which is a reference to the element you
            passed in the constructor.</p>

            <p>The one exception to this rule is the addInlineEventListeners() method, which acts upon custom attributes. If you create
            an element with a property named either i5_event or :event, along with an event name in parentheses set equal to a method
            on the component, it is translated into an addEventListener() call.</p>

            <pre><code>
            &lt;button type="button" i5_event (click)="something"&gt;Click Me&lt;/button&gt;
            </code></pre>

            <p>This is the same as button.addEventListener('click', component.something.bind(component));</p>
            `
        });
    }
}
/**
 * This class has nothing to add to the component. Makes it faster to unit test.
 * Normally you would probably set this to something specific.
 */
class PassThroughComponent extends Api_1.Component {
    constructor(args) {
        super(args);
    }
}
class Test009 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            const comp1 = new PassThroughComponent();
            Api_1.assert(comp1.content.tagName === "DIV", "Default should be div component.");
            const comp2 = new PassThroughComponent({ id: 'comp2' });
            Api_1.assert(comp2.content.id === 'comp2', "Id should match containerId");
            Api_1.assert(comp2.id === comp2.content.id, "Id helper should return content element id");
            this.testArea.appendChild(comp2.content);
            Api_1.assert(!!this.testArea.querySelector('#comp2'), "Should be able to add content to page");
            comp2.innerHTML = "Hello component 2";
            Api_1.assert(comp2.content.innerHTML === "Hello component 2", "innerHTML setter should set content HTML");
            const comp3 = new PassThroughComponent({ id: 'comp3', innerHtml: 'Hello component 3', type: Api_1.elementType.HTMLSpanElement });
            Api_1.assert(comp3.content.innerHTML === "Hello component 3", "innerHtml setting should set initial HTML");
            Api_1.assert(comp3.content.tagName === "SPAN", "Should create tag type provided in constructor");
            const adiv = Api_1.div("Some existing element");
            const comp4 = new PassThroughComponent({ element: adiv });
            Api_1.assert(comp4.content === adiv, "When containerElement specified, it should become the content of the component");
            Api_1.assert(Api_1.ComponentMap.components.get(comp4.content) === comp4, "ComponentMap should return component when provided component content");
            const comp4a = comp4.append(Api_1.div("A new child", { id: 'comp4a' }));
            Api_1.assert(!!comp4.content.querySelector('#comp4a'), "Append() should append to content");
            Api_1.assert(comp4a === comp4, "Append() should return reference to component.");
            const div2 = Api_1.div("A new child", { id: 'comp4b' });
            const comp4b = comp4.appendChild(div2);
            Api_1.assert(!!comp4.content.querySelector('#comp4b'), "appendChild() should append to content");
            Api_1.assert(comp4b === div2, "appendChild() should return reference to child.");
            const div3 = Api_1.div("Another element", { id: 'comp5a' });
            const comp5 = new PassThroughComponent({ element: div3 });
            const comp6 = comp5.addClass('a-class').addClass('b-class c-class').addClass(['d-class', 'e-class']).setStyle('border', 'solid').setStyle({ color: 'blue' });
            Api_1.assert(comp6 === comp5, "setClass() and setStyle() should return reference to child");
            for (const c of ['a-class', 'b-class', 'c-class', 'd-class', 'e-class']) {
                Api_1.assert(Array.from(div3.classList).includes(c), "setClass() should add class to content");
            }
            Api_1.assert(div3.style.border === 'solid', "setStyle() should set style of content");
            Api_1.assert(div3.style.color === 'blue', "setStyle() should set style of content");
            comp5.appendToParent(this.testArea);
            Api_1.assert(!!this.testArea.querySelector('#comp5a'), "appendToParent() should add content as child of target element");
            const comp7 = new PassThroughComponent({ outerHtml: '<span id="comp7" style="display: block;">Hello component 7</span>' }).appendToParent(this.testArea);
            Api_1.assert(comp7.content.innerHTML === "Hello component 7", "outerHtml setting should set initial HTML");
            Api_1.assert(comp7.content.tagName === "SPAN", "Should create tag type provided in outerHTML");
            // Here's something a little fancy.
            // There are already ways to add events, with no need to resort to shortcuts. But event shortcuts
            // are common in javascript frameworks. Take angular, which stores method call as a string, which is executed.
            // Now shudder.
            // In Ichigo, we add an i5_event or :event attribute to the HTML (both are acceptable ... it just depends on if you
            // mind non-standard attribute format or not), and then the event type in parentheses, which is set equal to a method in
            // the component.  This method is called with the event as its only argument, as in the following examples:
            // <div i5_event (click)="doSomething"></div>
            // <input :event (input)="writeSomething" />
            // The following is invalid and will throw: <button :event (click)="modifySometing(evt.currentTarget, someClosure)"></button>
            // It will throw because that string is not a method name on the component (unless you have weird methods).
            let comp8clicked;
            class Comp8Test extends Api_1.Component {
                constructor() {
                    super('<div id="comp8" i5_event (click)="simpleTest">Click Me</div>');
                    this.addInlineEventListeners();
                }
                simpleTest(evt) {
                    comp8clicked = 'I was clicked';
                }
            }
            const comp8 = new Comp8Test().appendToParent(this.testArea);
            comp8.content.click();
            Api_1.assert(!!comp8clicked, 'Click event should be wired to method');
            this.log(`TEST ${this.viewModel.testNumber}: Test successful`);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test009 = Test009;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Bound Component',
            descriptionHtml: `<p>A bound component is a component that has its 1- or 2-way databinding configured by custom HTML attributes beginning with the string "i5_" (or :, which is either valid or invalid depending on which spec you read). The main inspiration, and most of the ideas, are taken from AngularJS and Vue, though Ichigo's templating language is much more basic and does not involve special tokens like {} or {{}}.</p>

            <p>As usual in HTML5, bound components can be constructed in JavaScript code or a combination of JavaScript and HTML. There is even partial support for custom element tags, though this is done by replacing the element, not building a shadow root.</p>

            <p>(A shadow root webcomponent helper is a task for another day, when I feel up to it. The standard has changed and many pages about it are now incorrect, so it's a chore.)</p>

            <h2>Usage</h2>
            <pre><code>
            class BoundComponent<TElement extends HTMLElement = HTMLElement, TModel = any> extends Component<TElement> implements IView<TElement, TModel> {
                static inject<TElement extends HTMLElement, TModel>(selector?: string | HTMLElement | NodeListOf<HTMLElement> | HTMLElement[] | {
                    parent?: Element;
                    selector: string;
                }, options?: BoundInjectOptions<TModel>, constructor?: Constructable<BoundComponent<TElement, TModel>>, viewModel?: TModel): Array<BoundComponent<TElement, TModel>>;

                static injectBind<TElement extends HTMLElement, TModel>(viewModel?: TModel, selector?: string | HTMLElement | NodeListOf<HTMLElement> | HTMLElement[] | {
                    parent?: Element;
                    selector: string;
                }, options?: BoundInjectOptions<TModel>, constructor?: Constructable<BoundComponent<TElement, TModel>>): Array<BoundComponent<TElement, TModel>>;

                constructor(viewModel: TModel);
                constructor(viewModel: TModel, existingElement: IExistingElementOptions<TElement> & IComponentBindingOptions);
                constructor(viewModel: TModel, existingElement: IExistingLookupOptions & IComponentBindingOptions);
                constructor(viewModel: TModel, newElement: IInnerHtmlOptions & IComponentBindingOptions);
                constructor(viewModel: TModel, outerElement: IOuterHtmlOptions & IComponentBindingOptions);
                constructor(viewModel: TModel, newElement: string);

                write(evt: Event): void;
                observe(model?: any): this;
                observeAll(model?: any): this;
                render(): this;
                setTemplate(templateText: string, update?: boolean): this;
                setHtmlTemplate(templateProperty?: string, update?: boolean): this;
                setTextTemplate(templateProperty?: string, update?: boolean): this;
                setLoop(source: string, fragment: DocumentFragment | string, skipPostProcess?: boolean, update?: boolean): this;
                removeLoop(update?: boolean): this;
                setValueAttribute(source?: string | undefined, update?: boolean): this;
                setVisibility(source?: string | undefined, negative?: boolean, update?: boolean): this;
                addAttributeMapping(attribute: string, source?: string, update?: boolean): this;
                addBooleanAttributeMapping(attribute: string, source?: string, negative?: boolean, update?: boolean): this;
                removeAttributeMapping(attribute: string, update?: boolean): this;
                setCssClass(cls?: string | undefined, update?: boolean): this;
                setCssStyle(style?: string | undefined, update?: boolean): this;
                addCssClassSwitch(cls: string, source?: string, negative?: boolean, update?: boolean): this;
                removeCssClassSwitch(cls: string, update?: boolean): this;
                addWriteEvent(): this;
                addWriteTarget(target?: string, update?: boolean): this;
                removeWriteTarget(target: string, update?: boolean): this;
                dispose(): void;
                protected loopPostProcess(row: any, addedContent: Node[], allRows: Iterable<any>, previousContent: DocumentFragment): void;
            }
            </code></pre>

            <p>The most basic constructor looks like this: new BoundComponent(viewModel).  The view model is any data type.  Normally it is expected to be an observable object, but it could be a simple string or number, if needed.</p>

            <p>You can also convert components using the static BoundComponent.inject() method, which is convenient if you need to convert many elements at once.</p>

            <p>The most important part of the bound component is the ability to set an HTML template for the content. This is done using by using HTML templates, behind the scenes.  What this means is that you should pass valid HTML, either in the innerHTML of the content or as the argument of parseTemplate(). Now, special replacement tags like {} or \${} (I wish template literals were actual templates, then I could use them) are not part of HTML. The way you indicate replacements is with i-v tags, for example &lt;i-v&gt;viewModelVariableName&lt;/i-v&gt;. ViewModelVariableName must be a property of the viewModel you sent in.</p>

            <p>If you send in a simple data type, not an object, you can reference it by a period by itself ('.') as in "Hello &lt;i-v&gt;.&lt;/i-v&gt;"</p>

            <p>To avoid HTML escaping replacement values, include the noescape attribute, &lt;i-v noescape&gt;. If you need to nest components, indicate which component owns a replacement by using the name as a custom attribute &lt;i-v name&gt; (thus, names should contain only valid characters).</p>

            <p>There are so many custom properties in the bound component that I can't really go through them here. I'll summarize them and you can look through the test cases. The following are custom element attributes:</p>

            <ul>
            <li> i5_name="" or :name="" - Name for the component, used to bind specific &lt;i-v name&gt; tags when there are nested components
            <li> i5_text="property" or :text="property" - Set innerHTML to escaped property
            <li> i5_html="property" or :html="property" - Set innerHTML to unescaped property
            <li> i5_value="property" or :value="property" - Set form field value to property
            <li> i5_attr_attributeName="property" or i5_attr:attributeName="property" or :attr:attributeName="property" - Set attribute attributeName to property
            <li> i5_bool_attributeName="property" or i5_bool:attributeName="property" or :bool:attributeName="property" - Add boolean attribute attributeName if property is truthy
            <li> i5_bool0_attributeName="property" or i5_bool-:attributeName="property" or :bool-:attributeName="property" - Remove boolean attribute attributeName if property is truthy
            <li> i5_style="property" or :style="property" - Set style string to property
            <li> i5_class="property" or :class="property" - Set classList string to property
            <li> i5_switch_className="property" or i5_switch:className="property" or :switch:className="property" - If property is truthy, add className. If falsy, remove className
            <li> i5_switch0_className="property" or i5_switch-:className="property" or :switch-:className="property" - Reverse of previous option
            <li> i5_if="property" or :if="property" - If property is truthy, display:none applied. If falsy, removed (and possibly reset if switched on then off)
            <li> i5_if0="property" or :if-="property" - Reverse of previous option
            <li> i5_loop="property" or :loop="property" - Repeat element once for each item in property, calling loopPostProcess() after
            <li> i5_loop_null="property" or i5_loop:null="property" or :loop:null="property" - The same, but loopPostProcess() is not called
            <li> i5_item or :item (no value) - Indicate a the item in a loop that should be converted into a component
            <li> i5_input or :input (no value) - Bind input events on form field to the BoundComponent.write() method
            <li> i5_target="property" or :target="property" - BoundComponent.write() should send input data to property
            <li> i5_target1="property", i5_target2="property", :target1="property", etc - The same, but write to multiple targets
            <li> i5_input="property" or :input="property" - Shortcut for i5_input i5_target="property"
            </ul>

            <p>"Property" can be an object property, observable property, or parameterless function name. Can be prefixed with "this." to reference the component itself. These custom attributes can be used as attributes, data attributes, or passed in the constructor.</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test010 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            const basicViewModel = {
                name: "World",
                list: ["World", "Underworld"],
                cssClass: 'does-nothing',
                cssClasses: 'class-1 class-2',
                rawHtml: "Hello <em>World</em>",
                truthiness: true,
                trumpiness: false,
                nothing: null,
                block: "display: block",
                bold: "font-weight: bold",
                sampleMethod: function () { return this.name; },
                sampleMethod2: function () { return this.cssClass; },
                sampleMethod3: function () { return `Hello <em>${this.name}</em>`; },
                writable: null,
                writable2: null,
                writerMethod: function (arg) { this.writable = arg; },
                lastListItem: function () { return this.list[this.list.length - 1]; }
            };
            const asyncAsserts = new Api_1.DeferredPromise(Api_1.delay(1000), true);
            // Create the most basic template using pure JS and a simple HTML template.
            // This shows the template replacement format, using <i-v> tags.
            const comp1 = new Api_1.BoundComponent(basicViewModel, { element: Api_1.createElement(Api_1.elementType.HTMLDivElement, { innerHTML: 'Hello <i-v>name</i-v>' }) }).appendToParent(this.testArea);
            Api_1.assert(comp1.innerHTML === 'Hello <i-v>World</i-v>', 'Simple HTML replacement should populate i-v tags.');
            // The viewModel can be a simple object and can be referenced by '.'
            const comp2 = new Api_1.BoundComponent("World", { innerHtml: 'Hello <i-v>.</i-v>' }).appendToParent(this.testArea);
            Api_1.assert(comp2.innerHTML === 'Hello <i-v>World</i-v>', 'Period should indicate the viewModel itself.');
            // Attributes amd other can be set using special attributes. More on this later.
            const comp3 = new Api_1.BoundComponent(basicViewModel, {
                id: 'comp3',
                innerHtml: 'Hello <i-v>name</i-v>',
                attributes: {
                    i5_class: 'cssClass'
                }
            }).appendToParent(this.testArea);
            Api_1.assert(comp3.classList.toString() === 'does-nothing', "CSS class attribute should be set");
            // Like its base class, Component, it can be created with no rendering arguments, only the viewModel (which is required).
            // If you do this, you'll need to pass in any dynamic attributes after the fact.
            const comp4 = new Api_1.BoundComponent(basicViewModel)
                .appendToParent(this.testArea)
                .setTemplate('Hello <i-v>name</i-v>')
                .setCssClass('cssClass', true);
            Api_1.assert(comp4.innerHTML === 'Hello <i-v>World</i-v>', 'setTemplate should replace the HTML template.');
            Api_1.assert(comp4.classList.toString() === 'does-nothing', "CSS class attribute should be set");
            // The normal way to create a component is not like the examples given before, but to
            // reference an existing HTML DOM element. While it is possible to set the properties
            // entirely in JS code, there's no need for a bound component without HTML attributes.
            // Note that the TS has to take our word for it that the element is HTMLDivElement.
            this.testArea.appendChild(Api_1.createHtml('<div id="comp5" i5_class="cssClass">Hello <i-v>name</i-v></div>'));
            const comp5 = new Api_1.BoundComponent(basicViewModel, { element: document.getElementById('comp5') });
            Api_1.assert(comp5.innerHTML === 'Hello <i-v>World</i-v>', 'Simple HTML replacement should populate i-v tags.');
            Api_1.assert(comp5.classList.toString() === 'does-nothing', "CSS class attribute should be set");
            // This is a shortcut for the same thing (with a small twist). It gets extra speed because the type isn't checked.
            // So it has a minus, which is that TS doesn't get the type.
            this.testArea.appendChild(Api_1.createHtml('<div id="comp5a" i5_class="cssClass">Hello <i-v>name</i-v></div>'));
            const comp5a = new Api_1.BoundComponent(basicViewModel, { parent: this.testArea, selector: '#comp5a' });
            Api_1.assert(comp5a.innerHTML === 'Hello <i-v>World</i-v>', 'Simple HTML replacement should populate i-v tags.');
            Api_1.assert(comp5a.classList.toString() === 'does-nothing', "CSS class attribute should be set");
            // You could also create a new component using new HTML, using almost the same code, using the outerHtml overload.
            // Again, TS has to take our word for it that we're using a DIV, because it's not like it knows.
            // This does make for the quickest unit testing, however, so I will use it extensively.
            const comp6 = new Api_1.BoundComponent(basicViewModel, { outerHtml: '<div id="comp6" i5_class="cssClass">Hello <i-v>name</i-v></div>' }).appendToParent(this.testArea);
            Api_1.assert(comp6.innerHTML === 'Hello <i-v>World</i-v>', 'Simple HTML replacement should populate i-v tags.');
            Api_1.assert(comp6.classList.toString() === 'does-nothing', "CSS class attribute should be set");
            // Property names can reference data fields but they can also reference methods. If a method is referenced, it is executed
            // and the result is inserted. The method is called with no arguments.
            // Also, outerHtml is so easy to set that you may want to use this shortcut.
            // CONSIDER: Offer a way to set arguments. This can easily get hairy.
            const comp7 = new Api_1.BoundComponent(basicViewModel, '<div id="comp7" i5_class="sampleMethod2">Hello <i-v>sampleMethod</i-v></div>').appendToParent(this.testArea);
            Api_1.assert(comp7.innerHTML === 'Hello <i-v>World</i-v>', 'Methods should be called when referenced');
            Api_1.assert(comp7.classList.toString() === 'does-nothing', "Methods should be called when referenced");
            // Values are by default escaped.
            const comp8 = new Api_1.BoundComponent(basicViewModel, '<div id="comp8">Escaped: <i-v>rawHtml</i-v></div>').appendToParent(this.testArea);
            Api_1.assert(comp8.innerHTML === 'Escaped: <i-v>Hello &lt;em&gt;World&lt;/em&gt;</i-v>', "By default replacements should be HTML escaped");
            // You can skip the HTML escape process by adding a noescape property to the i-v element.
            const comp9 = new Api_1.BoundComponent(basicViewModel, '<div id="comp9">Not escaped: <i-v noescape>rawHtml</i-v></div>').appendToParent(this.testArea);
            Api_1.assert(comp9.content.querySelector('i-v').innerHTML === 'Hello <em>World</em>', "If noescape set, replacements should not be HTML escaped");
            // Escaped text can be set directly by using the i5_text attribute, instead of using the HTML template.
            // This makes a simple one-element template
            const comp10 = new Api_1.BoundComponent(basicViewModel, { outerHtml: '<div id="comp10" i5_text="rawHtml"></div>' }).appendToParent(this.testArea);
            Api_1.assert(comp10.innerHTML === '<i-v>Hello &lt;em&gt;World&lt;/em&gt;</i-v>', "Text property should set escaped HTML");
            // The non-escaped HTML can also be set directly by the i5_html attribute, instead of using the HTML template.
            // This makes a simple one-element template.
            const comp11 = new Api_1.BoundComponent(basicViewModel, '<div id="comp11" i5_html="rawHtml"></div>').appendToParent(this.testArea);
            // The HTML in this case is -- <i-v noescape="">Hello <em>World</em></i-v> -- which may be browser specific.
            Api_1.assert(comp11.content.firstElementChild.innerHTML === 'Hello <em>World</em>', 'HTML property should set unescaped HTML');
            // One will probably use the shortcut text and html properties with methods, however, in places where the HTML needs to be
            // very dynamic. Just like always, methods are fine.
            const comp12 = new Api_1.BoundComponent(basicViewModel, { outerHtml: '<div id="comp12" i5_html="sampleMethod3"></div>' }).appendToParent(this.testArea);
            Api_1.assert(comp12.content.firstElementChild.innerHTML === 'Hello <em>World</em>', 'Methods should be called when referenced');
            // And just like always, simple models can be accessed by '.'
            const comp13 = new Api_1.BoundComponent("Hello <em>World</em>", '<div id="comp13" i5_html="."></div>').appendToParent(this.testArea);
            Api_1.assert(comp13.content.firstElementChild.innerHTML === 'Hello <em>World</em>', 'Simple objects should be referenced by period');
            // Form fields are pretty nasty because the HTML standard doesn't have a standard way to set the value.
            // To make setting them as easy as it is to set the HTML, the i5_value property is introduced.
            this.testArea.appendChild(Api_1.createFragment(`<div>
                <input id="comp14a" i5_value="name" />
                <select id="comp14b" i5_value="name">
                    <option value="Sun">Sun</option>
                    <option value="Moon">Moon</option>
                    <option value="Stars">Stars</option>
                    <option value="World">World</option>
                    <option value="Underworld">Underworld</option>
                </select>
                <select id="comp14c" i5_value="list" multiple size="2">
                    <option value="World">World</option>
                    <option value="Underworld">Underworld</option>
                    <option value="Sun">Sun</option>
                    <option value="Moon">Moon</option>
                    <option value="Stars">Stars</option>
                </select>
            </div>`));
            const comp14a = new Api_1.BoundComponent(basicViewModel, { element: document.getElementById('comp14a') });
            const comp14b = new Api_1.BoundComponent(basicViewModel, { element: document.getElementById('comp14b') });
            const comp14c = new Api_1.BoundComponent(basicViewModel, { element: document.getElementById('comp14c') });
            Api_1.assert(comp14a.value === 'World', 'Input value can be set');
            Api_1.assert(comp14b.value === 'World', 'Single select value can be set');
            const setsAreEqual = (a, b) => a.size === b.size && [...a].every(v => b.has(v));
            Api_1.assert(setsAreEqual(new Set(comp14c.value), new Set(['World', 'Underworld'])), 'Multi select value can be set');
            // You can set attributes by using i5_attr_attribute or i5_attr:attribute.
            // One looks nicer in HTML but isn't valid JS. The other is less clear but is valid.
            // You can set boolean attributes by using i5_bool_attribute or i5_bool:attribute
            const comp15a = new Api_1.BoundComponent(basicViewModel, '<input id="comp15a" i5_value="name" i5_bool:disabled="truthiness" i5_attr:style="block" />').appendToParent(this.testArea);
            Api_1.assert(comp15a.value === 'World', 'Value should set value');
            Api_1.assert(comp15a.style.display === 'block', 'Attr should set attribute');
            Api_1.assert(comp15a.content.hasAttribute('disabled'), 'Attr should set boolean attribute');
            // Same thing, different style
            const comp15b = new Api_1.BoundComponent(basicViewModel, {
                id: 'comp15b',
                type: Api_1.elementType.HTMLInputElement,
                attributes: {
                    // tslint:disable-next-line:object-literal-key-quotes
                    i5_value: 'name',
                    // tslint:disable-next-line:object-literal-key-quotes
                    i5_attr_style: 'block',
                    'i5_bool:disabled': 'truthiness'
                }
            }).appendToParent(this.testArea);
            Api_1.assert(comp15b.value === 'World', 'Value should set value');
            Api_1.assert(comp15b.style.display === 'block', 'Attr should set attribute');
            Api_1.assert(comp15b.content.hasAttribute('disabled'), 'Attr should set boolean attribute');
            // Boolean attributes are ones that take effect if they even exist, regardless of their values.
            // They can be negates by adding ! to the end, i5_bool!:attribute
            // Also there's a different way to set style. While it is possible to set style through attributes, this is probably not normal.
            // Mainly because attributes are the initial value, not the current value.
            // You can set only one style string, mainly because it gives you an easy way to remove previous styles.
            const comp15c = new Api_1.BoundComponent(basicViewModel, '<input id="comp15c" i5_value="name" i5_bool-:disabled="nothing" i5_style="block" />').appendToParent(this.testArea);
            Api_1.assert(comp15c.content.hasAttribute('disabled'), 'Null attr should set negated boolean attribute');
            Api_1.assert(comp15c.style.display === 'block', 'Style should set style');
            // You can set the classList with i5_class, which we've already seen. If there are multiple classes, include them
            // separated by space, just like you do in HTML. This lets you turn classes on or off.
            // You can also swtich classes on or off based on truthy/falsy values using i5_switch:class (or i5_switch_class).
            const comp16 = new Api_1.BoundComponent(basicViewModel, '<div id="comp16" i5_class="cssClasses" i5_switch_class-3="nothing" i5_switch:class-4="truthiness">Hello World</div>').appendToParent(this.testArea);
            Api_1.assert(comp16.className === 'class-1 class-2 class-4', 'Can switch classes on or off and set multiple classes');
            // A negative switch is follewed by a - or a 0 before the first colon.
            const comp16a = new Api_1.BoundComponent(basicViewModel, '<div id="comp16a" i5_switch0_class-3="trumpiness" i5_switch-:class-4="trumpiness" i5_switch-:class-5="truthiness">Hello World</div>').appendToParent(this.testArea);
            Api_1.assert(comp16a.className === 'class-3 class-4', 'Negative switches reverse switch logic');
            // i5_if can be used to make a component element visible or invisible, using display: none.
            const comp17a = new Api_1.BoundComponent(basicViewModel, '<div id="comp17a" i5_if="truthiness">Hello World</div>').appendToParent(this.testArea);
            const comp17b = new Api_1.BoundComponent(basicViewModel, '<div id="comp17b" i5_if="trumpiness">Hello World</div>').appendToParent(this.testArea);
            Api_1.assert(comp17a.style.display === '', 'i5_if is true, element is displayed');
            Api_1.assert(comp17b.style.display === 'none', 'i5_if is false, element is not displayed');
            // If i5_if is switched off and then on, the original value of display is restored.
            // This is needed because, aside from using classes (which are probably a MUCH better solution),
            // there is no simple 'not-display-none' style, but instead a host of values for the display property.
            // We haven't tested observables yet so this test will toggle manually.
            const comp17c = new Api_1.BoundComponent(basicViewModel, '<input id="comp17c" i5_style="block" value="Hello World"/>').appendToParent(this.testArea);
            comp17c.setVisibility('trumpiness');
            comp17c.setVisibility('truthiness');
            Api_1.assert(comp17c.style.display === 'block', 'i5_if is true, element display property is restored');
            // The most common piece of event-based functionality is writing to a variable. In most cases, this
            // triggers an input event. According to the HTML5 specification, the input event is triggered
            // on any input, select, or textarea, but real life browsers may vary. For example, in Edge,
            // the input event isn't supported through most of its history.
            // Use the built-in attribute i5_target="propertyName" to indicate what properties the built-in
            // write method should set. If propertyName indicates a method, then that method is called
            // with the value.
            // The following mean the same thing:
            const comp18a = new Api_1.BoundComponent(basicViewModel, '<input id="comp18a" style="display: block;" i5_input i5_target="writable"/>').appendToParent(this.testArea);
            // Shortcut combining the event and the target
            const comp18b = new Api_1.BoundComponent(basicViewModel, '<input id="comp18b" style="display: block;" i5_input="writable"/>').appendToParent(this.testArea);
            comp18a.value = 'First test';
            comp18a.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'First test', 'Input works');
            comp18b.value = 'Second test';
            comp18b.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Second test', 'Input shortcut can take target as an argument');
            // The property 'writable' can be replaced by a method call
            const comp18c = new Api_1.BoundComponent(basicViewModel, '<input id="comp18c" style="display: block;" i5_input="writerMethod"/>').appendToParent(this.testArea);
            const comp18d = new Api_1.BoundComponent((x) => basicViewModel.writerMethod(x), '<input id="comp18d" style="display: block;" i5_input="."/>').appendToParent(this.testArea);
            comp18c.value = 'Fourth test';
            comp18c.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Fourth test', 'Write method can call methods');
            comp18d.value = 'Fifth test';
            comp18d.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Fifth test', 'Write method can call functions');
            // Often you want to set both the input and the value to the same thing.
            // You can use i5_input_value="foo" as a shortcut for i5_input="foo" and i5_value="foo"
            const comp18e = new Api_1.BoundComponent(basicViewModel, '<input id="comp18e" style="display: block;" i5_input_value="writable"/>').appendToParent(this.testArea);
            Api_1.assert(comp18e.value === 'Fifth test', 'i5_input_value sets value before');
            comp18e.value = 'Sixth test';
            comp18e.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Sixth test', 'i5_input still works');
            Api_1.assert(comp18e.value === 'Sixth test', 'i5_input_value sets value after');
            // The i5_target attribute can be replicated to write to multiple targets.
            // Everything after the "target", so i5_target1, i5_targetwhatever are valid.
            const comp19 = new Api_1.BoundComponent(basicViewModel, '<input id="comp19" style="display: block;" i5_input i5_target1="writable" i5_target2="writable2" />').appendToParent(this.testArea);
            comp19.value = 'Sixth test';
            comp19.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Sixth test' && basicViewModel.writable2 === 'Sixth test', 'Write method can write to multiple targets');
            // The basic loop, calling the built-in method BoundComponent.loopPostProcess.
            // Without any injection of loop item components (which I will get to shortly), the default loopPostProcess method does nothing.
            // I will need to detour into injection to go over the default post process method.
            const comp20a = new Api_1.BoundComponent(['One', 'Two', 'Three'], '<div id="comp20a" i5_loop=".">Random <span>span content</span>. </div>').appendToParent(this.testArea);
            const comp20b = new Api_1.BoundComponent(basicViewModel, '<div id="comp20b" i5_loop="list">Random <span>span content</span>. </div>').appendToParent(this.testArea);
            Api_1.assert(comp20a.content.querySelectorAll('span').length === 3, "Inner loop content should be replicated");
            Api_1.assert(comp20b.content.querySelectorAll('span').length === 2, "Inner loop content should be replicated");
            let loopcalled21a = 0;
            // To do your own logic, override the method loopPostProcess. loopPostProcess() is called once for each row in the iterable.
            class LoopComponent1 extends Api_1.BoundComponent {
                loopPostProcess(row, addedContent, allRows, previousContent) {
                    loopcalled21a++; // simple counter
                    Api_1.nodeListSelector(addedContent, 'span').innerHTML = row; // fill first span in the added content with current value
                    const rows = Array.from(allRows);
                    // If the last item in the iterable, add a period. This logic depends on the items being unique.
                    if (rows.indexOf(row) === rows.length - 1) {
                        Api_1.nodeListSelectorAll(addedContent, 'span')[1].innerHTML = '.';
                    }
                }
            }
            const comp21a = new LoopComponent1(['One', 'Two', 'Three'], '<div id="comp21a" i5_loop=".">A <span>span content</span><span>,</span> </div>').appendToParent(this.testArea);
            Api_1.assert(loopcalled21a === 3, 'Manual loop was called once per row');
            Api_1.assert(comp21a.innerHTML === "A <span>One</span><span>,</span> A <span>Two</span><span>,</span> A <span>Three</span><span>.</span> ", 'Manual loop should get the correct inputs and be able to modify the output.');
            // But even though that's possible, doing everything manually isn't ideal.
            // What would be ideal is if there were a way to componentize each item, doing replacements, etc.
            // DETOUR AHEAD
            // So now we make a detour into injection, because the default way to include variation in
            // the loop is by making them a component, by injecting component code.
            // By default, the existing element is kept and converted into a component.
            this.testArea.appendChild(Api_1.div(`<div>Down in here is a component:
                <div ichigo id="inject01a">Hello <i-v>name</i-v> #1</div>
                <div ichigo i5_style="bold">Hello <i-v>name</i-v> #2</div>
            </div>`));
            const firstInject = document.getElementById('inject01a');
            // This is the same as calling inject(viewmodel, '[ichigo]');
            const injected = Api_1.BoundComponent.inject(Api_1.kw('viewModel', basicViewModel));
            Api_1.assert(injected[0].innerHTML === 'Hello <i-v>World</i-v> #1', 'Inject should replace first.');
            Api_1.assert(injected[0].content === firstInject, 'Inject with keep=true should keep the existing element in place.');
            Api_1.assert(injected[1].innerHTML === 'Hello <i-v>World</i-v> #2', 'Inject should replace second.');
            // Using the default selector of [ichigo] is probably not a good idea, because it doesn't allow multiple
            // components ... or multiple tests. Let me clean up.
            function injectClean() {
                for (const e of document.querySelectorAll('[ichigo]')) {
                    e.removeAttribute('ichigo');
                }
            }
            injectClean();
            // The strength of the inject method, however, isn't as a shortcut for the regular constructor.
            // It's as a way to replace custom tags.
            this.testArea.appendChild(Api_1.div(`
                <inject-test-2 id="inject02a">Hello <i-v>name</i-v> #1</inject-test-2>
                <inject-test-2 i5_style="bold">Hello <i-v>name</i-v> #2</inject-test-2>
                <inject-test-3 id="inject02b">Hello <i-v>name</i-v> #3 </inject-test-3>
                <inject-test-3>Hello <i-v>name</i-v> #4 </inject-test-3>
                <div ichigo id="eraseMe" i5_style="bold">Something <i-v>to be replaced</i-v></div>
                <div id="id04d">Also <i-v>to be replaced</i-v></div>
            `));
            const injected2 = Api_1.BoundComponent.inject('inject-test-2', { replace: true }, Api_1.kw('viewModel', basicViewModel));
            const injected2b = Api_1.BoundComponent.inject('inject-test-3', { type: 'span', replace: true }, Api_1.kw('viewModel', basicViewModel));
            Api_1.assert(injected2[0].content.tagName === 'DIV' && injected2b[0].content.tagName === 'SPAN', 'Elements (including custom tags) are replaced when replace is true');
            Api_1.assert(injected2[1].style.cssText === 'font-weight: bold;', 'Existing attributes are kept even when replace is true and are attribute template logic is applied');
            const injected2c = Api_1.BoundComponent.inject('[ichigo]', { outerHtml: '<span i5_style="bold">The new <i-v>name</i-v></span>', id: 'inject02c', replace: true }, Api_1.kw('viewModel', basicViewModel));
            Api_1.assert(injected2c[0].innerHTML === 'The new <i-v>World</i-v>', 'When OuterHtml passed, the current innerHTML of the element is discarded');
            Api_1.assert(injected2c[0].id === 'inject02c', 'OuterHtml options also work with injection');
            Api_1.assert(injected2c[0].content.tagName === 'SPAN', 'OuterHtml inject still works without using custom tags');
            Api_1.assert(injected2c[0].style.cssText === 'font-weight: bold;', 'OuterHtml inject keeps existing attributes if not overridden');
            const injected2d = Api_1.BoundComponent.inject('#id04d', '<span id="inject02d" i5_style="bold">Also the new <i-v>name</i-v></span>', Api_1.kw('viewModel', basicViewModel));
            Api_1.assert(injected2d[0].id === 'inject02d' && injected2d[0].innerHTML === 'Also the new <i-v>World</i-v>', 'OuterHtml replace shortcut also works');
            injectClean();
            // When selector is a string, the elements are picked up using document.querySelectorAll().
            // If you are re-using selectors, this will pick up stuff you don't want to use.
            // Feel free to do your own query and pass in the results, or simply an array of elements to replace.
            this.testArea.appendChild(Api_1.div(`
                <div class="inject-selector-1">Hello <i-v>name</i-v> #1</div>
                <div class="inject-selector-1">Hello <i-v>name</i-v> #2</div>
            `, { id: 'inject03a' }));
            this.testArea.appendChild(Api_1.div(`<div class="inject-selector-1">Hello <i-v>.</i-v> #3</div>`, { id: 'inject03b' }));
            this.testArea.appendChild(Api_1.div('Hello <i-v>.</i-v> #4', { id: 'inject03c' }));
            const injected3 = Api_1.BoundComponent.inject(document.getElementById('inject03a').querySelectorAll('.inject-selector-1'), Api_1.kw('viewModel', basicViewModel));
            const injected3b = Api_1.BoundComponent.inject(document.getElementById('inject03b').querySelectorAll('.inject-selector-1'), Api_1.kw('viewModel', "Sekai"));
            const injected3c = Api_1.BoundComponent.inject(document.getElementById('inject03c'), Api_1.kw('viewModel', "WARUDO"));
            Api_1.assert(injected3[0].content.querySelector('i-v').innerHTML === 'World' && injected3b[0].content.querySelector('i-v').innerHTML === 'Sekai', 'Injection applied to NodeList when passed');
            Api_1.assert(injected3c[0].content.querySelector('i-v').innerHTML === 'WARUDO', 'Injection applied to single element when passed');
            // The final piece of the injection recipe is what component is injected.
            // Most of these tests are using the default BoundComponent class, but in the wild,
            // this will most commonly be the relevant view class, such as OrderView or BlogEntryView.
            this.testArea.appendChild(Api_1.div(`
                <inject-test-4>Hello <i-v>name</i-v></inject-test-4>
                <inject-test-5>Hello <i-v>name</i-v></inject-test-5>
            `));
            class InjectTestComponent extends Api_1.BoundComponent {
                constructor(vm, args) {
                    const tmp = Object.assign({}, vm, { name: 'Derived Class' }); // Change name
                    super(tmp, args);
                }
            }
            // These are both ways to do the same thing
            const injected4 = InjectTestComponent.inject('inject-test-4', { replace: true }, Api_1.kw('viewModel', basicViewModel));
            const injected4b = Api_1.BoundComponent.inject('inject-test-5', { replace: true }, InjectTestComponent, Api_1.kw('viewModel', basicViewModel));
            Api_1.assert(injected4[0].innerHTML === 'Hello <i-v>Derived Class</i-v>' && injected4b[0].innerHTML === 'Hello <i-v>Derived Class</i-v>', 'Can replace component class in inject()');
            // END DETOUR
            // And now that we understand injection, we can finally handle loop items using the default looper.
            // This uses the default BoundComponent for the top-level, using a string[] viewModel, and the same class for the
            // item-level, using a string viewModel (not validated by TypeScript).
            const comp22 = new Api_1.BoundComponent(['One', 'Two', 'Three'], `<div id="comp22" i5_loop="."><span><i-v>.</i-v> </span></div>`).appendToParent(this.testArea);
            Api_1.assert(comp22.innerHTML === '<span iv_bound_component=""><i-v>One</i-v> </span><span iv_bound_component=""><i-v>Two</i-v> </span><span iv_bound_component=""><i-v>Three</i-v> </span>', 'BoundComponent template processed each line individually');
            // Now test the ^ (parent) data source.
            const comp22a = new Api_1.BoundComponent({ parentProperty: 'out of Three', iter: ['One', 'Two', 'Three'] }, `<div id="comp22a" i5_loop="iter"><span><i-v>.</i-v> <i-v>^parentProperty</i-v> </span></div>`).appendToParent(this.testArea);
            Api_1.assert(comp22a.innerHTML === '<span iv_bound_component=""><i-v>One</i-v> <i-v>out of Three</i-v> </span><span iv_bound_component=""><i-v>Two</i-v> <i-v>out of Three</i-v> </span><span iv_bound_component=""><i-v>Three</i-v> <i-v>out of Three</i-v> </span>', 'BoundComponent loop contains reference to parent viewModel when referenced by ^');
            // The i-v :source property lets you grab data from any boundComponent on the page, referenced by id
            const comp22b1 = new Api_1.BoundComponent("out of Three", { id: "comp22b1", type: "span" }).appendToParent(this.testArea);
            const comp22b = new Api_1.BoundComponent(['One', 'Two', 'Three'], `<div id="comp22b" i5_loop="."><span><i-v>.</i-v> <i-v :source="comp22b1">.</i-v> </span></div>`).appendToParent(this.testArea);
            Api_1.assert(comp22b.innerHTML === '<span iv_bound_component=""><i-v>One</i-v> <i-v :source="comp22b1">out of Three</i-v> </span><span iv_bound_component=""><i-v>Two</i-v> <i-v :source="comp22b1">out of Three</i-v> </span><span iv_bound_component=""><i-v>Three</i-v> <i-v :source="comp22b1">out of Three</i-v> </span>', 'Data fetched from other component when referenced by :source');
            // The :source property also works for other custom attributes that are used to render the data (all but write targets)
            const comp22c = new Api_1.BoundComponent({ passFail: "PASSED", falsy: false, style: "text-decoration:underline;" }, { id: "comp22c", type: "span" }).appendToParent(this.testArea);
            const comp22d = new Api_1.BoundComponent({ passFail: "FAILED", falsy: true }, {
                type: "input",
                attributes: {
                    i5_source: "comp22c",
                    i5_attr_attributecheck: "passFail",
                    i5_value: "passFail",
                    i5_class: "passFail",
                    i5_style: "style"
                }
            }).appendToParent(this.testArea);
            Api_1.assert(comp22d.content.getAttribute('attributecheck') === "PASSED", "Other component can be used as source for :attr:value");
            Api_1.assert(comp22d.content.value === "PASSED", "Other component can be used as source for :value");
            Api_1.assert(comp22d.content.className === "PASSED", "Other component can be used as source for :class");
            Api_1.assert(comp22d.content.style.textDecoration === "underline", "Other component can be used as source for :style");
            const comp22e = new Api_1.BoundComponent({ passFail: "FAILED", falsy: true }, {
                type: "div",
                id: "comp22e",
                properties: {
                    innerHTML: '<div><i-v #comp22e>.</i-v></div>',
                },
                attributes: {
                    i5_source: "comp22c",
                    i5_switch0_passed: "falsy",
                    i5_if: "falsy",
                    i5_loop: "passFail"
                }
            }).appendToParent(this.testArea);
            Api_1.assert(comp22e.content.className === "passed", "Other component can be used as source for :switch:class");
            Api_1.assert(comp22e.content.style.display === "none", "Other component can be used as source for :if");
            Api_1.assert(Array.from(comp22e.content.querySelectorAll("div")).length === 6 && comp22e.content.querySelector("div").innerText === "P", "Other component can be used as soruce for :loop");
            // Of course, the component can be any class that inherits BoundComponent
            class LoopComponent2 extends Api_1.BoundComponent {
            }
            const comp23a = new Api_1.BoundComponent(['One', 'Two', 'Three'], {
                outerHtml: `<div id="comp23a" i5_loop="."><span><i-v>.</i-v> </span></div>`
            }).appendToParent(this.testArea);
            Api_1.assert(comp23a.content.querySelector('span').innerHTML === '<i-v>One</i-v> ', 'Successfully use derived class');
            // In these cases, when you have a view class for the top-level component, you probably
            // don't want to use the default BoundComponent class for the loop items. Set the loopItemClass to
            // indicate a class to use (of course, if you don't use the default looper, you can do whatever).
            // The important point in some contexts is that the parent component is passed on options.parent.
            // Use it in the occasional case where a child needs to know its parent.
            // If you want to have different components for different children (for example, a title component followed by
            // an image component), either encapsulate them in a parent component or don't use the default class/loop.
            // When the content is looped, before render() is called, the innerHTML is blank. It would be possible to keep the
            // template content, but in the case of an async component, that would create a flash of unprocessed content. The way
            // it's being done here, it goes from blank to having data. Much cleaner.
            // WARNING: By default, render() (which contains the loopPostProcess() call) is called in the constructor of BoundComponent.
            // If your child component depends on logic set up in the initialization of the parent component, this will produce bugs.
            // Lifecycle: Main CTOR() => Main super() => Main render() => Loop inject => Item CTOR() => Item CTOR end => Main super end => Main CTOR body (TypeScript field initialization) => Main CTOR end
            // As you can see from the lifecycle, any logic in the item CTOR is called before Main CTOR body.
            // It can be fixed in two ways. One is to set async: true in the options, creating an async component.
            // The second is to set defer: true and call render() manually when appropriate.
            // Currently neither of these is default.
            let loopcounter23b = 0;
            class LoopComponent3 extends Api_1.BoundComponent {
                constructor(vm, options) {
                    super(vm, options);
                    // Not deferred or async, so if this referenced the parent component, the loopcounter field would be undefined.
                    this.index = loopcounter23b++;
                    this.content.dataset.id = this.index.toString();
                }
            }
            const comp23b = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp23b" i5_loop="."><span><i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent3,
                async: false // Not using async render because it makes testing suck (this is default)
            })).appendToParent(this.testArea);
            Api_1.assert(comp23b.content.querySelector('span:nth-child(2)').dataset.id === '1', 'Successfully call constructor of derived class');
            loopcounter23b = 0;
            const comp23c = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp23c" i5_loop="."><span><i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent3,
                defer: true
            })).appendToParent(this.testArea);
            Api_1.assert(comp23c.innerHTML === '', "Defer true prevents calling of the render() method");
            comp23c.render();
            Api_1.assert(comp23c.innerHTML === comp23b.innerHTML, "Render can be called at any time after, even outside the derived constructor");
            // If you want to do nothing after creation, the easiest way is to supply an empty method, as in the example i5_loop:null="."
            const comp24 = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp24" i5_loop:null="."><span><i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent3
            })).appendToParent(this.testArea);
            Api_1.assert(comp24.innerHTML === '<span><i-v>.</i-v> </span><span><i-v>.</i-v> </span><span><i-v>.</i-v> </span>', 'Null loop handler does not inject any component');
            // At this time, I decided to add a way to access properties of the view, rather than the viewModel, by
            // prefixing them with "this." This would need to be in a derived class, because none of the methods
            // base class are applicable.
            // WARNING: Normally, render() is called in the constructor of BoundComponent. In the super() call of your class.
            // This will cause problems in most cases where properties are accessed. To handle this, using this.properties
            // triggers automatic { defer: true } behavior.
            // To handle it, you can set async to true or you can call render() at the end of the constructor.
            class LoopComponent4 extends Api_1.BoundComponent {
                constructor(vm, options) {
                    super(vm, options);
                    this.index = 0;
                    // If you look at the JS that TS generates, you'll see that this.index = 0 isn't called until after super().
                    // In render() (called in super()), index is undefined.
                    this.index = options.loopParent.viewModel.indexOf(vm);
                }
            }
            const comp25a = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp25a" i5_loop="."><span i5_attr:data-id="this.index"><i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent4
            })).appendToParent(this.testArea);
            Api_1.assert(comp25a.innerHTML === '<span i5_attr:data-id="this.index" iv_loop_component4=""><i-v>.</i-v> </span><span i5_attr:data-id="this.index" iv_loop_component4=""><i-v>.</i-v> </span><span i5_attr:data-id="this.index" iv_loop_component4=""><i-v>.</i-v> </span>', 'Render() not called automatically when "this." used.');
            // You can use fields without difficulty if async is true
            const comp25b = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp25b" i5_loop="."><span i5_attr:data-id="this.index"><i-v>this.index</i-v>: <i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent4,
                async: true
            })).appendToParent(this.testArea);
            // This is why I hate testing with async. Throw a debugger in and this will fail:
            this.log('Async test initated for 25b.');
            asyncAsserts.then(() => Api_1.assert(document.querySelector('#comp25b span:nth-child(2)').dataset.id === '1', 'this.index can be accessed asynchronously'));
            // If you want to do a synchronous call, do it this way.
            class LoopComponent5 extends LoopComponent4 {
                constructor(vm, options) {
                    super(vm, options);
                    this.render(); // Now it's safe to call render.
                }
            }
            const comp25c = new LoopComponent2(['One', 'Two', 'Three'], new Api_1.OuterHtmlBindingOptions({
                outerHtml: `<div id="comp25c" i5_loop="."><span i5_attr:data-id="this.index"><i-v>this.index</i-v>: <i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent5
            })).appendToParent(this.testArea);
            Api_1.assert(document.querySelector('#comp25c span:nth-child(2)').dataset.id === '1', 'this.index can be accessed if render() called in constructor');
            // I warned you against having replacement values that return other components, because the process of refreshing the data
            // (if an observable is in play) will delete your references. And the timing can be tricky.
            // That said, there should be no issues with nesting a component inside  (the static portion of) another component. Don't
            // loop, because loops are all dynamic.
            // But there will be issues without additional work.
            // In the following example, you'll see that without filtering i-v tags, the replacement in comp-2 will want to print
            // [Object object]. Which will break comp-2's replacement.
            // But by setting the name and matching it up in the "component" property of the i-v tags, the replacements are filtered to
            // only certain components.
            this.testArea.appendChild(Api_1.div(`
                <comp-1>
                    Hello <i-v #comp26a>name</i-v>
                    <comp-2>This is <i-v #comp26b>.</i-v></comp-2>
                </comp-1>
            `));
            const comp26a = Api_1.BoundComponent.inject('comp-1', { replace: true, type: Api_1.elementType.HTMLDivElement, id: 'comp26a' }, Api_1.kw('viewModel', basicViewModel));
            // You can set name by attribute iv_name or by name option.
            const comp26b = Api_1.BoundComponent.inject('comp-2', { replace: true, type: Api_1.elementType.HTMLDivElement, id: 'comp26b' }, Api_1.kw('viewModel', 'nested'));
            Api_1.assert(comp26a[0].innerHTML.includes('Hello <i-v #comp26a="">World</i-v>'), 'I-V tags are replaced based on their assigned components');
            Api_1.assert(comp26a[0].innerHTML.includes('<div id="comp26b" iv_bound_component="">This is <i-v #comp26b="">nested</i-v></div>'), 'I-V tags are restricted to their assigned components');
            this.testArea.appendChild(Api_1.div(`
                <comp-1>
                    Hello <i-v>name</i-v>
                    <comp-2>This is <i-v component="comp26d">.</i-v></comp-2>
                </comp-1>
            `));
            // This is pretty risky because i-v has no reference so I don't recommend being lazy like this.
            const comp26c = Api_1.BoundComponent.inject('comp-1', { replace: true, type: Api_1.elementType.HTMLDivElement, id: 'comp26c' }, Api_1.kw('viewModel', basicViewModel));
            const comp26d = Api_1.BoundComponent.inject('comp-2', { replace: true, type: Api_1.elementType.HTMLDivElement, id: 'comp26d' }, Api_1.kw('viewModel', 'nested'));
            Api_1.assert(comp26c[0].innerHTML.includes('Hello <i-v>World</i-v>'), 'Non-scoped I-V tags match first component requested');
            Api_1.assert(comp26c[0].innerHTML.includes('<div id="comp26d" iv_bound_component="">This is <i-v component="comp26d">nested</i-v></div>'), 'I-V tags are replaced based on their assigned components when bound using full syntax');
            // SHORTCUTS
            // To make things quicker, there is a shortcut for the "i5_" prefix on custom attributes: :
            // This makes :attr, :value, :loop, and so forth.
            // : is completely non-standard but it is legal in attribute names.
            const short1 = new Api_1.BoundComponent(basicViewModel, '<div :class="cssClass">Shortcut</div>').appendToParent(this.testArea);
            Api_1.assert(short1.classList.toString() === 'does-nothing', ':class shortcut for i5_class');
            const short2 = new Api_1.BoundComponent(basicViewModel, '<span :style="block">Shortcut</span>').appendToParent(this.testArea);
            Api_1.assert(short2.style.display === 'block', ':style shortcut for i5_style');
            const short3 = new Api_1.BoundComponent(basicViewModel, '<div :text="rawHtml"></div>').appendToParent(this.testArea);
            Api_1.assert(short3.innerHTML === '<i-v>Hello &lt;em&gt;World&lt;/em&gt;</i-v>', ":text shortcut for i5_text");
            const short4 = new Api_1.BoundComponent(basicViewModel, '<div :html="rawHtml"></div>').appendToParent(this.testArea);
            Api_1.assert(short4.content.firstElementChild.innerHTML === 'Hello <em>World</em>', ":html shortcut for i5_html");
            const short5 = new Api_1.BoundComponent(basicViewModel, '<input :style="block" :value="name" />').appendToParent(this.testArea);
            Api_1.assert(short5.value === 'World', ':value shortcut for i5_value');
            const short6 = new Api_1.BoundComponent(basicViewModel, '<input :style="block" :value="name" :attr:disabled="truthiness" />').appendToParent(this.testArea);
            Api_1.assert(short6.content.hasAttribute('disabled'), ':attr shortcut for i5_attr');
            const short7 = new Api_1.BoundComponent(basicViewModel, '<div :if="truthiness">Shortcut seen</div>').appendToParent(this.testArea);
            const short8 = new Api_1.BoundComponent(basicViewModel, '<div :if="trumpiness">Shortcut not seen</div>').appendToParent(this.testArea);
            const short9 = new Api_1.BoundComponent(basicViewModel, '<div :if-="truthiness">Shortcut not seen</div>').appendToParent(this.testArea);
            Api_1.assert(short7.style.display === '', ':if shortcut for i5_if');
            Api_1.assert(short8.style.display === 'none', ':if shortcut for i5_if');
            Api_1.assert(short9.style.display === 'none', ':if- shortcut for i5_if0');
            const short10 = new Api_1.BoundComponent(basicViewModel, '<input :style="block" :input="writable" />').appendToParent(this.testArea);
            short10.value = 'Shortcut 10';
            short10.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Shortcut 10', ':input shortcut for i5_input');
            const short11 = new Api_1.BoundComponent(basicViewModel, '<input :style="block" :input :target1="writable" :target2="writable2" />').appendToParent(this.testArea);
            short11.value = 'Shortcut 11';
            short11.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Shortcut 11' && basicViewModel.writable2 === 'Shortcut 11', ':target shortcut can handle multiple targets');
            // The shortcut for i5_input_value is :input: (:input_value will still work but it's still wordy)
            const short12 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block;" :input:="writable" />').appendToParent(this.testArea);
            Api_1.assert(short12.value === 'Shortcut 11', ':input: before');
            short12.value = 'Shortcut 12';
            short12.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(short12.value === 'Shortcut 12', ':input: after');
            // You can shortcut loops
            const short13 = new Api_1.BoundComponent(['Short', 'Shorter', 'Shortest'], `<div :loop="."><span><i-v>.</i-v></span></div>`).appendToParent(this.testArea);
            // The : shortcut is only intended to replace custom component attributes.
            const short14 = new Api_1.BoundComponent(['Short', 'Shorter', 'Shortest'], `<div :loop="."><span><i-v>.</i-v></span></div>`).appendToParent(this.testArea);
            // Ichigo makes heavy use of custom attributes, and purists might refuse to use it because all the attributes are
            // technically invalid, not even considering the shortcut character.
            // To make them happy, Ichigo can also be configured using data attributes, which are valid. It didn't take a lot of code.
            const dataset1 = new Api_1.BoundComponent(basicViewModel, '<div data-i5_class="cssClass">Shortcut</div>').appendToParent(this.testArea);
            Api_1.assert(dataset1.classList.toString() === 'does-nothing', 'i5_class in dataset');
            const dataset2 = new Api_1.BoundComponent(basicViewModel, '<span data-i5_style="block">Shortcut</span>').appendToParent(this.testArea);
            Api_1.assert(dataset2.style.display === 'block', 'i5_style in dataset');
            const dataset3 = new Api_1.BoundComponent(basicViewModel, '<div data-i5_text="rawHtml"></div>').appendToParent(this.testArea);
            Api_1.assert(dataset3.innerHTML === '<i-v>Hello &lt;em&gt;World&lt;/em&gt;</i-v>', "i5_text in dataset");
            const dataset4 = new Api_1.BoundComponent(basicViewModel, '<div data-i5_html="rawHtml"></div>').appendToParent(this.testArea);
            Api_1.assert(dataset4.content.firstElementChild.innerHTML === 'Hello <em>World</em>', "i5_html in dataset");
            const dataset5 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block" data-i5_value="name" />').appendToParent(this.testArea);
            Api_1.assert(dataset5.value === 'World', 'i5_value in dataset');
            const dataset6 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block" data-i5_value="name" data-i5_attr_disabled="truthiness" />').appendToParent(this.testArea);
            Api_1.assert(dataset6.content.hasAttribute('disabled'), 'i5_attr in dataset');
            const dataset7 = new Api_1.BoundComponent(basicViewModel, '<div data-i5_if="truthiness">Shortcut seen</div>').appendToParent(this.testArea);
            const dataset8 = new Api_1.BoundComponent(basicViewModel, '<div data-i5_if="trumpiness">Shortcut not seen</div>').appendToParent(this.testArea);
            Api_1.assert(dataset7.style.display === '', 'i5_if in dataset');
            Api_1.assert(dataset8.style.display === 'none', 'i5_if in dataset');
            const dataset9 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block" data-i5_input="writable" />').appendToParent(this.testArea);
            dataset9.value = 'Dataset 9';
            dataset9.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Dataset 9', 'i5_input in dataset');
            const dataset10 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block" data-i5_input data-i5_target1="writable" data-i5_target2="writable2" />').appendToParent(this.testArea);
            dataset10.value = 'Dataset 10';
            dataset10.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable === 'Dataset 10' && basicViewModel.writable2 === 'Dataset 10', 'data-i5_target shortcut can handle multiple targets');
            const dataset11 = new Api_1.BoundComponent(basicViewModel, '<input style="display: block;" data-i5_input_value="writable"/>').appendToParent(this.testArea);
            Api_1.assert(dataset11.value === 'Dataset 10', 'data-i5_input_value before');
            dataset11.value = 'Dataset 11';
            dataset11.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(dataset11.value === 'Dataset 11', 'data-i5_input_value after');
            const dataset12 = new Api_1.BoundComponent(['Short', 'Shorter', 'Shortest'], `<div data-i5_loop="."><span><i-v>.</i-v></span></div>`).appendToParent(this.testArea);
            // Again, some extra complexity for the sake of consistency.
            const dataset13 = new Api_1.BoundComponent(['Short', 'Shorter', 'Shortest'], `<div data-i5_loop="."><span><i-v>.</i-v></span></div>`).appendToParent(this.testArea);
            // If you subscribe the render() method of the component to an observable's changes,
            // then when the data is modified, the rendering of that data will be updated.
            // Remember that by default, observables work asynchronously.
            // If the view model is an observable, you can observe it simply by
            // passing observeViewModel: true in the component options.
            class ObservableViewModel extends Api_1.ObservableBase {
                constructor() {
                    super(...arguments);
                    this.name = new Api_1.ObservableProperty("World", { name: "name", forwardTo: this });
                }
            }
            const observableViewModel = new ObservableViewModel({ name: "VM" });
            const observeComp1 = new Api_1.BoundComponent(observableViewModel, {
                innerHtml: 'Hello <i-v>name</i-v>',
                observeViewModel: true
            }).appendToParent(this.testArea);
            Api_1.assert(observeComp1.innerHTML === 'Hello <i-v>World</i-v>', 'Component shows initial value before update');
            setTimeout(() => {
                observableViewModel.name.value = "Neptune";
            }, 500);
            asyncAsserts.then(() => Api_1.assert(observeComp1.innerHTML === 'Hello <i-v>Neptune</i-v>', 'Render() called when observing viewModel, if property is forwarded.'));
            // You can also observe each individual property of a view model, which is useful when the VM itself is a dumb object. Which
            // is generally better, in my opinion. Simpler chain of responsibility.
            class MoreTypicalViewModel {
                constructor() {
                    this.name = new Api_1.ObservableProperty("World");
                }
            }
            const dumbViewModel = new MoreTypicalViewModel();
            const observeComp2 = new Api_1.BoundComponent(dumbViewModel, {
                innerHtml: 'Hello <i-v>name</i-v>',
                observeAllViewModel: true
            }).appendToParent(this.testArea);
            Api_1.assert(observeComp2.innerHTML === 'Hello <i-v>World</i-v>', 'Component shows initial value before update #2');
            setTimeout(() => {
                dumbViewModel.name.value = "Mars";
            }, 600);
            asyncAsserts.then(() => Api_1.assert(observeComp2.innerHTML === 'Hello <i-v>Mars</i-v>', 'Render() called when observing all observable properties of a dumb view model'));
            // Of course, you can manually specify the observers (same as observeViewModel).
            const observeComp3 = new Api_1.BoundComponent(dumbViewModel, {
                innerHtml: 'Hello <i-v>name</i-v> #2',
                observeTargets: [dumbViewModel.name]
            }).appendToParent(this.testArea);
            asyncAsserts.then(() => Api_1.assert(observeComp3.innerHTML === 'Hello <i-v>Mars</i-v> #2', 'Render() called when observing observable properties on a dumb view model explicitly'));
            // Or manually specify the parent of observers (same as observeAllViewModel)
            const observeComp4 = new Api_1.BoundComponent(dumbViewModel, {
                innerHtml: 'Hello <i-v>name</i-v> #3',
                observeAllTargets: [dumbViewModel]
            }).appendToParent(this.testArea);
            asyncAsserts.then(() => Api_1.assert(observeComp4.innerHTML === 'Hello <i-v>Mars</i-v> #3', 'Render() called when observing all observable properties of a list of dumb view models'));
            // Or if complete manual assignment is your thing, you don't need to use the helpers.
            const observeComp5 = new Api_1.BoundComponent(observableViewModel, {
                innerHtml: 'Hello <i-v>name</i-v> #2'
            }).appendToParent(this.testArea);
            // This is the same as calling
            // observeComp5.viewModel.subscribe(observeComp5.render, observeComp5)
            observeComp5.observe();
            asyncAsserts.then(() => Api_1.assert(observeComp5.innerHTML === 'Hello <i-v>Neptune</i-v> #2', 'Render() called when the observe() method is called'));
            const observeComp6 = new Api_1.BoundComponent(dumbViewModel, {
                innerHtml: 'Hello <i-v>name</i-v> #4'
            }).appendToParent(this.testArea);
            // This is the same as calling
            // observeComp6.viewModel.subscribe(observeComp5.render, observeComp5.name)
            observeComp6.observeAll();
            asyncAsserts.then(() => Api_1.assert(observeComp6.innerHTML === 'Hello <i-v>Mars</i-v> #4', 'Render() called when the observeAll() method is called'));
            // The VM doesn't matter as long as it's observable. The process is the same for an array.
            // In this case, the array is the view model, so pass observeViewModel to true.
            const observableArr = Api_1.ObservableProxy.proximate(['One', 'Two']);
            const observeComp7 = new Api_1.BoundComponent(observableArr, {
                outerHtml: `<div :loop="."><span class="observing"><i-v>.</i-v> </span></div>`,
                observeViewModel: true
            }).appendToParent(this.testArea);
            Api_1.assert(Array.from(observeComp7.content.querySelectorAll('.observing')).length === 2, 'Array length before updating.');
            observableArr.push('Three');
            asyncAsserts.then(() => Api_1.assert(Array.from(observeComp7.content.querySelectorAll('.observing')).length === 3, 'Array length after updating.'))
                .then(() => Api_1.assert(Array.from(observeComp7.content.querySelectorAll('.observing i-v')).pop().innerHTML === 'Three', 'Last item is the most recent array addition'));
            // Each of the attribute-defined properties in the bound components can be set through fluent methods. You probably wouldn't
            // use this for everything (why use an bound component with no attributes?) but from time to time it's useful.
            const fluency = new Api_1.BoundComponent(basicViewModel, { innerHtml: 'Hellooo, <i-v>name</i-v>' }).appendToParent(this.testArea);
            // Set the update parameter to true on the last change to re-render the component.
            // This is only done when you call it so the number of redraws is minimized.
            fluency.setCssClass('cssClass');
            Api_1.assert(fluency.className === '', 'Simon didnt say (update not true)');
            fluency.addAttributeMapping('bogus', 'cssClass', true);
            Api_1.assert(fluency.className === 'does-nothing', 'Update called forces re-render');
            Api_1.assert(fluency.content.getAttribute('bogus') === 'does-nothing', 'Update called forces a complete re-render');
            // Or call .render() at the end. It's a fluent API.
            fluency.removeAttributeMapping('bogus').setLoop('list', '<div :text="."></div>').render();
            Api_1.assert(fluency.innerHTML === '<div :text="." iv_bound_component=""><i-v>World</i-v></div><div :text="." iv_bound_component=""><i-v>Underworld</i-v></div>', 'setLoop() replaces content with the provided loop');
            // All these are setting render to true so the output is visible in the test area, but they don't need to be.
            fluency.setVisibility('trumpiness', false, true);
            Api_1.assert(fluency.content.style.display === 'none', 'setVisibility() hides');
            fluency.setVisibility('truthiness', false, true);
            Api_1.assert(fluency.content.style.display === '', 'setVisibility() shows');
            fluency.addAttributeMapping('style', 'bold', true);
            Api_1.assert(fluency.style.cssText === 'font-weight: bold;', 'addAttribute() changes attribute');
            // There's a difference between removeAttribute on the content and removing the dynamic i5_attribute mapping
            fluency.content.removeAttribute('style');
            fluency.render();
            Api_1.assert(fluency.style.cssText === 'font-weight: bold;', 'addAttribute() regenerated during each rendering');
            fluency.content.removeAttribute('style');
            fluency.removeAttributeMapping('style', true);
            Api_1.assert(fluency.style.cssText === '', 'removeAttribute() takes dynamic attribute away');
            fluency.setCssClass('cssClasses', true);
            Api_1.assert(fluency.className === 'class-1 class-2', 'setCssClass() sets className');
            fluency.setCssStyle('bold', true);
            Api_1.assert(fluency.style.cssText === 'font-weight: bold;', 'setCssStyle() changes style');
            fluency.addCssClassSwitch('some-class', 'truthiness', false, true);
            Api_1.assert(fluency.className === 'class-1 class-2 some-class', 'addCssClassSwitch() adds class if property is true');
            // This case is a pain to test without bringing observables into it
            basicViewModel.truthiness = false;
            fluency.render();
            Api_1.assert(fluency.className === 'class-1 class-2', 'class switch still active');
            fluency.removeCssClassSwitch('some-class');
            basicViewModel.truthiness = true;
            fluency.render();
            Api_1.assert(fluency.className === 'class-1 class-2', 'class switch not active');
            // The partial exception  to the rule that update should be true is setTemplate(), and its children setHtmlTemplate()
            // and setTextTemplate(). Full rendering is still delayed, but initial replacements are done before writing.
            // I see pre-replacement values on pages all the time and it's tacky.
            // Note that by default this only replaces text. Any related classes, styles, etc,
            // are not seen until render() is triggered.
            fluency.setHtmlTemplate('rawHtml');
            Api_1.assert(fluency.innerHTML === '<i-v noescape="">Hello <em>World</em></i-v>', 'setHtmlTemplate() sets noescape');
            fluency.setTextTemplate('rawHtml');
            Api_1.assert(fluency.innerHTML === '<i-v>Hello &lt;em&gt;World&lt;/em&gt;</i-v>', 'setTextTemplate() doesnt set noescape');
            fluency.setTemplate('Hiya <i-v>name</i-v>!');
            Api_1.assert(fluency.innerHTML === 'Hiya <i-v>World</i-v>!', 'setTemplate() acts the same as if original innerHTML were set');
            const fluentInput = new Api_1.BoundComponent(basicViewModel, { type: 'input', attributes: { style: 'display: block;', i5_input: 'writable' } }).appendToParent(this.testArea);
            fluentInput.setValueAttribute('name', true);
            Api_1.assert(fluentInput.value === 'World', 'setValueAttribute() sets a value mapping');
            // Re-rendering after this one doesn't actually matter, since this isn't rendered
            fluentInput.addWriteTarget('writable2');
            fluentInput.value = 'Input Test 1';
            fluentInput.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable2 === 'Input Test 1', 'addWriteTarget() adds a form input binding');
            fluentInput.removeWriteTarget('writable2');
            fluentInput.value = 'Input Test 2';
            fluentInput.content.dispatchEvent(new Event('input', { bubbles: true }));
            Api_1.assert(basicViewModel.writable2 === 'Input Test 1', 'removeWriteTarget() removes the input binding');
            // State observables are similar, but keep in mind a few things.
            // Most importantly, you should observe the view model itself, never the sub-objects, which are just parts of the overall state.
            // Also, you are a bit limited in the complexity of your object.
            const stateObservable = new Api_1.ObservableState(basicViewModel);
            const observeComp8 = new Api_1.BoundComponent(stateObservable, {
                innerHtml: 'Hello <i-v>lastListItem</i-v>',
                observeViewModel: true
            }).appendToParent(this.testArea);
            asyncAsserts.then(() => Api_1.assert(observeComp8.innerHTML === 'Hello <i-v>Middle Earth</i-v>', 'Render() called with setState()'));
            stateObservable.setState({ list: ['World', 'Underworld', 'Middle Earth'] });
            // The following shouldn't throw. They won't do anything, but they shouldn't throw.
            const null1 = new Api_1.BoundComponent(undefined, { element: Api_1.createElement(Api_1.elementType.HTMLDivElement, { innerHTML: 'Null-hello <i-v>name</i-v>' }) }).appendToParent(this.testArea);
            const null2 = new LoopComponent2(undefined, {
                outerHtml: `<div id="null2" i5_loop="."><span><i-v>.</i-v> </span></div>`,
                loopItemClass: LoopComponent3,
                async: false // Not using async render because it makes testing suck (this is default)
            }).appendToParent(this.testArea);
            const null3 = new Api_1.BoundComponent(undefined, {
                innerHtml: 'Null-hello <i-v>name</i-v>',
                observeViewModel: true
            }).appendToParent(this.testArea);
            this.log(`TEST ${this.viewModel.testNumber}: Sync test successful`);
            this.log('Starting async tests');
            asyncAsserts.then(() => this.log(`TEST ${this.viewModel.testNumber}: Async tests succeeded`));
            asyncAsserts.catch(err => {
                this.log('ASYNC TESTS FAILED: ' + err.message);
                throw (err);
            });
            asyncAsserts.resolve();
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test010 = Test010;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],74:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Complete Bound Component Examples',
            descriptionHtml: `<p>Part two: more of the same.</p>
            <p>BoundComponents are pretty complex and have lots of options. So much that I'm splitting it up into 2 test cases. And
            to be honest, the first test case is really really long.</p>

            <p>Why are bound components so large (in terms of functionality ... the class is only 800 lines)? Why do they have so many
            options? Well, everyone has a different way of developing, and I don't want to push anyone into 'My Way' ... this isn't Angular
            or something. Especially since My Way changes depending on the project and sometimes the specific functionality. Sometimes
            (usually) a web server pushes the HTML and CSS and the JS just adds on to that. Sometimes, it's an SPA and everything is
            produced in JS. Sometimes I'm building a component that's getting injected into a completely different page.</p>

            <p>There are different ways to do each of these. Interaction with the DOM may be based on a lot of document.getElementById()
            calls. Or it may involve a lot of document.createElement. And even in the latter case, that could involve creating each
            individual elements or pushing a blob of HTML into innerHTML. It all depends.</p>

            <p>This test case implements a VERY simplistic chat component in a variety of different ways, using different features of
            the class in each case.</p>

            <p>I totally do not want to spend the time writing up a serious stylesheet for this, much less pulling in bootstrap, so this
            will look as primitive as heck.</p>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test011 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // Set up common tests for all these identical components, which are all the same thing, just constructed in different ways.
            // Testing this stuff asynchronously is super difficult, though. Normally with a user, you'd make a change, test it, then continue.
            const asyncAsserts = new Api_1.DeferredPromise(Api_1.delay(1000), true);
            function testMessage1(view) {
                const fromelement = view.content.querySelector('input.chat-from');
                const subelement = view.content.querySelector('input.chat-subject');
                const msgelement = view.content.querySelector('textarea.chat-message');
                const btn = view.content.querySelector('button.chat-submit');
                fromelement.value = view.constructor.name;
                fromelement.dispatchEvent(new Event('input', { bubbles: true }));
                subelement.value = "Hello";
                subelement.dispatchEvent(new Event('input', { bubbles: true }));
                msgelement.value = "Every client is adding the same message.";
                msgelement.dispatchEvent(new Event('input', { bubbles: true }));
                setTimeout(() => btn.click(), 50);
            }
            function testMessage2(view) {
                const fromelement = view.content.querySelector('input.chat-from');
                const subelement = view.content.querySelector('input.chat-subject');
                fromelement.value = 'John Smith on behalf of ' + view.constructor.name;
                fromelement.dispatchEvent(new Event('input', { bubbles: true }));
                subelement.value = 'Your assistance is needed';
                subelement.dispatchEvent(new Event('input', { bubbles: true }));
            }
            function testComponent(view) {
                testMessage1(view);
                setTimeout(() => testMessage2(view), 500);
            }
            function assertComponent(view, list) {
                Api_1.assert(view.content.querySelector('div.chat-closing').innerHTML.includes('John Smith'), 'From field updates closing: ' + view.constructor.name);
                Api_1.assert(!view.content.querySelector('input.chat-from').classList.toString().includes('red'), 'Class switch removed when from filled: ' + view.constructor.name);
                const subelement = view.content.querySelector('div.chat-subject-display');
                Api_1.assert(subelement.innerHTML.includes('Your assistance is needed'), 'Subject display updated by subject field: ' + view.constructor.name);
                Api_1.assert(subelement.style.display !== 'none', 'i5_if allows hidden field to become visible: ' + view.constructor.name);
                Api_1.assert(view.content.querySelector('textarea.chat-message').classList.toString().includes('red'), 'Class switch added when no message: ' + view.constructor.name);
                Api_1.assert(view.content.querySelector('button.chat-submit').hasAttribute('disabled'), 'Disabled boolean attribute added when no message: ' + view.constructor.name);
                Api_1.assert(list.chats.length === 6, 'Chats were added to the viewmodel during each chat submit');
            }
            class ChatViewModel {
                constructor(chat) {
                    this.id = 1;
                    this.created = new Date();
                    this.fromName = 'Anonymous';
                    this.subject = '';
                    this.message = '';
                    this.closing = 'I look forward to hearing from you and I remain meanwhile,';
                    if (chat) {
                        Object.assign(this, chat);
                    }
                }
                stripped() {
                    return `${this.message} ${this.closing} ${this.fromName}`.replace(/[\r\n]/g, '');
                }
                invalid() {
                    return !this.subject || !this.message || !this.fromName;
                }
            }
            class ChatListViewModel {
                constructor() {
                    this.chats = Api_1.ObservableProxy.proximate([]);
                    this.getNewChats()
                        .then(newChats => this.chats.push(...newChats));
                }
                beginChat() {
                    return Api_1.ObservableProxy.proximate(this._newChat());
                }
                addChat(chat) {
                    return this.upload(chat)
                        .then(resp => this.getNewChats(chat))
                        .then(newChats => this.chats.push(...newChats))
                        .then(() => this._newChat());
                }
                getNewChats(chat) {
                    if (chat) {
                        // It's important that we not add a reference to the working copy. If this were to be
                        // pulled down from a service, it would be a new object.
                        return Promise.resolve('Imagine a fetch request here').then(() => [new ChatViewModel(chat)]);
                    }
                    return Promise.resolve([]);
                }
                _newChat() {
                    const maxId = (this.chats[this.chats.length - 1] || { id: 0 }).id;
                    return new ChatViewModel({
                        id: maxId,
                        created: new Date(),
                        fromName: 'Anonymous',
                        subject: '',
                        message: ''
                    });
                }
                upload(chat) {
                    return Promise.resolve('Imagine a fetch request here');
                }
            }
            // For fun, we'll let all our different tests interact with the same view model.
            // But we'll arrange so that they give each component its own current working object.
            const chatlist = new ChatListViewModel();
            // This is a pretty cheap way to produce an inline stylesheet but it works and it doesn't even make dupes.
            // I don't like how scoped stylesheets got removed from the standard, though, forcing weird selectors.
            document.head.appendChild(Api_1.createElement(Api_1.elementType.HTMLStyleElement, {
                id: 'chat-stylesheet',
                innerHTML: `
                    .chat-example {
                        border: 3px solid black;
                        width: 75vw;
                    }
                    /* Probably wouldn't be used in a real test, but for this test, works as emphasis. */
                    .chat-example .component:hover {
                        background-color: gold;
                        transition: ease-in-out background-color 1s;
                    }
                    .chat-example .chat-subject-display {
                        background: powderblue;
                        border: 2px solid blue;
                        border-radius: 4px;
                        font-weight: bold;
                    }
                    .chat-example .chat-submit {
                        margin-right: 0;
                        margin-left: auto;
                        display: block;
                    }
                    .chat-example input,textarea {
                        width: 50vw;
                    }
                    .chat-example .red {
                        background: salmon;
                    }
            `
            }));
            // The first example is your traditional ES6 approach, with full HTML being provided by a web server somewhere,
            // then with logic layered on top in JS. The default BoundComponent will be used, as there's no functionality
            // to be overridden with custom logic.
            const example1html = `
                <div id="chat-example1" class="chat-example">
                    <h4>Example 1</h4> <!-- Misusing heading tags by jumping to H4-->
                    <div :loop="chats" class="component chat-list">
                        <div>
                            <div>#<i-v>id</i-v> From:<i-v>fromName</i-v> at <i-v>created</i-v>. <i-v>subject</i-v></div>
                            <div><i-v>stripped</i-v></div>
                        </div>
                    </div>
                    <br />
                    <div class="chat-editor">
                        <form :event (submit)="submit">
                            <div class="component chat-subject-display" :text="subject" :if="subject"></div>
                            <div>
                                <span>From:</span>
                                <input class="component chat-from" :input:="fromName" :switch-:red="fromName" />
                            </div>
                            <div>
                                <span>Subject:</span>
                                <input class="component chat-subject" :input:="subject" :switch-:red="subject" />
                            </div>
                            <div>
                                <textarea class="component chat-message" :input:="message" :switch-:red="message"></textarea>
                            </div>
                            <div class="component chat-closing">
                                <i-v>closing</i-v> <br />
                                <i-v>fromName</i-v>
                            </div>
                            <button class="component chat-submit" type="submit" :bool:disabled="invalid">Submit</button>
                        </form>
                    </div>
                </div>
            `;
            // This is where the "web server" returns a static page
            this.testArea.appendChild(Api_1.createHtml(example1html));
            class ChatView1 extends Api_1.Component {
                constructor(viewModel) {
                    super({ selector: '#chat-example1' });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.list = new Api_1.BoundComponent(this.viewModel, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-list' }))
                        .observe(this.viewModel.chats);
                    this.editor = {
                        subjectDisplay: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-subject-display', observeViewModel: true })),
                        subject: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-subject', observeViewModel: true })),
                        from: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-from', observeViewModel: true })),
                        message: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-message', observeViewModel: true })),
                        closing: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-closing', observeViewModel: true })),
                        button: new Api_1.BoundComponent(this.current, new Api_1.ExistingLookupBindingOptions({ parent: this.content, selector: '.chat-submit', observeViewModel: true }))
                    };
                    this.addInlineEventListeners();
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            const example1View = new ChatView1(chatlist);
            testComponent(example1View);
            asyncAsserts.then(() => assertComponent(example1View, chatlist));
            // Now that was a bit verbose, but it's a good match for the developer who wants to control everything and track
            // every component in the view, or doesn't have a lot of identical components. It does involve a workout for the control-V key.
            // But most, when faced by so much code duplication, would go with something like example 2, which uses the inject method.
            // This one can work with the same HTML provided by the web server.
            class ChatView2 extends Api_1.Component {
                constructor(viewModel) {
                    super({ selector: '#chat-example2' });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.list = Api_1.BoundComponent.inject('#chat-example2 .chat-list', Api_1.kw('viewModel', this.viewModel))[0]
                        .observe(this.viewModel.chats);
                    // Inject all chat entry components in one go
                    this.components = Api_1.BoundComponent.inject('#chat-example2 .chat-editor .component', { observeViewModel: true }, Api_1.kw('viewModel', this.current));
                    this.addInlineEventListeners();
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            const example2html = example1html.replace('example1', 'example2').replace('Example 1', 'Example 2');
            this.testArea.appendChild(Api_1.createHtml(example2html));
            const example2View = new ChatView2(chatlist);
            testComponent(example2View);
            asyncAsserts.then(() => assertComponent(example2View, chatlist));
            // Some people don't like the DIV soup that makes up most HTML. It makes more sense to have custom elements that say
            // what they are. It is these people who are giving us web components (which are a neat idea if they can get them working)
            // (though in most cases it would increase my workload many times).  It is to support this style of developing that I wrote
            // the inject() method for. You can write HTML that looks like it's truly componentized.
            // It takes a LOT of classes, however, and is overkill for an example this simple.
            class ChatList3 extends Api_1.BoundComponent {
                // I'd like to call this inject, but TS's restrictions on override naming forces me to avoid the friendliest names.
                static add(viewModel, parentId) {
                    // Generics are the wordiest things in typescript
                    return this.inject(`${parentId} chat-list`, { replace: true }, Api_1.kw('viewModel', viewModel))[0];
                }
                constructor(viewModel) {
                    super(viewModel, {
                        outerHtml: `
                        <div :loop="chats" class="component chat-list">
                            <div>
                                <div>#<i-v>id</i-v> From:<i-v>fromName</i-v> at <i-v>created</i-v>. <i-v>subject</i-v></div>
                                <div><i-v>stripped</i-v></div>
                            </div>
                        </div>`,
                        observeTargets: [viewModel.chats]
                    });
                }
            }
            class ChatSubjectDisplay3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    return this.inject(`${parentId} chat-subject-display`, { replace: true }, Api_1.kw('viewModel', viewModel))[0];
                }
                constructor(viewModel) {
                    super(viewModel, {
                        outerHtml: `<div class="component chat-subject-display" :text="subject" :if="subject"></div>`,
                        observeViewModel: true
                    });
                }
            }
            class ChatSubject3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    // We can use component (not bound component) injection to fill out static text, like labels.
                    const injected = Api_1.Component.inject(`${parentId} chat-subject`, `
                        <div>
                            <span>Subject:</span>
                            <input class="component chat-subject" :input:="subject" :switch-:red="subject" />
                        </div>
                        `)[0];
                    return new ChatSubject3(viewModel, { parent: injected.content, selector: 'input', observeViewModel: true });
                }
            }
            class ChatFrom3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    const injected = Api_1.Component.inject(`${parentId} chat-from`, `
                        <div>
                            <span>From:</span>
                            <input class="component chat-from" :input:="fromName" :switch-:red="fromName" />
                        </div>
                        `)[0];
                    return new ChatFrom3(viewModel, { parent: injected.content, selector: 'input', observeViewModel: true });
                }
            }
            class ChatMessage3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    const injected = Api_1.Component.inject(`${parentId} chat-message`, `
                        <div>
                            <textarea class="component chat-message" :input:="message" :switch-:red="message"></textarea>
                        </div>
                        `)[0];
                    return new ChatMessage3(viewModel, { parent: injected.content, selector: 'textarea', observeViewModel: true });
                }
            }
            class ChatClosing3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    return this.inject(`${parentId} chat-closing`, { replace: true }, Api_1.kw('viewModel', viewModel))[0];
                }
                constructor(viewModel) {
                    super(viewModel, {
                        outerHtml: `
                            <div class="component chat-closing">
                                <i-v>closing</i-v> <br />
                                <i-v>fromName</i-v>
                            </div>`,
                        observeViewModel: true
                    });
                }
            }
            class ChatSubmit3 extends Api_1.BoundComponent {
                static add(viewModel, parentId) {
                    return this.inject(`${parentId} chat-submit`, { replace: true }, Api_1.kw('viewModel', viewModel))[0];
                }
                constructor(viewModel) {
                    super(viewModel, {
                        outerHtml: `<button class="component chat-submit" type="submit" :bool:disabled="invalid">Submit</button>`,
                        observeViewModel: true
                    });
                }
            }
            class ChatView3 extends Api_1.Component {
                constructor(viewModel) {
                    const parentId = '#chat-example3';
                    super({ selector: parentId });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.list = ChatList3.add(this.viewModel, parentId);
                    this.editor = {
                        subjectDisplay: ChatSubjectDisplay3.add(this.current, parentId),
                        subject: ChatSubject3.add(this.current, parentId),
                        from: ChatFrom3.add(this.current, parentId),
                        message: ChatMessage3.add(this.current, parentId),
                        closing: ChatClosing3.add(this.current, parentId),
                        button: ChatSubmit3.add(this.current, parentId)
                    };
                    this.addInlineEventListeners();
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            // This is where the "web server" returns a static page
            const example3html = `
            <div id="chat-example3" class="chat-example">
                <h4>Example 3</h4> <!-- Misusing heading tags by jumping to H4-->
                <chat-list></chat-list>
                <br />
                <div class="chat-editor">
                    <form :event (submit)="submit">
                        <chat-subject-display></chat-subject-display>
                        <chat-from></chat-from>
                        <chat-subject></chat-subject>
                        <chat-message></chat-message>
                        <chat-closing></chat-closing>
                        <chat-submit></chat-submit>
                    </form>
                </div>
            </div>
            `;
            this.testArea.appendChild(Api_1.createHtml(example3html));
            const example3View = new ChatView3(chatlist);
            testComponent(example3View);
            asyncAsserts.then(() => assertComponent(example3View, chatlist));
            // It's not necessary to use custom tags. You can get similar HTML while keeping things vanilla and doing most of the work
            // on the JS side. This example will avoid using injection.  That makes things more verbose.
            class ChatList4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    super(viewModel, {
                        element: parent.querySelector('.chat-list'),
                        properties: {
                            innerHTML: `
                            <div>
                                <div>#<i-v>id</i-v> From:<i-v>fromName</i-v> at <i-v>created</i-v>. <i-v>subject</i-v></div>
                                <div><i-v>stripped</i-v></div>
                            </div>`
                        },
                        attributes: {
                            i5_loop: "chats"
                        },
                        observeTargets: [viewModel.chats]
                    });
                }
            }
            class ChatSubjectDisplay4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    super(viewModel, {
                        element: parent.querySelector('.chat-subject-display'),
                        attributes: {
                            i5_text: "subject",
                            i5_if: "subject"
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatSubject4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    // Because this has wrapper HTML, we need to add it first.
                    // As long as we don't reference this, we can do it before the super() call.
                    const wrapper = Api_1.div(`
                            <span>Subject:</span>
                            <input class="component chat-subject" :input:="subject" :switch-:red="subject" />
                    `);
                    parent.querySelector('.chat-subject').appendChild(wrapper);
                    super(viewModel, {
                        element: wrapper.querySelector('input'),
                        observeViewModel: true
                    });
                }
            }
            class ChatFrom4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    // Again, wrapper HTML
                    const wrapper = Api_1.div(`
                        <span>From:</span>
                        <input class="component chat-from" :input:="fromName" :switch-:red="fromName" />
                    `);
                    parent.querySelector('.chat-from').appendChild(wrapper);
                    super(viewModel, {
                        element: wrapper.querySelector('input'),
                        observeViewModel: true
                    });
                }
            }
            class ChatMessage4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    // Again, wrapper HTML
                    const wrapper = Api_1.div(`
                        <textarea class="component chat-message" :input:="message" :switch-:red="message"></textarea>
                    `);
                    parent.querySelector('.chat-message').appendChild(wrapper);
                    super(viewModel, {
                        element: wrapper.querySelector('textarea'),
                        observeViewModel: true
                    });
                }
            }
            class ChatClosing4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    super(viewModel, {
                        element: parent.querySelector('.chat-closing'),
                        properties: {
                            innerHTML: `
                                <i-v>closing</i-v> <br />
                                <i-v>fromName</i-v>`
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatSubmit4 extends Api_1.BoundComponent {
                constructor(viewModel, parent) {
                    super(viewModel, {
                        element: parent.querySelector('.chat-submit'),
                        attributes: {
                            type: 'submit',
                            i5_bool_disabled: 'invalid'
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatView4 extends Api_1.Component {
                constructor(viewModel) {
                    super({ selector: '#chat-example4' });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.list = new ChatList4(this.viewModel, this.content);
                    this.editor = {
                        subjectDisplay: new ChatSubjectDisplay4(this.current, this.content),
                        subject: new ChatSubject4(this.current, this.content),
                        from: new ChatFrom4(this.current, this.content),
                        message: new ChatMessage4(this.current, this.content),
                        closing: new ChatClosing4(this.current, this.content),
                        button: new ChatSubmit4(this.current, this.content),
                    };
                    this.addInlineEventListeners();
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            // This is where the "web server" returns a static page
            const example4html = `
            <div id="chat-example4" class="chat-example">
                <h4>Example 4</h4> <!-- Misusing heading tags by jumping to H4-->
                <div class="component chat-list"></div>
                <br />
                <div class="chat-editor">
                    <form :event (submit)="submit">
                        <div class="component chat-subject-display"></div>
                        <div class="chat-from"></div>
                        <div class="chat-subject"></div>
                        <div class="chat-message"></div>
                        <div class="component chat-closing"></div>
                        <button class="component chat-submit">Submit</button>
                    </form>
                </div>
            </div>
            `;
            this.testArea.appendChild(Api_1.createHtml(example4html));
            const example4View = new ChatView4(chatlist);
            testComponent(example4View);
            asyncAsserts.then(() => assertComponent(example4View, chatlist));
            // Some developers may want to add everything in javascript using dom manipulation methods.
            // This coding style produces maximum verbosity, and probably will not be used for a large view,
            // but it might be used for small components here and there.
            class ChatList5 extends Api_1.BoundComponent {
                constructor(viewModel) {
                    super(viewModel, {
                        type: Api_1.elementType.HTMLDivElement,
                        properties: {
                            innerHTML: `
                            <div>
                                <div>#<i-v>id</i-v> From:<i-v>fromName</i-v> at <i-v>created</i-v>. <i-v>subject</i-v></div>
                                <div><i-v>stripped</i-v></div>
                            </div>`
                        },
                        attributes: {
                            class: 'component chat-list',
                            i5_loop: "chats"
                        },
                        observeTargets: [viewModel.chats]
                    });
                }
            }
            class ChatSubjectDisplay5 extends Api_1.BoundComponent {
                constructor(viewModel) {
                    super(viewModel, {
                        // Note: type is optional (DIV is default)
                        attributes: {
                            class: 'component chat-subject-display',
                            i5_text: "subject",
                            i5_if: "subject"
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatSubject5 extends Api_1.Component {
                constructor(viewModel) {
                    super({ properties: { innerHTML: `<span>Subject:</span>` } });
                    // There are two possible ways to handle the wrapper DIV.
                    // One way is to pass the parent into the constructor, and the same as in example 4,
                    // create a wrapper div and insert into it. But just to be different, example 5 will
                    // make the entire div, including the label, into the component.
                    this.bound = new Api_1.BoundComponent(viewModel, new Api_1.InnerHtmlBindingOptions({
                        type: Api_1.elementType.HTMLInputElement,
                        attributes: {
                            class: 'component chat-subject',
                            i5_input_value: "subject",
                            i5_switch0_red: "subject"
                        },
                        observeViewModel: true
                    })).appendToParent(this);
                }
            }
            class ChatFrom5 extends Api_1.Component {
                constructor(viewModel) {
                    super({ properties: { innerHTML: `<span>From:</span>` } });
                    this.bound = new Api_1.BoundComponent(viewModel, new Api_1.InnerHtmlBindingOptions({
                        type: Api_1.elementType.HTMLInputElement,
                        attributes: {
                            class: 'component chat-from',
                            i5_input_value: "fromName",
                            i5_switch0_red: "fromName"
                        },
                        observeViewModel: true
                    })).appendToParent(this);
                }
            }
            class ChatMessage5 extends Api_1.Component {
                constructor(viewModel) {
                    super();
                    this.bound = new Api_1.BoundComponent(viewModel, new Api_1.InnerHtmlBindingOptions({
                        type: Api_1.elementType.HTMLTextAreaElement,
                        attributes: {
                            class: 'component chat-message',
                            i5_input_value: "message",
                            i5_switch0_red: "message"
                        },
                        observeViewModel: true
                    })).appendToParent(this);
                }
            }
            class ChatClosing5 extends Api_1.BoundComponent {
                constructor(viewModel) {
                    super(viewModel, {
                        properties: {
                            // Many properties in HTML can be created either as attributes or properties.
                            // But remember that names may change, as class becomes className.
                            className: 'component chat-closing',
                            innerHTML: `
                                <i-v>closing</i-v> <br />
                                <i-v>fromName</i-v>`
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatSubmit5 extends Api_1.BoundComponent {
                constructor(viewModel) {
                    super(viewModel, {
                        type: Api_1.elementType.HTMLButtonElement,
                        properties: {
                            innerHTML: 'Submit'
                        },
                        attributes: {
                            type: 'submit',
                            class: 'component chat-submit',
                            i5_bool_disabled: 'invalid'
                        },
                        observeViewModel: true
                    });
                }
            }
            class ChatView5 extends Api_1.Component {
                constructor(viewModel) {
                    super({
                        id: 'chat-example5',
                        properties: {
                            className: 'chat-example'
                        }
                    });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.list = new ChatList5(this.viewModel);
                    this.editor = {
                        subjectDisplay: new ChatSubjectDisplay5(this.current),
                        subject: new ChatSubject5(this.current),
                        from: new ChatFrom5(this.current),
                        message: new ChatMessage5(this.current),
                        closing: new ChatClosing5(this.current),
                        button: new ChatSubmit5(this.current),
                    };
                    this.append(Api_1.createElement(Api_1.elementType.HTMLHeading4Element, { innerHTML: 'Example 5' }))
                        .append(this.list)
                        .append(Api_1.createElement(Api_1.elementType.HTMLBRElement));
                    const editor = Api_1.div('', {
                        className: 'chat-editor'
                    });
                    const form = Api_1.createElement(Api_1.elementType.HTMLFormElement);
                    form.appendChild(this.editor.subjectDisplay.content);
                    form.appendChild(this.editor.from.content);
                    form.appendChild(this.editor.subject.content);
                    form.appendChild(this.editor.message.content);
                    form.appendChild(this.editor.closing.content);
                    form.appendChild(this.editor.button.content);
                    form.addEventListener('submit', this.submit.bind(this));
                    this.appendChild(editor).appendChild(form);
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            // Doing everything in javascript, however, means few assumptions about what HTML the web server returns.
            // We find a container, create the view, and drop the view into it.
            const example5View = new ChatView5(chatlist);
            this.testArea.appendChild(example5View.content);
            testComponent(example5View);
            asyncAsserts.then(() => assertComponent(example5View, chatlist));
            // I said example 5 was maximum verbosity, but THIS is maximum verbosity. Say you really liked the fluent interface
            // and wanted to use fluent methods for everything and not do anything in the constructor.
            // To make things even nastier, I'll do it all in a single view, without even encapsulating them in individual
            // component classes ... this is such a pain that no developer would ever make a whole page like this, but
            // doing it for a quick element would be no problem. In fact, VSCode's suggestions are MUCH better for methods as
            // for constructor arguments.
            class ChatView6 extends Api_1.Component {
                constructor(viewModel) {
                    super({
                        id: 'chat-example6',
                        properties: {
                            className: 'chat-example'
                        }
                    });
                    this.viewModel = viewModel;
                    this.current = this.viewModel.beginChat();
                    this.appendChild(Api_1.createElement(Api_1.elementType.HTMLHeading4Element, { innerHTML: 'Example 6' }));
                    this.list = new Api_1.BoundComponent(this.viewModel)
                        .addClass('component chat-list')
                        .setLoop('chats', `<div>
                            <div>#<i-v>id</i-v> From:<i-v>fromName</i-v> at <i-v>created</i-v>. <i-v>subject</i-v></div>
                            <div><i-v>stripped</i-v></div>
                        </div>`)
                        .observe(this.viewModel.chats)
                        .render()
                        .appendToParent(this);
                    this.appendChild(Api_1.createElement(Api_1.elementType.HTMLBRElement));
                    const subjectDisplay = new Api_1.BoundComponent(this.current)
                        .addClass('component chat-subject-display')
                        .setTextTemplate('subject')
                        .setVisibility('subject')
                        .observe()
                        .render();
                    const subject = new Api_1.BoundComponent(this.current, { type: Api_1.elementType.HTMLInputElement })
                        .addClass('component chat-subject')
                        .setValueAttribute('subject')
                        .addWriteTarget('subject')
                        .addWriteEvent()
                        .addCssClassSwitch('red', 'subject', true)
                        .observe()
                        .render();
                    const from = new Api_1.BoundComponent(this.current, { type: Api_1.elementType.HTMLInputElement })
                        .addClass('component chat-from')
                        .setValueAttribute('fromName')
                        .addWriteTarget('fromName')
                        .addWriteEvent()
                        .addCssClassSwitch('red', 'fromName', true)
                        .observe()
                        .render();
                    const message = new Api_1.BoundComponent(this.current, { type: Api_1.elementType.HTMLTextAreaElement })
                        .addClass('component chat-message')
                        .setValueAttribute('message')
                        .addWriteTarget('message')
                        .addWriteEvent()
                        .addCssClassSwitch('red', 'message', true)
                        .observe()
                        .render();
                    const closing = new Api_1.BoundComponent(this.current)
                        .addClass('component chat-closing')
                        .setTemplate(`<i-v>closing</i-v> <br /> <i-v>fromName</i-v>`)
                        .observe()
                        .render();
                    const button = new Api_1.BoundComponent(this.current, new Api_1.InnerHtmlBindingOptions({
                        type: Api_1.elementType.HTMLButtonElement,
                        properties: { innerHTML: 'Submit', type: 'submit' }
                    }))
                        .addClass('component chat-submit')
                        .addBooleanAttributeMapping('disabled', 'invalid')
                        .observe()
                        .render();
                    this.editor = {
                        subjectDisplay, subject, from, message, closing, button
                    };
                    const editor = Api_1.div('', {
                        className: 'chat-editor'
                    });
                    const form = Api_1.createElement(Api_1.elementType.HTMLFormElement);
                    form.appendChild(this.editor.subjectDisplay.content);
                    form.appendChild(Api_1.div('<span>From:</span>')).appendChild(this.editor.from.content);
                    form.appendChild(Api_1.div('<span>Subject:</span>')).appendChild(this.editor.subject.content);
                    form.appendChild(Api_1.div()).appendChild(this.editor.message.content);
                    form.appendChild(this.editor.closing.content);
                    form.appendChild(this.editor.button.content);
                    form.addEventListener('submit', this.submit.bind(this));
                    this.appendChild(editor).appendChild(form);
                }
                submit(evt) {
                    evt.preventDefault();
                    this.viewModel.addChat(this.current)
                        .then(newchat => {
                        Object.assign(this.current, newchat);
                    })
                        .catch(err => console.error(err));
                }
            }
            const example6View = new ChatView6(chatlist);
            this.testArea.appendChild(example6View.content);
            testComponent(example6View);
            asyncAsserts.then(() => assertComponent(example6View, chatlist));
            this.log('Starting async tests');
            asyncAsserts.then(() => this.log(`TEST ${this.viewModel.testNumber}: Async tests succeeded`));
            asyncAsserts.catch(err => {
                this.log('ASYNC TESTS FAILED: ' + err.message);
                throw (err);
            });
            asyncAsserts.resolve();
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test011 = Test011;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("../src/ExtensionLoader");
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Extension Methods',
            descriptionHtml: `<p>In 2017, the original goal was to have one-line binding of HTML elements to dynamic properties, as if
            it were a built-in part of the HTML5 standard. This eventually involved the creation of prototype extension methods. The
            implementation has changed -- now everything uses component binding -- but the original API of extension methods remains. 
            Further extensions were created to do other useful tasks, such as replacing an element.</p>

            <p>To add extension methods to the HTML element prototypes, import ExtensionLoader.ts directly.</p>

            <h2>Usage</h2>

            <p>These are just links to other methods that have already been referenced elsewhere, so I'm just going to list the methods.</p>

            <pre><code>
            interface HTMLElement {
                appendToParent(parent: HTMLElement): this;
                appendChildFluent<T extends Node>(child: T): this;
                appendSibling<T extends Node>(next: T): T;
                appendSiblingFluent<T extends Node>(next: T): this;
                replaceWith<T extends Node>(newElement: T): T;
                swap<T extends Node>(element: T): T;
                extract(): this;
                addEventListenerFluent(eventType: string, event: (evt: Event) => any, options?: AddEventListenerOptions): this;
                addStyle(property: string, value: string): this;
                addClass(classNames: string | string[]): this;
            }
            interface DocumentFragment {
                createElement<TElement extends HTMLElement>(tagName: string, properties?: Record<string, any>, attributes?: Record<string, any>): TElement;
                createElementFluent(tagName: string, properties?: Record<string, any>, attributes?: Record<string, any>): this;
                appendToParent<TElement extends HTMLElement>(parent: TElement): TElement;
            }
            interface HTMLElement {
                getComponent(this: HTMLElement): IContent | undefined;
                bindComponent<TElement extends HTMLElement = HTMLElement, TModel = any>(this: TElement, viewModel: TModel): BoundComponent<TElement, TModel>;
                deleteComponent(): void;
            }
            interface Object {
                toObservable<T>(name?: string): ObservableProperty<T>;
            }
            interface String {
                toObservable(name?: string): ObservableProperty<string>;
            }
            interface Number {
                toObservable(name?: string): ObservableProperty<number>;
            }
            interface Boolean {
                toObservable(name?: string): ObservableProperty<boolean>;
            }
            </code></pre>

            <h2>Warning</h2>
            <p>Tests are async and will keep running. Wait for tests to complete before leaving page.</p>
            `
        });
    }
}
class Test012 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            let clickTest = false;
            const newDiv = Api_1.div("PARENT", { id: "newDiv" });
            const sister = newDiv.appendToParent(this.testArea)
                .appendChildFluent(Api_1.div("CHILD", { id: "child" }))
                .addClass("some-class")
                .addStyle("text-decoration", "underline")
                .appendSiblingFluent(Api_1.div("BROTHER", { id: "brother" }))
                .appendSibling(Api_1.div("SISTER", { id: "sister" }))
                .addEventListenerFluent("click", () => { clickTest = true; });
            Api_1.assert(newDiv.parentElement === this.testArea, "AppendToParent adopts parent element");
            Api_1.assert(document.getElementById("child").parentElement === newDiv, "AppendChildFluent works as appendChild");
            Api_1.assert(newDiv.className === 'some-class', "AddClass adds a class, and appendChildFluent returned reference to fluent object");
            Api_1.assert(newDiv.style.textDecoration === 'underline', "AddStyle adds a style, and addClass returned reference to fluent object");
            Api_1.assert(document.getElementById("brother").parentElement === this.testArea, "AppendSiblingFluent adds a sibling element");
            Api_1.assert(document.getElementById("sister").parentElement === this.testArea, "AppendSibling adds a sibling element and appendSiblingFluent returned reference to fluent object");
            Api_1.assert(document.getElementById("sister") === sister, "AppendSibling returns reference to argument and addEventListenerFluent returned reference to fluent object");
            sister.click();
            Api_1.assert(clickTest, "AddEventListenerFluent adds click handler");
            const exchangeStudent = this.testArea.appendChild(Api_1.div("FAMILY IN ANOTHER COUNTRY", { id: "foreign" }))
                .appendChild(Api_1.div("EXCHANGE STUDENT", { id: "exchange" }));
            exchangeStudent.swap(sister);
            Api_1.assert(document.getElementById("foreign") === sister.parentElement && exchangeStudent.parentElement === this.testArea, "Swap exchanged element locations");
            const puppy = document.getElementById("child").replaceWith(Api_1.div("PUPPY"));
            Api_1.assert(puppy.parentElement === newDiv && document.getElementById("child") === null, "ReplaceWith added replaced the element");
            sister.extract();
            Api_1.assert(document.getElementById("sister") === null, "Extract removed the element");
            const frag = document.createDocumentFragment();
            frag.createElementFluent(Api_1.elementType.HTMLDivElement, { innerHTML: "Frag Brother", id: "frag-brother" })
                .createElement(Api_1.elementType.HTMLDivElement, { innerHTML: "Frag Sister", id: "frag-sister" })
                .appendChild(Api_1.div("Frag Nephew", { id: "frag-nephew" }));
            frag.appendToParent(this.testArea);
            Api_1.assert(document.getElementById("frag-brother").parentElement === this.testArea, "CreateElementFluent created an element and appendToParent added the fragment content");
            Api_1.assert(document.getElementById("frag-sister").parentElement === this.testArea, "CreateElement created an element and CreateReferencFluent returned reference to fluent object");
            Api_1.assert(document.getElementById("frag-nephew").parentElement === document.getElementById("frag-sister"), "CreateElement returned reference to argument");
            const testViewModel = {
                name: "My Name".toObservable(),
                age: (24).toObservable(),
                observed: true.toObservable(),
                friend: exchangeStudent.toObservable(),
                friendsName: function () { return this.friend.value.innerHTML; }
            };
            Api_1.assert(testViewModel.name instanceof Api_1.ObservableProperty, "toObservable made simple string an observable");
            Api_1.assert(testViewModel.age instanceof Api_1.ObservableProperty, "toObservable made simple number an observable");
            Api_1.assert(testViewModel.observed instanceof Api_1.ObservableProperty, "toObservable made simple bool an observable");
            Api_1.assert(testViewModel.friend instanceof Api_1.ObservableProperty, "toObservable made object an observable");
            // Now we put it all together. I don't recommend building a full form like this. Someone will need to maintain it.
            // That person might be you. But for adding a single bound element, it could work.
            const form = this.testArea.appendChild(Api_1.createElement(Api_1.elementType.HTMLFormElement));
            const name = Api_1.createElement(Api_1.elementType.HTMLInputElement, { id: "name" })
                .bindComponent(testViewModel)
                .setValueAttribute("name")
                .addWriteTarget("name")
                .addWriteEvent()
                .observe(testViewModel.name)
                .render()
                .appendToParent(form);
            const age = Api_1.createElement(Api_1.elementType.HTMLInputElement, { type: "number", id: "age" })
                .bindComponent(testViewModel.age)
                .setValueAttribute() // defaults to .
                .addWriteTarget() // defaults to .
                .addWriteEvent()
                .observe()
                .render()
                .appendToParent(form);
            const observed = Api_1.createElement(Api_1.elementType.HTMLInputElement, { id: "observed" }, { readonly: true })
                .bindComponent(testViewModel)
                .setValueAttribute("observed", true)
                .appendToParent(form);
            const friend = Api_1.createElement(Api_1.elementType.HTMLInputElement, { id: "friend" }, { readonly: true })
                .bindComponent(testViewModel)
                .setValueAttribute("friendsName", true)
                .appendToParent(form);
            Api_1.assert(name.value === "My Name", "Element binding is in place");
            Api_1.assert(age.value === 24, "Element binding is in place with default attribute");
            Api_1.assert(document.getElementById('friend').getComponent() === friend, "GetComponent gets the component bound");
            this.log(`TEST ${this.viewModel.testNumber}: Begin Async Test`);
            name.value = "Not My Name";
            name.content.dispatchEvent(new Event('input', { bubbles: true }));
            testViewModel.age.value = 25;
            setTimeout(() => {
                Api_1.assert(age.value === 25, "Two-way binding is reading");
                Api_1.assert(testViewModel.name.value === "Not My Name", "Two-way binding is writing");
                this.log(`TEST ${this.viewModel.testNumber}: Async Test successful`);
            }, 1000);
            this.log(`TEST ${this.viewModel.testNumber}: Sync Test successful`);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test012 = Test012;

},{"../src/Api":1,"../src/ExtensionLoader":8,"./TestCaseView":79,"./TestCaseViewModel":80}],76:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'Dedicated Web Worker (Experimental)',
            descriptionHtml: `<p>This is an experimental web worker that can be created on the fly and dedicated
            to heavy tasks that, assuming the user's PC is powerful enough, be run on background threads without
            impacting front-end performance.</p>

            <p>You can type away in the next input to see that the front end is not being blocked and there is no
            stuttering in the debug console.</p>
            <input style="width: 100%;"/ id="stutter-check">

            <h2>Usage</h2>
            <p>Pass the task and its arguments to taskStart().then(response => wait for the response);</p>
            `
        });
    }
}
class Test013 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            function bigCalculation(iter, mult) {
                const primes = calculatePrimes(iter, mult);
                return primes;
                function calculatePrimes(iterations, multiplier) {
                    // tslint:disable-next-line:no-shadowed-variable
                    const primes = [];
                    for (let i = 0; i < iterations; i++) {
                        const candidate = i * (multiplier * Math.random());
                        let isPrime = true;
                        for (let c = 2; c <= Math.sqrt(candidate); ++c) {
                            if (candidate % c === 0) {
                                isPrime = false;
                                break;
                            }
                        }
                        if (isPrime) {
                            primes.push(candidate);
                        }
                    }
                    return primes;
                }
            }
            // To make it extra difficult, we'll also spend CPU on the current thread logging what the user types.
            document.getElementById('stutter-check').addEventListener('input', (evt) => {
                // tslint:disable-next-line:no-console
                console.log(evt.currentTarget.value);
            });
            this.log(`Test ${this.viewModel.testNumber}: Test start`);
            let calc = [];
            const dyn = new Api_1.DynamicWebWorker();
            dyn.taskStart(bigCalculation, 1000, 1000000000).then(resp => {
                calc = resp;
                // tslint:disable-next-line:no-console
                console.log(resp);
                this.log(resp.length + ' primes calculated');
            }).then(() => {
                Api_1.assert(calc.length === 1000, 'All the primes were calculated');
                this.log(`Test ${this.viewModel.testNumber}: Test successful`);
            });
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test013 = Test013;

},{"../src/Api":1,"./TestCaseView":79,"./TestCaseViewModel":80}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const TestCaseView_1 = require("./TestCaseView");
const TestCaseViewModel_1 = require("./TestCaseViewModel");
const Api_1 = require("../src/Api");
const CssStyleSheet_1 = require("../src/Css/CssStyleSheet");
// tslint:disable:max-classes-per-file
class TestViewModel extends TestCaseViewModel_1.TestCaseViewModel {
    constructor() {
        super({
            name: 'JS CSS Classes (Experimental)',
            descriptionHtml: `<p>Here's another experimental model that will be of limited utility, but it's kind
            of neat. It's making CSS classes (any rules, in fact, even those that aren't using class selectors) act
            more like JS classes, with inheritance and traits. Basically similar to SASS/SCSS except at runtime (my
            first version used SCSS syntax even).</p>

            <p>This isn't very useful, the same as SASS isn't very useful. Oh, I know that a number of projects
            use it, but that doesn't mean it's really worth it. The problem with CSS isn't the lack of inheritance ...
            for simple key/value collections, clipboard inheritance is annoying but functional. It isn't the lack of
            variables ... CSS variables now exist. It isn't the way scoping was deleted from the standard ... that
            can be hacked together using selectors ... but it does hurt.</p>

            <p>The problem with CSS is CSS. It's a flaming trainwreck during the Hard Rain. No amount of sugar will make
            the CSS layout model sweeter than a human waste recycling plant. The most powerful tool -- really the only
            tool -- that helps with dealing with CSS is attitude. Specifically, this attitude: "it looks close enough."</p>

            <p>But it was a fun experiment. Except when I had to fight bugs in TypeScript (that still exist in new versions so
            my NPM build issues aren't the issue stressing me).</p>

            <h2>Usage</h2>
            <p>Create classes inheriting from CssClass, with properties that match the class (or other rule) CSS properties. In most
            cases these will need to be quoted. Their values can be strings, instances of the CssVariable class, or nested properties,
            which are simple text maps (for example, font = { weight: "bold" } is the same as setting "font-weight" = "bold"). 
            Call render$() to add the CSS to the page.</p>

            <p>Special properties all end in the $ character.</p>
            <code><pre>
            interface {
                selector$: string;              // selector for the rule. Required.
                media$?: string;                // @media element
                styleSheetParent$: HTMLElement; // A <style> element is created. This is where. Default document.head.
                styleSheetId$: string;          // The ID of the style element created. Autogenerated.
                scopeElement$?: HTMLElement;    // Set this if you want the CSS to apply only to an element or its children
                extends$?: RulesCanExtend | RulesCanExtend[];   // Inherit CSS from these classes. Allows multiple inheritance.
                nested$?: RulesCanNest | RulesCanNest[];        // See the & operator in SASS/LESS.
                revert$: boolean;                               // Set to true as a shortcut for "all" = "initial"
                render$(): void;                                // Add or update the <style> element, adding CSS styling
                remove$(): void;                                // Remove the <style> element, removing CSS styling
            }
            </pre></code>

            <p>When writing the class and using initializers, remember to use equals (=), not colon (:). This is important.
            Remember that this is Typescript. "class CLS { foo: 'bar' } is totally different from "var CLS = { foo: 'bar' }." In the
            first case, new objects look like this {}, and your resulting CSS class is empty.</p>

            <p>The CssStyleSheet is a collection of CssRule objects. CssVariable is a CSS custom property. CssInlineRule is a quick and
            dirty way to create a CssRule inline in code without creating a class.</p>`
        });
    }
}
class Test014 extends TestCaseView_1.TestCaseView {
    constructor() {
        super(new TestViewModel());
    }
    testCase() {
        try {
            // Demo storing styles somewhere other than the HEAD
            const randomStyleDiv = Api_1.div({ id: 'somewhere-for-the-style' });
            this.testArea.appendChild(randomStyleDiv);
            const scopedDiv = Api_1.div({ id: 'scoped', className: 'divparent' });
            scopedDiv.appendChild(Api_1.paragraph('Hello World', { id: 'para' })).appendChild(Api_1.paragraph()); // dummy p tag at end
            scopedDiv.appendChild(Api_1.anchor('Test1', 'https://www.google.com', { id: 'a1' })).appendChild(Api_1.paragraph()); // dummy p at end
            scopedDiv.appendChild(Api_1.anchor('Test2', 'https://www.google.com', { id: 'a2', className: 'nested' })).appendChild(Api_1.paragraph());
            this.testArea.appendChild(scopedDiv);
            const colorVar = new Api_1.CssVariable("primary", "blue");
            class BorderBaseRule extends Api_1.CssSimpleRule {
                constructor() {
                    super(...arguments);
                    this["border-style"] = "solid";
                }
            }
            class BorderColorRule extends BorderBaseRule {
                constructor() {
                    super(...arguments);
                    this["border-color"] = "black";
                    this["border-bottom-width"] = "10px";
                }
            }
            class DivRule extends Api_1.CssRule {
                constructor() {
                    super(randomStyleDiv);
                    this.selector$ = "div";
                    this["color"] = colorVar;
                    this["font-size"] = "20px";
                    this["font"] = {
                        weight: "bold" // Demo nested properties: Only one level of nesting is allowed
                    };
                    this.extends$ = BorderColorRule; // Demo "multiple inheritance"
                    this.nested$ = NestedRule; // Demo nested rules/selectors
                    this.scopeElement$ = scopedDiv; // Demo fake scoping (shouldn't affect all the other divs on the page)
                }
            }
            class NestedRule extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = "& .nested"; // Note the SASS/LESS ampersand that forces a space. You could have also used " .nested" but that would look weird.
                    this["text-decoration"] = "none";
                }
            }
            const cssRule = new DivRule().render$();
            const divStyles = window.getComputedStyle(scopedDiv);
            const testAreaStyles = window.getComputedStyle(this.testArea);
            const textStyles = window.getComputedStyle(document.getElementById('para'));
            const a1styles = window.getComputedStyle(document.getElementById('a1'));
            const a2styles = window.getComputedStyle(document.getElementById('a2'));
            this.log('Beginning tests. Warning: these tests are based on the default setup where I live.');
            this.log('They will fail in browsers with different CSS settings');
            Api_1.assert(textStyles.getPropertyValue('font-size') === '20px', 'Direct string property is applied');
            Api_1.assert(divStyles.getPropertyValue("border-color") === 'rgb(0, 0, 0)', 'Inherited property is applied (1 level deep)');
            Api_1.assert(divStyles.getPropertyValue("border-style") === 'solid', 'Inherited property is applied (2 levels deep)');
            Api_1.assert(a2styles.getPropertyValue('text-decoration').includes('none'), 'Nested rule is applied');
            Api_1.assert(textStyles.getPropertyValue('color') === 'rgb(0, 0, 255)', 'CSS variable (custom property) is applied');
            Api_1.assert(textStyles.getPropertyValue('font-weight') === '700', 'Nested property is applied');
            Api_1.assert(testAreaStyles.getPropertyValue("border-style") === 'none', 'Scoped style stays in scoped element');
            class AllRed extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = 'page-router';
                    this['color'] = 'red';
                }
            }
            class WavyGravy extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = 'h1';
                    this['text-decoration'] = 'wavy underline';
                }
            }
            // A style sheet is little more than a collection of style rules
            const sheet1 = new CssStyleSheet_1.CssStyleSheet([AllRed, WavyGravy], randomStyleDiv);
            sheet1.render();
            Api_1.assert(window.getComputedStyle(document.querySelector('h1')).getPropertyValue('color') === 'rgb(255, 0, 0)', 'Styles in stylesheet are applied and there is no scoping');
            Api_1.assert(window.getComputedStyle(document.querySelector('h1')).getPropertyValue('text-decoration').includes('wavy'), 'Multiple styles in stylesheet are applied');
            sheet1.remove();
            Api_1.assert(window.getComputedStyle(document.querySelector('h1')).getPropertyValue('color') === 'rgb(0, 0, 0)', 'Styles in stylesheet are removed');
            Api_1.assert(!window.getComputedStyle(document.querySelector('h1')).getPropertyValue('text-decoration').includes('wavy'), 'Multiple styles in stylesheet are removed');
            // Finally a more complex test. This resembles something you might actually use this for.
            class BtnBase extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = ".btn";
                    this["display"] = "inline-block";
                    this["font-weight"] = "500";
                    this["text-align"] = "center";
                    this["white-space"] = "nowrap";
                    this["vertical-align"] = "middle";
                    this["user-select"] = "none";
                    this["border"] = "1px solid transparent";
                    this["padding"] = ".46875rem 1rem";
                    this["font-size"] = "1rem";
                    this["line-height"] = "1.5";
                    this["border-radius"] = ".125rem";
                    this["transition"] = "color 0.15s ease-in-out,background-color .15s ease-in-out,border-color 0.15s ease-in-out,box-shadow .15s ease-in-out";
                    this.nested$ = [
                        new Api_1.CssInlineRule("&:hover, &:hover", { "text-decoration": "none" }),
                        new Api_1.CssInlineRule("&:focus, &.focus", { "outline": "none", "box-shadow": "none" }),
                        new Api_1.CssInlineRule("&:disabled, &.disabled", { "opacity": ".65", "box-shadow": "none" }),
                        new Api_1.CssInlineRule("&:not(:disabled):not(.disabled)", { cursor: "pointer" }),
                    ];
                }
            }
            class BtnPrimary extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = "";
                    this["color"] = "#fff";
                    this["background-color"] = "#df382c";
                    this["border-color"] = "#df382c";
                    this["box-shadow"] = "none";
                    this.nested$ = [
                        new Api_1.CssInlineRule("&:hover", { "color": "#fff", "background-color": "#f22112", "border-color": "#ea1c0d" }),
                        new Api_1.CssInlineRule("&.focus", { "box-shadow": "none, 0 0 0 .2rem rgba(244,67,54,.5)" }),
                        new Api_1.CssInlineRule("&.disabled, &:disabled", { "color": "#fff", "background-color": "#df382c", "border-color": "#df382c" }),
                        new Api_1.CssInlineRule("&:not(:disabled):not(.disabled).active, &:not(:disabled):not(.disabled):active", { "color": "#fff", "background-color": "#ea1c0d", "border-color": "#deb1b0c" }),
                        new Api_1.CssInlineRule("&:not(:disabled):not(.disabled).active:focus, &:not(:disabled):not(.disabled):active:focus", { "box-shadow": "none,0 0 0 .2rem rgba(244,67,54,.5)" }),
                    ];
                }
            }
            class BtnSecondary extends Api_1.CssRule {
                constructor() {
                    super(...arguments);
                    this.selector$ = "";
                    this["color"] = "#fff";
                    this["background-color"] = "#aea79f";
                    this["border-color"] = "#aea79f";
                    this["box-shadow"] = "none";
                    this.nested$ = [
                        new Api_1.CssInlineRule("&:hover", { "color": "#fff", "background-color": "#5a6268", "border-color": "#545b62" }),
                        new Api_1.CssInlineRule("&.focus", { "box-shadow": "none, 0 0 0 .2rem rgba(208,7%,46%,.5)" }),
                        new Api_1.CssInlineRule("&.disabled, &:disabled", { "color": "#fff", "background-color": "#aea79f", "border-color": "#aea79f" }),
                        new Api_1.CssInlineRule("&:not(:disabled):not(.disabled).active, &:not(:disabled):not(.disabled):active", { "color": "#fff", "background-color": "#545b62", "border-color": "#4e555b" }),
                        new Api_1.CssInlineRule("&:not(:disabled):not(.disabled).active:focus, &:not(:disabled):not(.disabled):active:focus", { "box-shadow": "none,0 0 0 .2rem rgba(208,7%,46%,.5)" }),
                    ];
                }
            }
            class BtnClass extends BtnBase {
                constructor(className, primary = true, parent) {
                    super(parent);
                    this.selector$ = '.' + className;
                    this.extends$ = this.extends$ || [];
                    if (!Array.isArray(this.extends$)) {
                        this.extends$ = [this.extends$];
                    }
                    if (primary) {
                        this.extends$.push(new BtnPrimary());
                    }
                    else {
                        this.extends$.push(new BtnSecondary());
                    }
                }
            }
            // Now say I imported the BtnClass from some module.
            const buttonTest = this.testArea.appendChild(Api_1.div());
            const btnPrimary = new BtnClass("btn-primary", true, buttonTest).render$();
            const btnSecondary = new BtnClass("btn-secondary", false, buttonTest).render$();
            this.testArea.appendChild(Api_1.createHtml(`<div>
                    <button type="button" class="btn-primary">Ok</button>
                    <button type="button" class="btn-secondary">Not Ok</button>
                </div>
                `));
            const allTheRules = Api_1.getCssRulesInElement(buttonTest);
            this.log(allTheRules);
            this.log(`Test ${this.viewModel.testNumber}: Test successful`);
        }
        catch (err) {
            this.log("ERROR: " + err);
            throw err;
        }
    }
}
exports.Test014 = Test014;

},{"../src/Api":1,"../src/Css/CssStyleSheet":5,"./TestCaseView":79,"./TestCaseViewModel":80}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
class ConsoleViewModel {
    constructor() {
        this.output = Api_1.ObservableProxy.proximate([]);
    }
}
// tslint:disable-next-line:max-classes-per-file
class ConsoleView extends Api_1.Component {
    constructor() {
        super({
            innerHtml: `
                <h2>Log</h2>
                <div id="consoleLog" :loop="output">
                    <div :item><i-v>.</i-v></div>
                </div>`
        });
        this.viewModel = new ConsoleViewModel();
        this.entries = new Api_1.BoundComponent(this.viewModel, {
            parent: this.content,
            selector: '#consoleLog',
            observeAllViewModel: true
        });
    }
    /**
     * Log to the dev console but also to the output observable, where it can be used for display.
     *
     * @param {*} thing
     * @memberof ConsoleView
     */
    log(thing) {
        // tslint:disable-next-line:no-console
        console.log(thing);
        this.viewModel.output.push(clean(thing));
        function clean(val) {
            if (Api_1.isNone(val)) {
                return '';
            }
            if (typeof val === 'string') {
                return val;
            }
            return JSON.stringify(val);
        }
    }
}
exports.ConsoleView = ConsoleView;

},{"../src/Api":1}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:max-classes-per-file
const Api_1 = require("../src/Api");
const TestCaseConsole_1 = require("./TestCaseConsole");
class TestCaseView extends Api_1.Component {
    constructor(viewModel) {
        super();
        this.viewModel = viewModel;
        // Multiple ways of appending new components
        this.appendChild(new TestHeader(viewModel));
        this.console = new TestCaseConsole_1.ConsoleView().appendToParent(this);
        this.testAreaHeader = this.appendChild(Api_1.createElement(Api_1.elementType.HTMLHeading2Element, {
            innerHTML: 'Test Area',
            style: 'cursor: pointer;'
        }));
        this.testArea = this.appendChild(Api_1.div('', { id: 'testArea' }));
        // Need to add a small delay, because this component is added to the DOM by the PageRouter immediately
        // after construction. document.getElementById(), used in many test cases, won't find anything until after
        // the closing brace.
        setTimeout(() => this.testCase(), 150);
        // Make the test area collapsable and collapse it after 3s.
        this.testAreaHeader.addEventListener('click', this.toggleTestArea.bind(this));
        this.toggleId = setTimeout(() => this.toggleTestArea(), 3000);
    }
    log(thing) {
        this.console.log(thing);
    }
    toggleTestArea(evt) {
        // Don't toggle after user clicks the header
        if (evt && this.toggleId) {
            clearTimeout(this.toggleId);
            this.toggleId = undefined;
        }
        if (this.testArea.style.display !== 'none') {
            this.testArea.style.display = 'none';
            this.testAreaHeader.style.color = 'lightgray';
            this.testAreaHeader.innerHTML = 'Test Area (hidden)';
        }
        else {
            this.testArea.style.display = 'block';
            this.testAreaHeader.style.color = 'black';
            this.testAreaHeader.innerHTML = 'Test Area';
        }
    }
}
exports.TestCaseView = TestCaseView;
class TestHeader extends Api_1.Component {
    constructor(vm) {
        super();
        if (vm.name) {
            this.appendChild(Api_1.paragraph(`<h1>Test ${vm.testNumber}: ${vm.name}</h1>`));
        }
        if (vm.description) {
            this.appendChild(Api_1.span(vm.description));
        }
    }
}
exports.TestHeader = TestHeader;

},{"../src/Api":1,"./TestCaseConsole":78}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
class TestCaseViewModel {
    constructor({ name, descriptionHtml } = {}) {
        this.name = Api_1.escapeHtml(name);
        this.description = descriptionHtml;
        this.testNumber = Api_1.PageRouter.params.get('id') || '?';
    }
}
exports.TestCaseViewModel = TestCaseViewModel;

},{"../src/Api":1}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Api_1 = require("../src/Api");
class TestbenchView extends Api_1.Component {
    constructor() {
        super({
            id: 'test-bench',
            innerHtml: `<div>
                <a href="#" class="test-link">Previous Test</a>
                <span id="testHeader">Test #0</span>
                <a href="#" class="test-link" data-next="1">Next Test</a>
            </div>
            <br />
            <layout-body></layout-body>`
        });
        const hdr = this.content.querySelector('#testHeader');
        if (hdr) {
            hdr.innerHTML = "Test #" + Api_1.PageRouter.matchedRoute.params.get('id') || '0';
        }
        // Initialize pager to go through tests.
        for (const l of this.content.querySelectorAll('.test-link')) {
            l.addEventListener('click', this.gotoNextTest.bind(this));
        }
    }
    gotoNextTest(evt) {
        evt.preventDefault();
        const id = Number(Api_1.PageRouter.matchedRoute.params.get('id') || '0');
        let nextid;
        if (evt.currentTarget.dataset.next) {
            nextid = id + 1;
            // At the moment, there's exactly one route per test, so we can cheaply know we're at the end
            // even without any configuration for the tests being in this class. This is a cheat, though,
            // because we could easily have added some other routes.
            if (nextid >= Api_1.PageRouter.allRoutes.length) {
                nextid = 0;
            }
        }
        else {
            nextid = id - 1;
            if (nextid < 0) {
                nextid = Api_1.PageRouter.allRoutes.length - 1;
            }
        }
        const hdr = this.content.querySelector('#testHeader');
        if (hdr) {
            hdr.innerHTML = "Test #" + nextid;
        }
        Api_1.PageRouter.route('test/' + nextid);
    }
}
exports.TestbenchView = TestbenchView;

},{"../src/Api":1}]},{},[62])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25wbV9nbG9iYWwvbGliL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvQXBpLmpzIiwic3JjL0Nzcy9Dc3NJbmxpbmVSdWxlLmpzIiwic3JjL0Nzcy9Dc3NSdWxlLmpzIiwic3JjL0Nzcy9Dc3NSdWxlQ29udHJhY3QuanMiLCJzcmMvQ3NzL0Nzc1N0eWxlU2hlZXQuanMiLCJzcmMvQ3NzL0Nzc1ZhcmlhYmxlLmpzIiwic3JjL0Nzcy9HZXRDc3NSdWxlc0luRWxlbWVudC5qcyIsInNyYy9FeHRlbnNpb25Mb2FkZXIuanMiLCJzcmMvRXh0ZW5zaW9ucy9Db21wb25lbnRFeHRlbnNpb25zLmpzIiwic3JjL0V4dGVuc2lvbnMvRWxlbWVudEV4dGVuc2lvbnMuanMiLCJzcmMvRXh0ZW5zaW9ucy9PYnNlcnZhYmxlRXh0ZW5zaW9ucy5qcyIsInNyYy9IdG1sL0NyZWF0ZUVsZW1lbnQuanMiLCJzcmMvSHRtbC9EZWxldGVOb2RlQ29udGVudC5qcyIsInNyYy9IdG1sL0VsZW1lbnRUeXBlLmpzIiwic3JjL0h0bWwvRXNjYXBlSHRtbC5qcyIsInNyYy9IdG1sL0V4dHJhY3ROb2RlQ29udGVudC5qcyIsInNyYy9IdG1sL0ZpbmRJbmRleEluUGFyZW50LmpzIiwic3JjL0h0bWwvRm9ybUZpZWxkVmFsdWUuanMiLCJzcmMvSHRtbC9RdWVyeVNlbGVjdG9yTm9kZUxpc3QuanMiLCJzcmMvSHRtbC9WYWxpZGF0ZVVuaXF1ZURvbUlkcy5qcyIsInNyYy9IdG1sQ29tcG9uZW50L0JvdW5kQ29tcG9uZW50LmpzIiwic3JjL0h0bWxDb21wb25lbnQvQ29tcG9uZW50LmpzIiwic3JjL0h0bWxDb21wb25lbnQvQ29tcG9uZW50TWFwLmpzIiwic3JjL0h0bWxDb21wb25lbnQvT3B0aW9ucy9JQ29tcG9uZW50QmluZGluZ09wdGlvbnMuanMiLCJzcmMvSHRtbENvbXBvbmVudC9PcHRpb25zL0lFeGlzdGluZ0VsZW1lbnRPcHRpb25zLmpzIiwic3JjL0h0bWxDb21wb25lbnQvT3B0aW9ucy9JRXhpc3RpbmdMb29rdXBPcHRpb25zLmpzIiwic3JjL0h0bWxDb21wb25lbnQvT3B0aW9ucy9JSW5uZXJIdG1sT3B0aW9ucy5qcyIsInNyYy9IdG1sQ29tcG9uZW50L09wdGlvbnMvSU91dGVySHRtbE9wdGlvbnMuanMiLCJzcmMvT2JzZXJ2YWJsZS9JT2JzZXJ2YWJsZS5qcyIsInNyYy9PYnNlcnZhYmxlL0ludGVybmFsL0FycmF5T2JzZXJ2YWJsZS5qcyIsInNyYy9PYnNlcnZhYmxlL0ludGVybmFsL0FycmF5UHJveHlIYW5kbGVyLmpzIiwic3JjL09ic2VydmFibGUvSW50ZXJuYWwvT2JqZWN0T2JzZXJ2YWJsZS5qcyIsInNyYy9PYnNlcnZhYmxlL0ludGVybmFsL09iamVjdFByb3h5SGFuZGxlci5qcyIsInNyYy9PYnNlcnZhYmxlL09ic2VydmFibGVBc3NpZ24uanMiLCJzcmMvT2JzZXJ2YWJsZS9PYnNlcnZhYmxlQmFzZS5qcyIsInNyYy9PYnNlcnZhYmxlL09ic2VydmFibGVQcm9wZXJ0eS5qcyIsInNyYy9PYnNlcnZhYmxlL09ic2VydmFibGVQcm94eS5qcyIsInNyYy9PYnNlcnZhYmxlL09ic2VydmFibGVTdGF0ZS5qcyIsInNyYy9Sb3V0ZXIvQWR2YW5jZWRQYWdlUm91dGVyLmpzIiwic3JjL1JvdXRlci9QYWdlUm91dGVyLmpzIiwic3JjL1N5c3RlbS9Bc3luYy9EZWZlcnJlZFByb21pc2UuanMiLCJzcmMvU3lzdGVtL0FzeW5jL0RlbGF5LmpzIiwic3JjL1N5c3RlbS9Bc3luYy9EeW5hbWljV2ViV29ya2VyLmpzIiwic3JjL1N5c3RlbS9Bc3luYy9SZXBlYXRhYmxlUHJvbWlzZS5qcyIsInNyYy9TeXN0ZW0vQ29sbGVjdGlvbnMvQXJyYXlVdGlsaXRpZXMuanMiLCJzcmMvU3lzdGVtL0NvbGxlY3Rpb25zL09yZGVyQnkuanMiLCJzcmMvU3lzdGVtL0V2ZW50SGFuZGxlci9BcnJheUNoYW5nZWRFdmVudEFyZ3MuanMiLCJzcmMvU3lzdGVtL0V2ZW50SGFuZGxlci9EZWxlZ2F0ZS5qcyIsInNyYy9TeXN0ZW0vRXZlbnRIYW5kbGVyL0V2ZW50SGFuZGxlci5qcyIsInNyYy9TeXN0ZW0vRXZlbnRIYW5kbGVyL1Byb3BlcnR5Q2hhbmdlZEV2ZW50QXJncy5qcyIsInNyYy9TeXN0ZW0vVHlwZXMvQ29uc3RydWN0YWJsZS5qcyIsInNyYy9TeXN0ZW0vVHlwZXMvS2V5d29yZEFyZ3VtZW50cy5qcyIsInNyYy9TeXN0ZW0vVHlwZXMvTm9uZVR5cGUuanMiLCJzcmMvU3lzdGVtL1V0aWxpdHkvQXNzZXJ0LmpzIiwic3JjL1N5c3RlbS9VdGlsaXR5L0Nsb25lRGVlcC5qcyIsInNyYy9TeXN0ZW0vVXRpbGl0eS9DbG9uZU9iamVjdC5qcyIsInNyYy9TeXN0ZW0vVXRpbGl0eS9FbHZpcy5qcyIsInNyYy9TeXN0ZW0vVXRpbGl0eS9HZXRVbmlxdWVJZC5qcyIsInNyYy9TeXN0ZW0vVXRpbGl0eS9Jc0ludGVnZXIuanMiLCJzcmMvU3lzdGVtL1V0aWxpdHkvSXNQcmltaXRpdmUuanMiLCJzcmMvU3lzdGVtL1V0aWxpdHkvT2JqZWN0RnVsbEFzc2lnbi5qcyIsInRlc3RzL1Byb2dyYW0uanMiLCJ0ZXN0cy9UZXN0MDAwLmpzIiwidGVzdHMvVGVzdDAwMS5qcyIsInRlc3RzL1Rlc3QwMDIuanMiLCJ0ZXN0cy9UZXN0MDAzLmpzIiwidGVzdHMvVGVzdDAwNC5qcyIsInRlc3RzL1Rlc3QwMDUuanMiLCJ0ZXN0cy9UZXN0MDA2LmpzIiwidGVzdHMvVGVzdDAwNy5qcyIsInRlc3RzL1Rlc3QwMDguanMiLCJ0ZXN0cy9UZXN0MDA5LmpzIiwidGVzdHMvVGVzdDAxMC5qcyIsInRlc3RzL1Rlc3QwMTEuanMiLCJ0ZXN0cy9UZXN0MDEyLmpzIiwidGVzdHMvVGVzdDAxMy5qcyIsInRlc3RzL1Rlc3QwMTQuanMiLCJ0ZXN0cy9UZXN0Q2FzZUNvbnNvbGUuanMiLCJ0ZXN0cy9UZXN0Q2FzZVZpZXcuanMiLCJ0ZXN0cy9UZXN0Q2FzZVZpZXdNb2RlbC5qcyIsInRlc3RzL1Rlc3RiZW5jaFZpZXcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vQ3NzL0Nzc0lubGluZVJ1bGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vQ3NzL0Nzc1J1bGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vQ3NzL0Nzc1J1bGVDb250cmFjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9Dc3MvQ3NzVmFyaWFibGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vQ3NzL0dldENzc1J1bGVzSW5FbGVtZW50XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0h0bWwvQ3JlYXRlRWxlbWVudFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sL0RlbGV0ZU5vZGVDb250ZW50XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0h0bWwvRWxlbWVudFR5cGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbC9Fc2NhcGVIdG1sXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0h0bWwvRmluZEluZGV4SW5QYXJlbnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbC9Gb3JtRmllbGRWYWx1ZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sL0V4dHJhY3ROb2RlQ29udGVudFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sL1F1ZXJ5U2VsZWN0b3JOb2RlTGlzdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sL1ZhbGlkYXRlVW5pcXVlRG9tSWRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0h0bWxDb21wb25lbnQvQm91bmRDb21wb25lbnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbENvbXBvbmVudC9Db21wb25lbnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbENvbXBvbmVudC9Db21wb25lbnRNYXBcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbENvbXBvbmVudC9PcHRpb25zL0lFeGlzdGluZ0VsZW1lbnRPcHRpb25zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL0h0bWxDb21wb25lbnQvT3B0aW9ucy9JSW5uZXJIdG1sT3B0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sQ29tcG9uZW50L09wdGlvbnMvSUV4aXN0aW5nTG9va3VwT3B0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9IdG1sQ29tcG9uZW50L09wdGlvbnMvSU91dGVySHRtbE9wdGlvbnNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vSHRtbENvbXBvbmVudC9PcHRpb25zL0lDb21wb25lbnRCaW5kaW5nT3B0aW9uc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9PYnNlcnZhYmxlL0lPYnNlcnZhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL09ic2VydmFibGUvT2JzZXJ2YWJsZUFzc2lnblwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9PYnNlcnZhYmxlL09ic2VydmFibGVCYXNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL09ic2VydmFibGUvT2JzZXJ2YWJsZVByb3BlcnR5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL09ic2VydmFibGUvT2JzZXJ2YWJsZVByb3h5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL09ic2VydmFibGUvT2JzZXJ2YWJsZVN0YXRlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1JvdXRlci9QYWdlUm91dGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1JvdXRlci9BZHZhbmNlZFBhZ2VSb3V0ZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vU3lzdGVtL0FzeW5jL0R5bmFtaWNXZWJXb3JrZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vU3lzdGVtL0FzeW5jL0RlZmVycmVkUHJvbWlzZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vQXN5bmMvRGVsYXlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vU3lzdGVtL0FzeW5jL1JlcGVhdGFibGVQcm9taXNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9Db2xsZWN0aW9ucy9BcnJheVV0aWxpdGllc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vQ29sbGVjdGlvbnMvT3JkZXJCeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vRXZlbnRIYW5kbGVyL0FycmF5Q2hhbmdlZEV2ZW50QXJnc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vRXZlbnRIYW5kbGVyL0RlbGVnYXRlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9FdmVudEhhbmRsZXIvRXZlbnRIYW5kbGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9FdmVudEhhbmRsZXIvUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9UeXBlcy9Db25zdHJ1Y3RhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9UeXBlcy9LZXl3b3JkQXJndW1lbnRzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9UeXBlcy9Ob25lVHlwZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vVXRpbGl0eS9Bc3NlcnRcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vU3lzdGVtL1V0aWxpdHkvQ2xvbmVEZWVwXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9VdGlsaXR5L0Nsb25lT2JqZWN0XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9VdGlsaXR5L0VsdmlzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL1N5c3RlbS9VdGlsaXR5L0lzSW50ZWdlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vVXRpbGl0eS9Jc1ByaW1pdGl2ZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vVXRpbGl0eS9HZXRVbmlxdWVJZFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9TeXN0ZW0vVXRpbGl0eS9PYmplY3RGdWxsQXNzaWduXCIpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ3NzUnVsZV8xID0gcmVxdWlyZShcIi4vQ3NzUnVsZVwiKTtcbi8qKlxuICogQSBzaW1wbGUsIGRlZmF1bHQgQ3NzIFJ1bGUgdGhhdCBpcyB3aXRoIGFuIGlubGluZSBpbml0aWFsaXplciBpbiB0aGUgY29uc3RydWN0b3IsIHVzZWZ1bCBmb3IgcXVpY2sgYW5kIGRpcnR5IGlubGluZSBjbGFzc2VzLlxuICovXG5jbGFzcyBDc3NJbmxpbmVSdWxlIGV4dGVuZHMgQ3NzUnVsZV8xLkNzc1J1bGUge1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBpbml0aWFsLCBwYXJlbnQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50KTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBpbml0aWFsKTtcbiAgICAgICAgdGhpcy5zZWxlY3RvciQgPSBzZWxlY3RvcjtcbiAgICB9XG59XG5leHBvcnRzLkNzc0lubGluZVJ1bGUgPSBDc3NJbmxpbmVSdWxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFbGVtZW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRWxlbWVudFR5cGVcIik7XG5jb25zdCBDcmVhdGVFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vSHRtbC9DcmVhdGVFbGVtZW50XCIpO1xuY29uc3QgQ29uc3RydWN0YWJsZV8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9UeXBlcy9Db25zdHJ1Y3RhYmxlXCIpO1xuY29uc3QgR2V0VW5pcXVlSWRfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVXRpbGl0eS9HZXRVbmlxdWVJZFwiKTtcbmNvbnN0IENzc1ZhcmlhYmxlXzEgPSByZXF1aXJlKFwiLi9Dc3NWYXJpYWJsZVwiKTtcbi8qKlxuICogQSBKYXZhc2NyaXB0IENTUyBydWxlLiBOb3RlIHRoZSBjYXBpdGFsaXphdGlvbi4gVGhpcyBpc24ndCB0aGUgc2FtZSBhcyBDU1NSdWxlLiBJJ20gY29uc2lkZXJpbmcgcmVuYW1pbmcgdGhpcyB0b1xuICogQ3NzSnNSdWxlIGJ1dCBJJ20gaG9waW5nIEkgdGhpbmsgdXAgc29tZXRoaW5nIGJldHRlci4gSXQgaGFzIHRvIGJlIG1vcmUgZ2VuZXJpYyB0aGFuIENzc0NsYXNzIGJlY2F1c2UsIHdlbGwsIHRoZXJlJ3NcbiAqIG1vcmUgdG8gQ1NTIHRoYW4gY2xhc3Mgc2VsZWN0b3JzLlxuICovXG5jbGFzcyBDc3NSdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgLyoqIFN0b3JpbmcgdGhpcyBzb21ld2hlcmUgb3RoZXIgdGhhbiB0aGUgSEVBRCB3b3VsZCBtYWtlIGl0IGVhc3kgdG8gZHJvcCB0aGUgc2hlZXQgb24gcGFnZSBjaGFuZ2UuICovXG4gICAgICAgIHRoaXMuc3R5bGVTaGVldFBhcmVudCQgPSBkb2N1bWVudC5oZWFkO1xuICAgICAgICB0aGlzLnN0eWxlU2hlZXRJZCQgPSBHZXRVbmlxdWVJZF8xLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgIHRoaXMuZXh0ZW5kcyQgPSBbXTtcbiAgICAgICAgdGhpcy5uZXN0ZWQkID0gW107XG4gICAgICAgIHRoaXMucmV2ZXJ0JCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jb25zdHJ1Y3RlZCQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3JzJCA9IFtdO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnN0eWxlU2hlZXRQYXJlbnQkID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlciQocGFyZW50U2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jb25zdHJ1Y3RlZCQpIHtcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyLCB3ZSBjYW5ub3QgcmVhZCBwcm9wZXJ0aWVzIG9mIHRoaXMgaW4gdGhlIGNvbnN0cnVjdG9yLCBiZWNhdXNlIHRoZWlyIHBvcHVsYXRpb24gaXMgZW1pdHRlZFxuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHN1cGVyKCkgY2FsbC4gQnV0IHdlIGRvbid0IHdhbnQgdG8gY2xvbmUgdGhpcyBvYmplY3QgYW5kIHJlcGVhdCB0aGlzIGV2ZXJ5IHRpbWUgaXQncyByZW5kZXJlZC5cbiAgICAgICAgICAgIHRoaXMuX2NvbnN0cnVjdGVkJCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXZlcnQkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGwgPSBcImluaXRpYWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZENsYXNzJCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubmVzdGVkJCkge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLm5lc3RlZCQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkJCA9IFt0aGlzLm5lc3RlZCRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIG5lc3RdIG9mIHRoaXMubmVzdGVkJC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKENvbnN0cnVjdGFibGVfMS5jb25zdHJ1Y3RvclR5cGVHdWFyZChuZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQkW2lkeF0gPSBuZXcgbmVzdCh0aGlzLnN0eWxlU2hlZXRQYXJlbnQkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2J1aWxkU2VsZWN0b3JzJChwYXJlbnRTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBjcmVhdGVzIGEgc2VwYXJhdGUgc3R5bGUgZWxlbWVudCBmb3IgZWFjaCBydWxlLiBUaGF0IG1pZ2h0IHNlZW0gcHJldHR5IGV4Y2Vzc2l2ZSwgYnV0IGl0J3MgdGhlIG9ubHkgd2F5XG4gICAgICAgIC8vIHRvIG1ha2UgaXQgZWFzeSB0byB1cGRhdGUgcnVsZXMuIFRoZSBBUEkgZm9yIGRlYWxpbmcgd2l0aCBDU1MgaW4gSFRNTDUgaXMgTkFBQUFBQUFTVFkuXG4gICAgICAgIGxldCBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlU2hlZXRQYXJlbnQkLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5zdHlsZVNoZWV0SWQkKTtcbiAgICAgICAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0UGFyZW50JC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlRWxlbWVudCA9IHRoaXMuc3R5bGVTaGVldFBhcmVudCQuYXBwZW5kQ2hpbGQoQ3JlYXRlRWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQoRWxlbWVudFR5cGVfMS5lbGVtZW50VHlwZS5IVE1MU3R5bGVFbGVtZW50LCB7IGlkOiB0aGlzLnN0eWxlU2hlZXRJZCQgfSkpO1xuICAgICAgICBjb25zdCBzaGVldCA9IHN0eWxlRWxlbWVudC5zaGVldDtcbiAgICAgICAgdGhpcy5fYnVpbGRSdWxlJChzaGVldCk7XG4gICAgICAgIGlmICh0aGlzLm5lc3RlZCQpIHtcbiAgICAgICAgICAgIC8vIFdlIHByZXZpb3VzbHkgbWFkZSB0aGlzIGFuIGFycmF5IG9mIGNvbnN0cnVjdGVkIHR5cGVzLlxuICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0IG9mIHRoaXMubmVzdGVkJCkge1xuICAgICAgICAgICAgICAgIG5lc3Quc3R5bGVTaGVldFBhcmVudCQgPSB0aGlzLnN0eWxlU2hlZXRQYXJlbnQkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc2VsIG9mIHRoaXMuX3NlbGVjdG9ycyQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmVzdC5yZW5kZXIkKHNlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmUkKCkge1xuICAgICAgICBjb25zdCBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlU2hlZXRQYXJlbnQkLnF1ZXJ5U2VsZWN0b3IoJyMnICsgdGhpcy5zdHlsZVNoZWV0SWQkKTtcbiAgICAgICAgaWYgKHN0eWxlRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zdHlsZVNoZWV0UGFyZW50JC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudCBcIm11bHRpcGxlIGluaGVyaXRhbmNlXCIuXG4gICAgICpcbiAgICAgKiBUaGlzIGNoZWNrcyBvbmx5IENTUyBwcm9wZXJ0aWVzLiBJZiB5b3UgaW5oZXJpdCBmcm9tIG90aGVyIENzc1J1bGUgY2xhc3NlcyB0aGF0XG4gICAgICogdGhlbXNlbHZlcyBoYXZlIGV4dGVuZHMkIHNldCwgdGhvc2UgYXJlIG5vdCBjaGVja2VkLiBJIGRvbid0IHRoaW5rIHRoZXJlJ3MgZW5vdWdoXG4gICAgICoganVzdGlmaWNhdGlvbiB0byBicmluZyByZWN1cnNpb24gaW50byB0aGlzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHByaW9yaXR5IGlzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2Ygbm9ybWFsIGluaGVyaXRhbmNlIHByaW9yaXR5LlxuICAgICAqIE5vcm1hbGx5LCB3aGVuIGxvb2tpbmcgZm9yIGEgcHJvcGVydHksIHRoZSBydW50aW1lIHRyYXZlcnNlcyB0aGUgaW5oZXJpdGFuY2UgdHJlZVxuICAgICAqIGFuZCB1c2VzIHRoZSBmaXJzdCBvY2N1cnJlbmNlLiBJbiBDU1MsIHRoZSBMQVNUIG9jY3VyYW5jZSB0YWtlcyBwcmlvcml0eS5cbiAgICAgKi9cbiAgICBfZXh0ZW5kQ2xhc3MkKCkge1xuICAgICAgICBpZiAoIXRoaXMuZXh0ZW5kcyQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5leHRlbmRzJCkpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kcyQgPSBbdGhpcy5leHRlbmRzJF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBleCBvZiB0aGlzLmV4dGVuZHMkKSB7XG4gICAgICAgICAgICBsZXQgdHJhaXRTb3VyY2U7XG4gICAgICAgICAgICBpZiAoQ29uc3RydWN0YWJsZV8xLmNvbnN0cnVjdG9yVHlwZUd1YXJkKGV4KSkge1xuICAgICAgICAgICAgICAgIHRyYWl0U291cmNlID0gbmV3IGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFpdFNvdXJjZSA9IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmFtZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoZmluZFByb3BlcnR5TmFtZXModHJhaXRTb3VyY2UpKSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgbmFtZXMgd2l0aCBzcGVjaWFsIG1lYW5pbmdcbiAgICAgICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHRyYWl0U291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkU2VsZWN0b3JzJChwYXJlbnRTZWxlY3Rvcikge1xuICAgICAgICBwYXJlbnRTZWxlY3RvciA9IChwYXJlbnRTZWxlY3RvciB8fCAnJyk7XG4gICAgICAgIC8vIElmIHNjb3BlRWxlbWVudCQgaXMgc2V0LCA8c3R5bGUgc2NvcGVkPiBpcyBzaW11bGF0ZWQgaW4gYSBoYWNreSB3YXkuIEl0IGdlbmVyYXRlcyBhbiByYW5kb20gY2xhc3MgbmFtZSBhbmQgYWRkc1xuICAgICAgICAvLyB0aGF0IHRvIGJvdGggdGhlIHNlbGVjdG9yIGFuZCB0aGUgZWxlbWVudC4gVGhpcyBzaW1pbGFyIHRvIHRoZSB3YXkgQ1NTIE1vZHVsZXMgYW5kIEFuZ3VsYXIgZG8gaXQsIGV4Y2VwdCB0aGVcbiAgICAgICAgLy8gcmFuZG9tIHNlbGVjdG9yIGNvbWVzIGR1cmluZyBydW50aW1lIGluc3RlYWQgb2YgYSBjdXN0b20gYnVpbGQgcHJvY2Vzcy5cbiAgICAgICAgaWYgKHRoaXMuc2NvcGVFbGVtZW50JCAmJiAhdGhpcy5fZmFrZVNjb3BlQ2xhc3MkKSB7XG4gICAgICAgICAgICB0aGlzLl9mYWtlU2NvcGVDbGFzcyQgPSB0aGlzLl9mYWtlU2NvcGVDbGFzcyQgfHwgJ3Njb3BlLScgKyBHZXRVbmlxdWVJZF8xLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICB0aGlzLnNjb3BlRWxlbWVudCQuY2xhc3NMaXN0LmFkZCh0aGlzLl9mYWtlU2NvcGVDbGFzcyQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHNlbCBvZiB0aGlzLnNlbGVjdG9yJC5zcGxpdCgnLCcpLm1hcChtID0+IG0udHJpbSgpKSkge1xuICAgICAgICAgICAgc2VsID0gKHNlbCB8fCAnJykucmVwbGFjZSgnJicsICcnKTsgLy8gQW1wZXJzYW5kIHRlbGxzIHVzIHdoZXJlIHRvIHN0YXJ0IChhbGxvd3MgYSBzcGFjZSkgYnV0IGl0J3MgaW52YWxpZCBDU1NcbiAgICAgICAgICAgIGlmICh0aGlzLl9mYWtlU2NvcGVDbGFzcyQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RvcnMkLnB1c2gocGFyZW50U2VsZWN0b3IgKyAnLicgKyB0aGlzLl9mYWtlU2NvcGVDbGFzcyQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjZSBhbiBpZCBsaWtlIFwiZGl2LmF1dG9nZW4gLm90aGVyY2xhc3MsIC5hdXRvZ2VuIGRpdiAub3RoZXJjbGFzc1wiXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdvcmRzID0gc2VsLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmRzWzBdID0gcGFyZW50U2VsZWN0b3IgKyB3b3Jkc1swXSArICcuJyArIHRoaXMuX2Zha2VTY29wZUNsYXNzJDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3JzJC5wdXNoKHdvcmRzLmpvaW4oJyAnKS50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBDU1Mgc2VsZWN0b3IgdGhhdCBtYXRjaGVzIGFuIGl0ZW0gYW5kIGl0cyBjaGlsZHJlbi4gSXQgdGFrZXMgMiBydWxlcy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3JzJC5wdXNoKChwYXJlbnRTZWxlY3RvciArICcuJyArIHRoaXMuX2Zha2VTY29wZUNsYXNzJCArICcgJyArIHNlbCkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghc2VsKSB7XG4gICAgICAgICAgICAgICAgLy8gQSBibGFuayBzZWxlY3RvciB3aWxsIGZhaWxcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0b3JzJC5wdXNoKHBhcmVudFNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9ycyQucHVzaCgnYm9keScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdG9ycyQucHVzaChwYXJlbnRTZWxlY3RvciArIHNlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2J1aWxkUnVsZSQoc2hlZXQpIHtcbiAgICAgICAgY29uc3QgcnVsZVRleHQgPSBbXTtcbiAgICAgICAgY29uc3QgdmFyaWFibGVzID0gW107XG4gICAgICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGZpbmRQcm9wZXJ0eU5hbWVzKHRoaXMpKSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG5hbWVzKSB7XG4gICAgICAgICAgICAvLyBGaWx0ZXIgb3V0IG5hbWVzIHdpdGggc3BlY2lhbCBtZWFuaW5nXG4gICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCckJykgfHwgIXRoaXNba2V5XSB8fCB0eXBlb2YgdGhpc1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiBUeXBlc2NyaXB0IHdhcyB3b3JraW5nIGNvcnJlY3RseSwgd2Uga25vdyB0aGF0IGFsbCBwcm9wZXJ0aWVzIHRoYXQgZG9uJ3QgZW5kIGluICQgYXJlIFJ1bGVWYWx1ZSB0eXBlLlxuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpc1trZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcnVsZVRleHQucHVzaChgJHtrZXl9OiAke3ZhbH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIENzc1ZhcmlhYmxlXzEuQ3NzVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICB2YXJpYWJsZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIHJ1bGVUZXh0LnB1c2goYCR7a2V5fTogdmFyKC0tJHt2YWwubmFtZX0pYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXN0ZWQgcHJvcGVydGllcywgd2hpY2ggZXh0ZW5kIHRoZSBrZXkgYW5kIGFkZCBtb3JlIHJ1bGVzXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBucCBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5wLmVuZHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZwID0gdmFsW25wXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2cCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVUZXh0LnB1c2goYCR7a2V5fS0ke25wfTogJHt2cH1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHZwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVUZXh0LnB1c2goYCR7a2V5fS0ke25wfTogdmFyKC0tJHt2YWwubmFtZX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbFNlbGVjdG9yID0gdGhpcy5fc2VsZWN0b3JzJC5qb2luKCcsICcpO1xuICAgICAgICBjb25zdCBmdWxsVGV4dCA9IHJ1bGVUZXh0LmpvaW4oJzsgXFxuJyk7XG4gICAgICAgIGlmICghZnVsbFRleHQpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYE5vIENTUyBwcm9wZXJ0aWVzIGRlZmluZWQgZm9yIHJ1bGU6ICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBvbiAke2Z1bGxTZWxlY3Rvcn0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZ1bGxSdWxlID0gYCR7ZnVsbFNlbGVjdG9yfSB7IFxcbiR7ZnVsbFRleHR9OyBcXG59YDtcbiAgICAgICAgaWYgKHRoaXMubWVkaWEkKSB7XG4gICAgICAgICAgICBmdWxsUnVsZSA9IGBAbWVkaWEgJHt0aGlzLm1lZGlhJH0geyBcXG4ke2Z1bGxSdWxlfVxcbn1gO1xuICAgICAgICB9XG4gICAgICAgIHNoZWV0Lmluc2VydFJ1bGUoZnVsbFJ1bGUsIDApO1xuICAgICAgICAvLyBBZGQgYWxsIHRoZSB2YXJpYWJsZSB2YWx1ZXNcbiAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFyaWFibGVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJUZXh0ID0gYCR7di5zY29wZX0geyAtLSR7di5uYW1lfTogJHt2LnZhbHVlfTsgfWA7XG4gICAgICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHZhclRleHQsIGkpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Dc3NSdWxlID0gQ3NzUnVsZTtcbmZ1bmN0aW9uIGZpbmRQcm9wZXJ0eU5hbWVzKG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5wdXNoKC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZmlsdGVyKGYgPT4gZiAhPT0gJ2NvbnN0cnVjdG9yJykpO1xuICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgaWYgKHByb3RvICYmIHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKC4uLmZpbmRQcm9wZXJ0eU5hbWVzKHByb3RvKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGhpcyB0eXBlIGlzIGhlcmUgZm9yIGEgYnVsbHNoaXQgcmVhc29uLCB3aGljaCBpcyB0aGF0IGlmIHlvdSB3YW50IHRvIHJlcXVpcmUgdmFsdWVzIHRvIGJlIGFsbCBzdHJpbmdzLCB0aGlzIGNvcHlwYXN0YVxuICogbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgZGVmaW5pdGlvbiBvZiB0aGUgY2xhc3MuIFRoYXQncyBnb2luZyBmYXIgYmV5b25kIHRpbWUgY2hlY2tpbmcuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE1MzAwIChub3QganVzdCBpbnRlcmZhY2VzKVxuICovXG5jbGFzcyBDc3NTaW1wbGVSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsKSB7XG4gICAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGluaXRpYWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Dc3NTaW1wbGVSdWxlID0gQ3NzU2ltcGxlUnVsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29uc3RydWN0YWJsZV8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9UeXBlcy9Db25zdHJ1Y3RhYmxlXCIpO1xuY2xhc3MgQ3NzU3R5bGVTaGVldCB7XG4gICAgY29uc3RydWN0b3IocnVsZXMsIHBhcmVudCkge1xuICAgICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgICAgIGlmIChydWxlcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKENvbnN0cnVjdGFibGVfMS5jb25zdHJ1Y3RvclR5cGVHdWFyZChydWxlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGVzLnB1c2gobmV3IHJ1bGUocGFyZW50KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBydWxlLnN0eWxlU2hlZXRQYXJlbnQkID0gcGFyZW50IHx8IHJ1bGUuc3R5bGVTaGVldFBhcmVudCQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5ydWxlcykge1xuICAgICAgICAgICAgcnVsZS5yZW5kZXIkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgdGhpcy5ydWxlcykge1xuICAgICAgICAgICAgcnVsZS5yZW1vdmUkKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNzc1N0eWxlU2hlZXQgPSBDc3NTdHlsZVNoZWV0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFVzZSB0byBkZWZpbmUgYSBDU1MgY3VzdG9tIHByb3BlcnR5LlxuICovXG5jbGFzcyBDc3NWYXJpYWJsZSB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsdWUsIHNjb3BlID0gJzpyb290Jykge1xuICAgICAgICB0aGlzLnNjb3BlID0gJzpyb290JztcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxufVxuZXhwb3J0cy5Dc3NWYXJpYWJsZSA9IENzc1ZhcmlhYmxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBnZXRDc3NSdWxlc0luRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yIChjb25zdCBzdHlsZSBvZiBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJykpIHtcbiAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIHN0eWxlLnNoZWV0LmNzc1J1bGVzKSB7XG4gICAgICAgICAgICAvLyBBIHZlcnkgbWluaW11bSBvZiBwcmV0dHkgcHJpbnRpbmcuIEkgbWF5IGJlZWYgaXQgdXAgbGF0ZXIuXG4gICAgICAgICAgICByZXN1bHQucHVzaChydWxlLmNzc1RleHQucmVwbGFjZSgvXFx7L2csICdcXG4gICAge1xcbiAgICcpLnJlcGxhY2UoLzsvZywgJztcXG4gICAgJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbignXFxuJyk7XG59XG5leHBvcnRzLmdldENzc1J1bGVzSW5FbGVtZW50ID0gZ2V0Q3NzUnVsZXNJbkVsZW1lbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVGhpcyBzY3JpcHQgY29udGFpbnMgZXh0ZW5zaW9ucyB0byBwcm92aWRlIGFkZGl0aW9uYWwgZnVuY3Rpb25zIHVzZWQgYnkgSWNoaWdvLlxuICogSW4geW91ciBtYWluIHByb2Nlc3MsIGltcG9ydCB0aGlzIHNjcmlwdCAoaW1wb3J0ICcvcGF0aC90by9JY2hpZ28vSWNoaWdvRXh0ZW5zaW9uTG9hZGVyJykgdG8gYWRkXG4gKiB0aGVzZSBleHRlbnNpb25zIHRvIHByb3RvdHlwZXMuXG4gKi9cbnJlcXVpcmUoXCIuL0V4dGVuc2lvbnMvT2JzZXJ2YWJsZUV4dGVuc2lvbnNcIik7XG5yZXF1aXJlKFwiLi9FeHRlbnNpb25zL0NvbXBvbmVudEV4dGVuc2lvbnNcIik7XG5yZXF1aXJlKFwiLi9FeHRlbnNpb25zL0VsZW1lbnRFeHRlbnNpb25zXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBJQ29tcG9uZW50QmluZGluZ09wdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9IdG1sQ29tcG9uZW50L09wdGlvbnMvSUNvbXBvbmVudEJpbmRpbmdPcHRpb25zXCIpO1xuY29uc3QgQm91bmRDb21wb25lbnRfMSA9IHJlcXVpcmUoXCIuLi9IdG1sQ29tcG9uZW50L0JvdW5kQ29tcG9uZW50XCIpO1xuY29uc3QgQ29tcG9uZW50TWFwXzEgPSByZXF1aXJlKFwiLi4vSHRtbENvbXBvbmVudC9Db21wb25lbnRNYXBcIik7XG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29tcG9uZW50ID0gZnVuY3Rpb24gX2dldENvbXBvbmVudCgpIHtcbiAgICByZXR1cm4gQ29tcG9uZW50TWFwXzEuQ29tcG9uZW50TWFwLmNvbXBvbmVudHMuZ2V0KHRoaXMpO1xufTtcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5iaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gX2JpbmQodmlld01vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZENvbXBvbmVudF8xLkJvdW5kQ29tcG9uZW50KHZpZXdNb2RlbCwgbmV3IElDb21wb25lbnRCaW5kaW5nT3B0aW9uc18xLkV4aXN0aW5nRWxlbWVudEJpbmRpbmdPcHRpb25zKHsgZWxlbWVudDogdGhpcyB9KSk7XG59O1xuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRlbGV0ZUNvbXBvbmVudCA9IGZ1bmN0aW9uIF9kZWxldGVDb21wb25lbnQoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gQ29tcG9uZW50TWFwXzEuQ29tcG9uZW50TWFwLmNvbXBvbmVudHMuZ2V0KHRoaXMpO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vdCBhIGNvbXBvbmVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBCb3VuZENvbXBvbmVudF8xLkJvdW5kQ29tcG9uZW50KSB7XG4gICAgICAgIGNvbXBvbmVudC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSB8fCBkb2N1bWVudDtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDcmVhdGVFbGVtZW50XzEgPSByZXF1aXJlKFwiLi4vSHRtbC9DcmVhdGVFbGVtZW50XCIpO1xuLyoqXG4gKiBTZXQgdGhlIHBhcmVudCBmb3IgYW4gZWxlbWVudCAoam9pbiB0aGUgcGFyZW50J3MgZmFtaWx5IGFzIGEgbmV3IGNoaWxkKSwgdGhlIG9wcG9zaXRlIG9mIGFwcGVuZENoaWxkLiBGbHVlbnQsIGZvciBjaGFpbmluZywgc29cbiAqIGl0J3Mgbm90IGEgcGVyZmVjdCBhbmFsb2cgKGFwcGVuZENoaWxkIHJldHVybnMgdGhlIGFyZ3VtZW50IHdoaWxlIHRoaXMgcmV0dXJucyB0aGUgZXh0ZW5kZWQgb2JqZWN0IC4uLiB0aG91Z2ggYm90aCBhcmUgdGhlIGNoaWxkKS5cbiAqL1xuSFRNTEVsZW1lbnQucHJvdG90eXBlLmFwcGVuZFRvUGFyZW50ID0gZnVuY3Rpb24gX2FwcGVuZFRvUGFyZW50KHBhcmVudCkge1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIEZsdWVudCB2ZXJzaW9uIG9mIGFwcGVuZENoaWxkLCB3aGljaCByZXR1cm5zIHRoZSBwYXJlbnQsIG5vdCB0aGUgY2hpbGQgKHRoZSBhcmd1bWVudCkuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZEZsdWVudCA9IGZ1bmN0aW9uIF9hcHBlbmRDaGlsZEZsdWVudChjaGlsZCkge1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQWRkIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50IGl0ZW0sIGF0IHRoZSBzYW1lIGxldmVsLiBOb3QgZmx1ZW50LCBzbyB0aGlzIGlzIHRoZSBzYW1lIHBhdHRlcm4gYXMgYXBwZW5kQ2hpbGQuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRTaWJsaW5nID0gZnVuY3Rpb24gX2FwcGVuZFNpYmxpbmcobmV4dCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSB8fCBkb2N1bWVudDtcbiAgICByZXR1cm4gcGFyZW50LmFwcGVuZENoaWxkKG5leHQpO1xufTtcbi8qKlxuICogQWRkIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBjdXJyZW50IGl0ZW0sIGF0IHRoZSBzYW1lIGxldmVsLiBGbHVlbnQuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hcHBlbmRTaWJsaW5nRmx1ZW50ID0gZnVuY3Rpb24gX2FwcGVuZFNpYmxpbmdGbHVlbnQobmV4dCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSB8fCBkb2N1bWVudDtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobmV4dCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSBlbGVtZW50LiBOb3QgZmx1ZW50LCBzbyB0aGlzIGlzIHRoZSBzYW1lIHBhdHRlcm4gYXMgYXBwZW5kQ2hpbGQuIFRoZXJlIGlzIG5vIGZsdWVudCB2ZXJzaW9uIGJlY2F1c2VcbiAqIHRoaXMgaXMgZGVsZXRpbmcgdGhlIGV4dGVuZGVkIG9iamVjdC5cbiAqL1xuSFRNTEVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoID0gZnVuY3Rpb24gX3JlcGxhY2VXaXRoKG5ld0VsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGUgfHwgZG9jdW1lbnQ7XG4gICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdFbGVtZW50LCB0aGlzKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG4vKipcbiAqIFN3YXAgdHdvIGVsZW1lbnRzIGZyb20gdGhlaXIgcGxhY2VzIGluIHRoZSBET00sIHJldHVybmluZyB0aGUgYXJndW1lbnQuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5zd2FwID0gZnVuY3Rpb24gX3N3YXAoZWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSB8fCBkb2N1bWVudDtcbiAgICBjb25zdCBlbGVtZW50UGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlIHx8IGRvY3VtZW50O1xuICAgIGNvbnN0IHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIGVsZW1lbnRQYXJlbnQucmVwbGFjZUNoaWxkKHBsYWNlSG9sZGVyLCBlbGVtZW50KTtcbiAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVsZW1lbnQsIHRoaXMpO1xuICAgIGVsZW1lbnRQYXJlbnQucmVwbGFjZUNoaWxkKHRoaXMsIHBsYWNlSG9sZGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgZG9jdW1lbnQucmVtb3ZlQ2hpbGQgdGhhdCB1c2VzIHRoZSBzYW1lIEFQSSBhcyB0aGUgb3RoZXIgZnVuY3Rpb25zIGhlcmUuXG4gKiBJbmNsdWRlZCBmb3IgdGhlIHNha2Ugb2YgY29uc2lzdGVuY3kuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5leHRyYWN0ID0gZnVuY3Rpb24gX2V4dHJhY3QoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlIHx8IGRvY3VtZW50O1xuICAgIHJldHVybiBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG59O1xuLyoqXG4gKiBGbHVlbnQgdmVyc2lvbiBvZiBhZGRFdmVudExpc3RlbmVyLlxuICovXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lckZsdWVudCA9IGZ1bmN0aW9uIF9hZGRFdmVudExpc3RlbmVyRmx1ZW50KGV2ZW50VHlwZSwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBldmVudCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBGbHVlbnQgc3R5bGUgYWRkZXIuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hZGRTdHlsZSA9IGZ1bmN0aW9uIF9hZGRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBGbHVlbnQgY2xhc3MgYWRkZXIuXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIF9hZGRDbGFzcyhjbGFzc05hbWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNsYXNzTmFtZXMpKSB7XG4gICAgICAgIGNsYXNzTmFtZXMgPSBbY2xhc3NOYW1lc107XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gYWxzbyBhbGxvdyBjbGFzc2VzIGluIHRoZSBcImNsYXNzMSBjbGFzczJcIiBmb3JtYXRcbiAgICBmb3IgKGNvbnN0IGMgb2YgW10uY29uY2F0KC4uLmNsYXNzTmFtZXNcbiAgICAgICAgLm1hcChxID0+IHEuc3BsaXQoJyAnKSlcbiAgICAgICAgLmZpbHRlcihxID0+IHEpKSkge1xuICAgICAgICB0aGlzLmNsYXNzTGlzdC5hZGQoYyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQgdXNpbmcgdGhlIGNyZWF0ZUVsZW1lbnQgaGVscGVyIGZ1bmN0aW9uIGFuZCBhZGQgaXQgdG8gdGhlIGZyYWdtZW50LCByZXR1cm5pbmcgdGhlIG5ldyBlbGVtZW50LlxuICovXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBDcmVhdGVFbGVtZW50XzEuY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBwcm9wZXJ0aWVzKTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuIGVsZW1lbnQgdXNpbmcgdGhlIGNyZWF0ZUVsZW1lbnQgaGVscGVyIGZ1bmN0aW9uIGFuZCBhZGQgaXQgdG8gdGhlIGZyYWdtZW50LiBGbHVlbnQgdmVyc2lvbiwgc28gaXQncyBlYXN5IHRvIHF1aWNrbHkgYWRkXG4gKiBhIGJ1bmNoIG9mIGVsZW1lbnRzIHRvIHRoZSBmcmFnbWVudC5cbiAqL1xuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudEZsdWVudCA9IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50Rmx1ZW50KHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gQ3JlYXRlRWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQodGFnTmFtZSwgcHJvcGVydGllcyk7XG4gICAgdGhpcy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG4vKipcbiAqIFRha2UgYSBkb2N1bWVudCBmcmFnbWVudCBhbmQgYWRkIGl0cyBjb250ZW50cyB0byBhIHBhcmVudCBlbGVtZW50LiBDYW5ub3QgYmUgZmx1ZW50IGJlY2F1c2UgYXQgdGhpcyBwb2ludCwgdGhlIGZyYWdtZW50IGlzIGVtcHR5IGFuZFxuICogcHJldHR5IHVzZWxlc3MsIHNvIHRoaXMgcmV0dXJucyB0aGUgcGFyZW50IGFyZ3VtZW50IChhcyBnb29kIGFzIGFueSBvdGhlciBvcHRpb24pLlxuICovXG5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5hcHBlbmRUb1BhcmVudCA9IGZ1bmN0aW9uIF9hcHBlbmRUb1BhcmVudChwYXJlbnQpIHtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgcmV0dXJuIHBhcmVudDtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE9ic2VydmFibGVQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL09ic2VydmFibGUvT2JzZXJ2YWJsZVByb3BlcnR5XCIpO1xuLyoqXG4gKiBRdWlja2x5IGNvbnZlcnQgYW4gb2JqZWN0IHRvIGEgT2JzZXJ2YWJsZVByb3BlcnR5LlxuICovXG5PYmplY3QucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUHJvcGVydHlfMS5PYnNlcnZhYmxlUHJvcGVydHkodGhpcywgeyBuYW1lIH0pO1xufTtcbi8qKlxuICogUXVpY2tseSBjb252ZXJ0IGEgc3RyaW5nIHRvIGFuIE9ic2VydmFibGVQcm9wZXJ0eS5cbiAqL1xuU3RyaW5nLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVByb3BlcnR5XzEuT2JzZXJ2YWJsZVByb3BlcnR5KHRoaXMsIHsgbmFtZSB9KTtcbn07XG4vKipcbiAqIFF1aWNrbHkgY29udmVydCBhIG51bWJlciB0byBhIE9ic2VydmFibGVQcm9wZXJ0eS5cbiAqL1xuTnVtYmVyLnByb3RvdHlwZS50b09ic2VydmFibGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVByb3BlcnR5XzEuT2JzZXJ2YWJsZVByb3BlcnR5KHRoaXMsIHsgbmFtZSB9KTtcbn07XG4vKipcbiAqIFF1aWNrbHkgY29udmVydCBhIGJvb2wgdG8gYSBPYnNlcnZhYmxlUHJvcGVydHkuXG4gKi9cbkJvb2xlYW4ucHJvdG90eXBlLnRvT2JzZXJ2YWJsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUHJvcGVydHlfMS5PYnNlcnZhYmxlUHJvcGVydHkodGhpcywgeyBuYW1lIH0pO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgS2V5d29yZEFyZ3VtZW50c18xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9UeXBlcy9LZXl3b3JkQXJndW1lbnRzXCIpO1xuY29uc3QgRWxlbWVudFR5cGVfMSA9IHJlcXVpcmUoXCIuL0VsZW1lbnRUeXBlXCIpO1xuY29uc3QgRXh0cmFjdE5vZGVDb250ZW50XzEgPSByZXF1aXJlKFwiLi9FeHRyYWN0Tm9kZUNvbnRlbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIHByb3BlcnRpZXMgPSB7fSwgYXR0cmlidXRlcykge1xuICAgICh7IHRhZ05hbWUsIHByb3BlcnRpZXMgPSB7fSwgYXR0cmlidXRlcyB9ID0gS2V5d29yZEFyZ3VtZW50c18xLkt3YXJnLnBhcnNlQXJncyh7IHRhZ05hbWUsIHByb3BlcnRpZXMsIGF0dHJpYnV0ZXMgfSkpOyAvLyBrd2FyZ2xpbmVcbiAgICAvLyBBbGxvdyBhdHRyaWJ1dGVzIHRvIGJlIHNlbnQgb24gcHJvcGVydGllcywgcHJvdmlkaW5nIGEgY2xlYW5lciBpbnRlcmZhY2UuXG4gICAgLy8gSXQgYWxsb3dzIHlvdSB0byBzZW5kIGNyZWF0ZUVsZW1lbnQoJ2RpdicsIHthdHRyaWJ1dGVzOiB7IGNsYXNzOiAnZm9vJyB9fSkgaW5zdGVhZCBvZiBjcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCB7IGNsYXNzOiAnZm9vJyB9KTtcbiAgICAvLyBBbm90aGVyIG9wdGlvbiBpcyB0byB1c2UgS3dhcmdzLCBidXQgbm90IGV2ZXJ5b25lIHdhbnRzIHRvLlxuICAgIGlmIChwcm9wZXJ0aWVzICYmICdhdHRyaWJ1dGVzJyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKGF0dHJpYnV0ZXMgfHwge30sIHByb3BlcnRpZXMuYXR0cmlidXRlcyk7XG4gICAgICAgIGRlbGV0ZSBwcm9wZXJ0aWVzLmF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGUodGFnTmFtZSwgcHJvcGVydGllcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50O1xuZnVuY3Rpb24gY3JlYXRlKHRhZywgcHJvcGVydGllcyA9IHt9LCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IChkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZykpO1xuICAgIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0cmlidXRlc1thdHRyXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRE9NIHByb3BlcnRpZXMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgYXR0cmlidXRlcywgYmVjYXVzZSBpbiBzb21lIGNhc2VzLCB0aGV5IG92ZXJyaWRlIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIFF1aWNrIGhlbHBlciB0byBjcmVhdGUgSFRNTCBmcm9tIGFueSBIVE1MIGVsZW1lbnQgcHJvdmlkZWQuXG4gKiBVc2UgbGlrZSBjb25zdCBkaXYgPSBjcmVhdGVIdG1sPEhUTUxEaXZFbGVtZW50PihcIjxkaXY+U29tZXRoaW5nPC9kaXY+XCIpIG9yIGNvbnN0IGN1c3RvbSA9IGNyZWF0ZUh0bWwoXCI8c29tZS10YWc+PC9zb21lLXRhZz5cIikuXG4gKiBJZiBtdWx0aXBsZSBlbGVtZW50cyBvciBhIHBsYWluIHRleHQgc3RyaW5nIHdpdGggbm8gSFRNTCBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBkaXYsIHNvIGl0IGNhbiBrZWVwXG4gKiByZXR1cm5pbmcgYW4gSFRNTEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSHRtbChodG1sLCBpbmxpbmUgPSBmYWxzZSkge1xuICAgIGxldCB3cmFwcGVyO1xuICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgd3JhcHBlciA9IHNwYW4oKGh0bWwgfHwgJycpLnRyaW0oKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3cmFwcGVyID0gZGl2KChodG1sIHx8ICcnKS50cmltKCkpO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHdyYXBwZXIuY2hpbGROb2RlcztcbiAgICAvLyBNdWx0aXBsZSBub2RlcywgcmV0dXJuIHRoZSB3cmFwcGluZyBkaXZcbiAgICAvLyBlLmcuIFwiVGhpcyBpcyBhIDxlbT50ZXN0PC9lbT5cIiBvciBcIjxkaXY+SGVsbG88L2Rpdj48ZGl2PldvcmxkPC9kaXY+XCJcbiAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICAvLyBJZiBqdXN0IGEgdGV4dG5vZGUgKG9yIGVtcHR5KSwgcmV0dXJuIGEgc3Bhbi4gVGV4dCBpcyBpbmNvbXBhdGlibGUgd2l0aCBIVE1MRWxlbWVudCBzbyBjYW4ndCByZXR1cm4gdGhhdFxuICAgIC8vIGUuZy4gXCJIZWxsbyB3b3JsZFwiXG4gICAgaWYgKCF3cmFwcGVyLmZpcnN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgIGlmIChpbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyOyAvLyBUaGlzIGlzIGEgc3BhblxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNwYW4od3JhcHBlci5pbm5lckhUTUwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEVsc2UgcmV0dXJuIHRoZSBzaW5nbGUgY2hpbGQuXG4gICAgLy8gZS5nLiBcIjxkaXY+PGRpdj5IZWxsbzwvZGl2PjxkaXY+V29ybGQ8L2Rpdj48L2Rpdj5cIlxuICAgIHJldHVybiB3cmFwcGVyLmZpcnN0RWxlbWVudENoaWxkO1xufVxuZXhwb3J0cy5jcmVhdGVIdG1sID0gY3JlYXRlSHRtbDtcbi8qKlxuICogUXVpY2sgaGVscGVyIHRvIGNyZWF0ZSBhIGRvY3VtZW50IGZyYWdtZW50IHdpdGggYW55IGh0bWwuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KGh0bWwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gZGl2KChodG1sIHx8ICcnKS50cmltKCkpO1xuICAgIHJldHVybiBFeHRyYWN0Tm9kZUNvbnRlbnRfMS5leHRyYWN0Tm9kZUNvbnRlbnQod3JhcHBlcik7XG59XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50ID0gY3JlYXRlRnJhZ21lbnQ7XG5mdW5jdGlvbiBkaXYoaHRtbE9yUHJvcGVydGllcyA9IFwiXCIsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcykge1xuICAgICh7IGh0bWxPclByb3BlcnRpZXMgPSBcIlwiLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzID0ge30sIGF0dHJpYnV0ZXMgfSA9IEtleXdvcmRBcmd1bWVudHNfMS5Ld2FyZy5wYXJzZUFyZ3MoeyBodG1sT3JQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzIH0pKTsgLy8ga3dhcmdsaW5lXG4gICAgcmV0dXJuIF9pbnRlcm5hbChFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCBodG1sT3JQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuZGl2ID0gZGl2O1xuZnVuY3Rpb24gc3BhbihodG1sT3JQcm9wZXJ0aWVzID0gXCJcIiwgcHJvcGVydGllc09yQXR0cmlidXRlcyA9IHt9LCBhdHRyaWJ1dGVzKSB7XG4gICAgKHsgaHRtbE9yUHJvcGVydGllcyA9IFwiXCIsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcyB9ID0gS2V5d29yZEFyZ3VtZW50c18xLkt3YXJnLnBhcnNlQXJncyh7IGh0bWxPclByb3BlcnRpZXMsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMgfSkpOyAvLyBrd2FyZ2xpbmVcbiAgICByZXR1cm4gX2ludGVybmFsKEVsZW1lbnRUeXBlXzEuZWxlbWVudFR5cGUuSFRNTFNwYW5FbGVtZW50LCBodG1sT3JQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMuc3BhbiA9IHNwYW47XG5mdW5jdGlvbiBwYXJhZ3JhcGgoaHRtbE9yUHJvcGVydGllcyA9IFwiXCIsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcykge1xuICAgICh7IGh0bWxPclByb3BlcnRpZXMgPSBcIlwiLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzID0ge30sIGF0dHJpYnV0ZXMgfSA9IEtleXdvcmRBcmd1bWVudHNfMS5Ld2FyZy5wYXJzZUFyZ3MoeyBodG1sT3JQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzIH0pKTsgLy8ga3dhcmdsaW5lXG4gICAgcmV0dXJuIF9pbnRlcm5hbChFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxQYXJhZ3JhcGhFbGVtZW50LCBodG1sT3JQcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbn1cbmV4cG9ydHMucGFyYWdyYXBoID0gcGFyYWdyYXBoO1xuZnVuY3Rpb24gYW5jaG9yKGh0bWxPclByb3BlcnRpZXMgPSBcIlwiLCBocmVmT3JQcm9wZXJ0aWVzID0ge30sIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcykge1xuICAgICh7IGh0bWxPclByb3BlcnRpZXMgPSBcIlwiLCBocmVmT3JQcm9wZXJ0aWVzID0ge30sIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcyB9ID0gS2V5d29yZEFyZ3VtZW50c18xLkt3YXJnLnBhcnNlQXJncyh7IGh0bWxPclByb3BlcnRpZXMsIGhyZWZPclByb3BlcnRpZXMsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMgfSkpOyAvLyBrd2FyZ2xpbmVcbiAgICBjb25zdCB0bXAgPSBfaW50ZXJuYWwoRWxlbWVudFR5cGVfMS5lbGVtZW50VHlwZS5IVE1MQW5jaG9yRWxlbWVudCwgaHRtbE9yUHJvcGVydGllcywgcHJvcGVydGllc09yQXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgaWYgKHR5cGVvZiBocmVmT3JQcm9wZXJ0aWVzID09PSAnc3RyaW5nJykge1xuICAgICAgICB0bXAuaHJlZiA9IFN0cmluZyhocmVmT3JQcm9wZXJ0aWVzIHx8ICcnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydHMuYW5jaG9yID0gYW5jaG9yO1xuZnVuY3Rpb24gYnV0dG9uKGh0bWxPclByb3BlcnRpZXMgPSBcIlwiLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzID0ge30sIGF0dHJpYnV0ZXMpIHtcbiAgICAoeyBodG1sT3JQcm9wZXJ0aWVzID0gXCJcIiwgcHJvcGVydGllc09yQXR0cmlidXRlcyA9IHt9LCBhdHRyaWJ1dGVzIH0gPSBLZXl3b3JkQXJndW1lbnRzXzEuS3dhcmcucGFyc2VBcmdzKHsgaHRtbE9yUHJvcGVydGllcywgcHJvcGVydGllc09yQXR0cmlidXRlcywgYXR0cmlidXRlcyB9KSk7IC8vIGt3YXJnbGluZVxuICAgIHJldHVybiBfaW50ZXJuYWwoRWxlbWVudFR5cGVfMS5lbGVtZW50VHlwZS5IVE1MQnV0dG9uRWxlbWVudCwgaHRtbE9yUHJvcGVydGllcywgcHJvcGVydGllc09yQXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmJ1dHRvbiA9IGJ1dHRvbjtcbi8vIENvbW1vbiBwcml2YXRlIGZ1bmN0aW9ucyBmb3Igb3ZlcmxvYWRzLiBQcmV2ZW50cyBsb3RzIG9mIGNvcHlwYXN0YS5cbi8vIFRoaXMgd29ya3MgZm9yIGV2ZXJ5dGhpbmcgYmVjYXVzZSBUeXBlU2NyaXB0IGlzIGtlZXBpbmcgdGhlIHR5cGVzIHZhbGlkLiBJbiBwdXJlIEpTLCBidWdzIGNvdWxkIGJlIGNyZWF0ZWQgKGZvciBleGFtcGxlLCBwYXNzaW5nIGFuIGlubmVyXG4vLyBlbGVtZW50IHRvIGEgcGFyYWdyYXBoIC4uLiBkaXNhbGxvd2VkIGJ5IFRTIGJ1dCB0aGUgY29kZSBpcyB0aGVyZSBpbiB0aGUgSlMpXG5mdW5jdGlvbiBfaW50ZXJuYWwodHlwZSwgaHRtbE9yUHJvcGVydGllcyA9IFwiXCIsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMgPSB7fSwgYXR0cmlidXRlcykge1xuICAgIGlmIChodG1sT3JQcm9wZXJ0aWVzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9vdnIxKHR5cGUsIGh0bWxPclByb3BlcnRpZXMsIHByb3BlcnRpZXNPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaHRtbE9yUHJvcGVydGllcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gX292cjModHlwZSwgaHRtbE9yUHJvcGVydGllcywgcHJvcGVydGllc09yQXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX292cjIodHlwZSwgU3RyaW5nKGh0bWxPclByb3BlcnRpZXMgfHwgJycpLCBwcm9wZXJ0aWVzT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfb3ZyMSh0eXBlLCBpbm5lckVsZW1lbnQsIHByb3BzLCBhdHRycykge1xuICAgIGNvbnN0IGUgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBhdHRycyk7XG4gICAgZS5hcHBlbmRDaGlsZChpbm5lckVsZW1lbnQpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX292cjIodHlwZSwgaW5uZXJIdG1sLCBwcm9wcywgYXR0cnMpIHtcbiAgICBwcm9wcyA9IHByb3BzIHx8IHt9O1xuICAgIHByb3BzLmlubmVySFRNTCA9IGlubmVySHRtbDtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgYXR0cnMpO1xufVxuZnVuY3Rpb24gX292cjModHlwZSwgcHJvcHMsIGF0dHJzKSB7XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBwcm9wcy5pbm5lckhUTUwgPSBwcm9wcy5pbm5lckhUTUwgfHwgJyc7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGF0dHJzKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZWxldGUgdGhlIGNvbnRlbnRzIG9mIGFueSBodG1sIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZU5vZGVDb250ZW50KG5vZGUpIHtcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG59XG5leHBvcnRzLmRlbGV0ZU5vZGVDb250ZW50ID0gZGVsZXRlTm9kZUNvbnRlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBoZWxwZXIgZm9yIENyZWF0ZUVsZW1lbnQsIHJvdWdobHkgbWFwcGluZyB0byBIdG1sRWxlbWVudCB0eXBlcywgYnV0IG5vdCBwZXJmZWN0bHkgYmVjYXVzZSBpdCdzIGltcG9zc2libGVcbiAqICh0aGVyZSdzIG5vIHBlcmZlY3QgMToxIHJlbGF0aW9uc2hpcCkuXG4gKi9cbnZhciBlbGVtZW50VHlwZTtcbihmdW5jdGlvbiAoZWxlbWVudFR5cGUpIHtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxBbmNob3JFbGVtZW50XCJdID0gXCJhXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MQXJlYUVsZW1lbnRcIl0gPSBcImFyZWFcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxBdWRpb0VsZW1lbnRcIl0gPSBcImF1ZGlvXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MQlJFbGVtZW50XCJdID0gXCJiclwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEJhc2VGb250RWxlbWVudFwiXSA9IFwiYmFzZWZvbnRcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxCbG9ja1F1b3RlRWxlbWVudFwiXSA9IFwiYmxvY2txdW90ZVwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEJ1dHRvbkVsZW1lbnRcIl0gPSBcImJ1dHRvblwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTENhbnZhc0VsZW1lbnRcIl0gPSBcImNhbnZhc1wiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTERhdGFFbGVtZW50XCJdID0gXCJkYXRhXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MRGF0YUxpc3RFbGVtZW50XCJdID0gXCJkYXRhbGlzdFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTERpYWxvZ0VsZW1lbnRcIl0gPSBcImRpYWxvZ1wiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTERpdkVsZW1lbnRcIl0gPSBcImRpdlwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTERMaXN0RWxlbWVudFwiXSA9IFwiZGxcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxFbWJlZEVsZW1lbnRcIl0gPSBcImVtYmVkXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MRmllbGRTZXRFbGVtZW50XCJdID0gXCJmaWVsZHNldFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEZvcm1FbGVtZW50XCJdID0gXCJmb3JtXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MSGVhZGluZzFFbGVtZW50XCJdID0gXCJoMVwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEhlYWRpbmcyRWxlbWVudFwiXSA9IFwiaDJcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxIZWFkaW5nM0VsZW1lbnRcIl0gPSBcImgzXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MSGVhZGluZzRFbGVtZW50XCJdID0gXCJoNFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEhlYWRpbmc1RWxlbWVudFwiXSA9IFwiaDVcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxIZWFkaW5nNkVsZW1lbnRcIl0gPSBcImg2XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MSFJFbGVtZW50XCJdID0gXCJoclwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTEltYWdlRWxlbWVudFwiXSA9IFwiaW1hZ2VcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxJbnB1dEVsZW1lbnRcIl0gPSBcImlucHV0XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MTGFiZWxFbGVtZW50XCJdID0gXCJsYWJlbFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTExlZ2VuZEVsZW1lbnRcIl0gPSBcImxlZ2VuZFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTExJRWxlbWVudFwiXSA9IFwibGlcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxMaW5rRWxlbWVudFwiXSA9IFwibGlua1wiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTE1hcEVsZW1lbnRcIl0gPSBcIm1hcFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTE1ldGVyRWxlbWVudFwiXSA9IFwibWV0ZXJcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxNb2REZWxFbGVtZW50XCJdID0gXCJkZWxcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxNb2RJbnNFbGVtZW50XCJdID0gXCJpbnNcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxPTGlzdEVsZW1lbnRcIl0gPSBcIm9sXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MT2JqZWN0RWxlbWVudFwiXSA9IFwib2JqZWN0XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MT3B0R3JvdXBFbGVtZW50XCJdID0gXCJvcHRncm91cFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTE9wdGlvbkVsZW1lbnRcIl0gPSBcIm9wdGlvblwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTE91dHB1dEVsZW1lbnRcIl0gPSBcIm91dHB1dFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFBhcmFncmFwaEVsZW1lbnRcIl0gPSBcInBcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxQYXJhbUVsZW1lbnRcIl0gPSBcInBhcmFtXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MUGljdHVyZUVsZW1lbnRcIl0gPSBcInBpY3R1cmVcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxQcmVFbGVtZW50XCJdID0gXCJwcmVcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxQcm9ncmVzc0VsZW1lbnRcIl0gPSBcInByb2dyZXNzXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MUXVvdGVFbGVtZW50XCJdID0gXCJxXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MU2NyaXB0RWxlbWVudFwiXSA9IFwic2NyaXB0XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MU2VsZWN0RWxlbWVudFwiXSA9IFwic2VsZWN0XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MU291cmNlRWxlbWVudFwiXSA9IFwic291cmNlXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MU3BhbkVsZW1lbnRcIl0gPSBcInNwYW5cIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxTdHlsZUVsZW1lbnRcIl0gPSBcInN0eWxlXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVGFibGVDYXB0aW9uRWxlbWVudFwiXSA9IFwiY2FwdGlvblwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFRhYmxlRGF0YUNlbGxFbGVtZW50XCJdID0gXCJ0ZFwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFRhYmxlSGVhZGVyQ2VsbEVsZW1lbnRcIl0gPSBcInRoXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVGFibGVDb2xFbGVtZW50XCJdID0gXCJjb2xcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxUYWJsZUNvbEdyb3VwRWxlbWVudFwiXSA9IFwiY29sZ3JvdXBcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxUYWJsZUVsZW1lbnRcIl0gPSBcInRhYmxlXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVGFibGVSb3dFbGVtZW50XCJdID0gXCJ0clwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFRhYmxlU2VjdGlvbkJvZHlFbGVtZW50XCJdID0gXCJ0Ym9keVwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFRhYmxlU2VjdGlvbkZvb3RlckVsZW1lbnRcIl0gPSBcInRmb290XCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVGFibGVTZWN0aW9uSGVhZGVyRWxlbWVudFwiXSA9IFwidGhlYWRcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxUZW1wbGF0ZUVsZW1lbnRcIl0gPSBcInRlbXBsYXRlXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVGV4dEFyZWFFbGVtZW50XCJdID0gXCJ0ZXh0YXJlYVwiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFRpbWVFbGVtZW50XCJdID0gXCJ0aW1lXCI7XG4gICAgZWxlbWVudFR5cGVbXCJIVE1MVHJhY2tFbGVtZW50XCJdID0gXCJ0cmFja1wiO1xuICAgIGVsZW1lbnRUeXBlW1wiSFRNTFVMaXN0RWxlbWVudFwiXSA9IFwidWxcIjtcbiAgICBlbGVtZW50VHlwZVtcIkhUTUxWaWRlb0VsZW1lbnRcIl0gPSBcInZpZGVvXCI7XG59KShlbGVtZW50VHlwZSA9IGV4cG9ydHMuZWxlbWVudFR5cGUgfHwgKGV4cG9ydHMuZWxlbWVudFR5cGUgPSB7fSkpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBlc2NhcGVIdG1sKGlucHV0KSB7XG4gICAgLy8gVGhlcmUgaXNuJ3QgYSBidWlsdC1pbiB3YXkgdG8gZG8gdGhpcywgc3RpbGwsIHNvIHdlIG5lZWQgYSBoZWxwZXIgZnVuY3Rpb24uXG4gICAgLy8gVGhlIGFydGljbGUgXCJZb3UgYXJlIHByb2JhYmx5IG1pc3VzaW5nIERPTSB0ZXh0IG1ldGhvZHNcIiBjb252aW5jZWQgbWUgdG8gZG8gaXQgdGhpcyB3YXksXG4gICAgLy8gdnMuIGNyZWF0ZVRleHROb2RlLiBUaG91Z2ggY3JlYXRlVGV4dE5vZGUgd291bGQgcHJvYmFibHkgd29yayBmaW5lIGZvciBzZXR0aW5nIGlubmVySFRNTC5cbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgY29uc3QgZXNjYXBlcyA9IHtcbiAgICAgICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgICAgICBcIj5cIjogXCImZ3Q7XCIsXG4gICAgICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgICAgIFwiL1wiOiBcIiYjeDJGO1wiLFxuICAgICAgICBcIj1cIjogXCImI3gzRDtcIixcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgXCInXCI6IFwiJiMzOTtcIixcbiAgICAgICAgXCJgXCI6IFwiJiN4NjA7XCJcbiAgICB9O1xuICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bJjw+XCInYD1cXC9dL2csIHMgPT4gZXNjYXBlc1tzXSk7XG59XG5leHBvcnRzLmVzY2FwZUh0bWwgPSBlc2NhcGVIdG1sO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEdldCB0aGUgY29udGVudHMgb2YgYW55IGh0bWwgbm9kZSBhcyBhIERvY3VtZW50RnJhZ21lbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3ROb2RlQ29udGVudChub2RlKSB7XG4gICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICByZXR1cm4gcmFuZ2UuZXh0cmFjdENvbnRlbnRzKCk7XG59XG5leHBvcnRzLmV4dHJhY3ROb2RlQ29udGVudCA9IGV4dHJhY3ROb2RlQ29udGVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZmluZEluZGV4SW5QYXJlbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5jaGlsZHJlbikuaW5kZXhPZihlbGVtZW50KTtcbiAgICB9XG59XG5leHBvcnRzLmZpbmRJbmRleEluUGFyZW50ID0gZmluZEluZGV4SW5QYXJlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE5vbmVUeXBlXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1R5cGVzL05vbmVUeXBlXCIpO1xuLyoqXG4gKiBIVE1MIGlzIGluY29uc2lzdGVudC4gR2V0dGluZyB0aGUgdmFsdWUgb2YgZm9ybSBmaWVsZHMgaXMgYSBiaXQgY29tcGxpY2F0ZWQsIG5vdCBhbHdheXMgZWxlbWVudC52YWx1ZSxcbiAqIHNvIGhlcmUncyBhIGhlbHBlciB0byBtYWtlIGl0IGVhc2llci5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybUZpZWxkVmFsdWUoZWxlbWVudCkge1xuICAgIC8vIEl0IHdvdWxkIGJlIHJlYWxseSBuaWNlIGF0IHRoaXMgcG9pbnQgaWYgSlMgY291bGQgc2VlIGdlbmVyaWMgcGFyYW1ldGVycy5cbiAgICAvLyBJZiBpdCBjb3VsZCwgdGhlbiB0aGUgY29kZSBjb3VsZCBzYXkgXCJpZiAoaW5wdXQudHlwZSA9PT0gJ2NoZWNrYm94JyAmJiBUT3V0cHV0ICE9PSBib29sZWFuKSB0aHJvdyBuZXcgRXJyb3IoKVwiXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZWxlbWVudDtcbiAgICAgICAgaWYgKGlucHV0LnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2NoZWNrYm94Jykge1xuICAgICAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dC50eXBlLnRvTG93ZXJDYXNlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TnVtYmVySW5wdXRWYWx1ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQudHlwZS50b0xvd2VyQ2FzZSgpID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHJldHVybiBnZXRTZWxlY3RWYWx1ZShlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRGb3JtRmllbGRWYWx1ZSA9IGdldEZvcm1GaWVsZFZhbHVlO1xuZnVuY3Rpb24gZ2V0Q2hlY2tib3hWYWx1ZShpbnB1dCkge1xuICAgIHJldHVybiAhIWlucHV0LmNoZWNrZWQ7XG59XG5leHBvcnRzLmdldENoZWNrYm94VmFsdWUgPSBnZXRDaGVja2JveFZhbHVlO1xuZnVuY3Rpb24gZ2V0TnVtYmVySW5wdXRWYWx1ZShpbnB1dCkge1xuICAgIGlmIChpbnB1dC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKGlucHV0LnZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLmdldE51bWJlcklucHV0VmFsdWUgPSBnZXROdW1iZXJJbnB1dFZhbHVlO1xuZnVuY3Rpb24gZ2V0UmFkaW9WYWx1ZShpbnB1dCkge1xuICAgIC8vIFJhZGlvIGJ1dHRvbnMgYXJlIHdlaXJkLiBXZSB3YW50IHRoZW0gdG8gYXBwZWFyIHRvIGJlIG1vcmUgbm9ybWFsLlxuICAgIGlmIChpbnB1dC5uYW1lKSB7XG4gICAgICAgIHJldHVybiAoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgaW5wdXRbbmFtZT1cIiR7aW5wdXQubmFtZX1cIl06Y2hlY2tlZGApIHx8IHt9KS52YWx1ZTtcbiAgICB9XG4gICAgLy8gSWYgbm8gbmFtZSwgZmFsbCBiYWNrIHRvIHRoaXNcbiAgICBpZiAoaW5wdXQuY2hlY2tlZCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRSYWRpb1ZhbHVlID0gZ2V0UmFkaW9WYWx1ZTtcbmZ1bmN0aW9uIGdldFNlbGVjdFZhbHVlKHNlbGVjdCkge1xuICAgIGlmIChzZWxlY3QubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIGdldE11bHRpU2VsZWN0VmFsdWUoc2VsZWN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzZWxlY3QudmFsdWU7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRTZWxlY3RWYWx1ZSA9IGdldFNlbGVjdFZhbHVlO1xuZnVuY3Rpb24gZ2V0TXVsdGlTZWxlY3RWYWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShzZWxlY3Quc2VsZWN0ZWRPcHRpb25zKS5maWx0ZXIoZiA9PiBmLnZhbHVlKS5tYXAobSA9PiBtLnZhbHVlKTtcbn1cbmV4cG9ydHMuZ2V0TXVsdGlTZWxlY3RWYWx1ZSA9IGdldE11bHRpU2VsZWN0VmFsdWU7XG4vLyBUaGlzIGlzIGFsbW9zdCBwb2ludGxlc3MuIEp1c3QgaGVyZSBmb3IgY29uc2lzdGVuY3kuXG5mdW5jdGlvbiBnZXRTaW1wbGVGb3JtVmFsdWUoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuICAgICAgICBpZiAoaW5wdXQubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IHZhbGlkIGZvciBtdWx0aS1zZWxlY3RzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnZhbHVlO1xufVxuZXhwb3J0cy5nZXRTaW1wbGVGb3JtVmFsdWUgPSBnZXRTaW1wbGVGb3JtVmFsdWU7XG4vKipcbiAqIFNldHRpbmcgdmFsdWVzIGlzIGp1c3QgYXMgY29tcGxpY2F0ZWQgYXMgZ2V0dGluZyB0aGVtLCBiZWNhdXNlIEhUTUwgaXMgaW5jb25zaXN0ZW50LiBZb3UgY2FuJ3QganVzdCBzYXkgZWxlbWVudC52YWx1ZSA9IGZvby5cbiAqIEhlcmUncyBhIGhlbHBlciB0byBtYWtlIGl0IGVhc2llci5cbiAqL1xuZnVuY3Rpb24gc2V0Rm9ybUZpZWxkVmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAvLyBIZXJlIHlvdSBjYW4gdmFsaWRhdGUgdGhlIHR5cGUgYmVmb3JlIHNldHRpbmcgb3IgZG8gc29tZSBraW5kIG9mIGNvbnZlcnNpb24uXG4gICAgLy8gRm9yIG11bHRpLXNlbGVjdHMsIGNhbiBhdXRvLXdyYXAgdmFsdWUgaW4gc3RyaW5nLlxuICAgIGlmIChOb25lVHlwZV8xLmlzTm9uZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nVmFsdWUgPSB2YWx1ZS50b1N0cmluZygpOyAvLyB1c2VkIGluIG1vc3Qgb2YgdGhlIGNhc2VzXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZWxlbWVudDtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlucHV0LnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjaGVja2JveCcpIHtcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSB2YWx1ZSA9PT0gdHJ1ZSB8fCBzdHJpbmdWYWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgaW5wdXQuY2hlY2tlZCA9IHN0cmluZ1ZhbHVlID09PSBpbnB1dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnZGF0ZScpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHRvRGF0ZVN0cmluZyhuZXcgRGF0ZShzdHJpbmdWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdkYXRldGltZScgfHwgdHlwZSA9PT0gJ2RhdGV0aW1lLWxvY2FsJykge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShzdHJpbmdWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNOYU4oZGF0ZS52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSBgJHt0b0RhdGVTdHJpbmcoZGF0ZSl9VCR7dG9UaW1lU3RyaW5nKGRhdGUpfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc2VsZWN0Jykge1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBlbGVtZW50O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gQXJyYXkuZnJvbShzZWxlY3Qub3B0aW9ucyk7XG4gICAgICAgIGlmIChzZWxlY3QubXVsdGlwbGUpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjaGVja09wdGlvbihvcHRpb25zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0LnZhbHVlID0gc3RyaW5nVmFsdWU7IC8vIHRyZWF0aW5nIGl0IGxpa2UgYSBub24tbXVsdGlwbGUgd29ya3NcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb25leGlzdGVudCBvcHRpb25zIGNhbm5vdCBiZSBzZXQuIFdlIHNob3VsZCBsZXQgdGhlIHByb2dyYW1tZXIga25vdy4gRXZlbiB0aG91Z2ggdGhpcyB0YWtlcyBDUFUgY3ljbGVzLlxuICAgICAgICAgICAgdmFsdWUubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgIGNoZWNrT3B0aW9uKG9wdGlvbnMsIG0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdCBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0LnNlbGVjdGVkID0gdmFsdWUubWFwKG0gPT4gbS50b1N0cmluZygpKS5pbmRleE9mKG9wdC52YWx1ZSkgPiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNoZWNrT3B0aW9uKG9wdGlvbnMsIHZhbHVlKTtcbiAgICAgICAgICAgIHNlbGVjdC52YWx1ZSA9IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgIGVsZW1lbnQudmFsdWUgPSBzdHJpbmdWYWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihgQ2FsbGVkIHNldEZvcm1GaWVsZFZhbHVlIG9uIG5vbi1mb3JtIGZpZWxkICR7ZWxlbWVudC50YWdOYW1lfSAke2VsZW1lbnQuaWQgfHwgJyd9YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrT3B0aW9uKG9wdGlvbnMsIHZhbCkge1xuICAgICAgICAvLyBJZiB5b3Ugc2V0IHRoZSB2YWx1ZSBvZiBhIHNlbGVjdCB0byBzb21ldGhpbmcgdGhhdCBpcyBub3QgYW4gYXZhaWxhYmxlIG9wdGlvbiwgbm90aGluZyB3aWxsIGhhcHBlbi5cbiAgICAgICAgY29uc3QgaGFzT3B0aW9uID0gb3B0aW9ucy5tYXAobSA9PiBtLnZhbHVlKS5pbmRleE9mKHZhbC50b1N0cmluZygpKSA+IC0xO1xuICAgICAgICBpZiAoIWhhc09wdGlvbikge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2FsbGVkIHNldEZvcm1GaWVsZFZhbHVlIHdpdGggbm9uZXhpc3RlbnQgb3B0aW9uICR7dmFsLnRvU3RyaW5nKCl9IG9uIHNlbGVjdCAke2VsZW1lbnQuaWR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlc2UgY291bGQgYmUgcmVhZGFibGUgb25lbGluZXJzIGlmIHdlIGhhZCBwYWRTdGFydCgpIGJ1dCBpdCdzIG5vdCB3b3J0aCBidW1waW5nIHRvIEVTMjAxNyBmb3Igb25lIG1ldGhvZFxuICAgIGZ1bmN0aW9uIHRvRGF0ZVN0cmluZyhkYXRlKSB7XG4gICAgICAgIGlmICghaXNOYU4oZGF0ZS52YWx1ZU9mKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9udGggPSAoJzAnICsgKGRhdGUuZ2V0VVRDTW9udGgoKSArIDEpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgY29uc3QgZGF5ID0gKCcwJyArIGRhdGUuZ2V0VVRDRGF0ZSgpLnRvU3RyaW5nKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgcmV0dXJuIGAke2RhdGUuZ2V0VVRDRnVsbFllYXIoKX0tJHttb250aH0tJHtkYXl9YDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdG9UaW1lU3RyaW5nKGRhdGUpIHtcbiAgICAgICAgaWYgKCFpc05hTihkYXRlLnZhbHVlT2YoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3VyID0gKCcwJyArIGRhdGUuZ2V0SG91cnMoKSkuc2xpY2UoLTIpO1xuICAgICAgICBjb25zdCBtaW51dGUgPSAoJzAnICsgZGF0ZS5nZXRNaW51dGVzKCkpLnNsaWNlKC0yKTtcbiAgICAgICAgcmV0dXJuIGAke2hvdXJ9OiR7bWludXRlfWA7XG4gICAgfVxufVxuZXhwb3J0cy5zZXRGb3JtRmllbGRWYWx1ZSA9IHNldEZvcm1GaWVsZFZhbHVlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEhlcmUncyBhIGhlbHBlciBmb3Igb25lIG9mIHRoZSBwbGFjZXMgd2hlcmUgSFRNTDUgZmFsbHMgb3Zlci4gSWYgeW91IGdldCBzb21lIGh0bWwgbGlrZSA8ZGl2IGlkPVwiMVwiPjwvZGl2PjxkaXYgaWQ9XCIyXCI+PC9kaXY+LCBpdCBiZWNvbWVzXG4gKiBhIE5vZGVMaXN0LiBIVE1MNSBieSBkZWZhdWx0IGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gc2VhcmNoIHRoaXMgZm9yIGEgc2VsZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIG5vZGVMaXN0U2VsZWN0b3Iobm9kZXMsIHNlbGVjdG9yKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmICghKCdtYXRjaGVzJyBpbiBub2RlKSkge1xuICAgICAgICAgICAgLy8gRmlsdGVyIG91dCB0ZXh0IG5vZGVzXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VhcmNoID0gbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMubm9kZUxpc3RTZWxlY3RvciA9IG5vZGVMaXN0U2VsZWN0b3I7XG4vKipcbiAqIEhlcmUncyBhIGhlbHBlciBmb3Igb25lIG9mIHRoZSBwbGFjZXMgd2hlcmUgSFRNTDUgZmFsbHMgb3Zlci4gSWYgeW91IGdldCBzb21lIGh0bWwgbGlrZSA8ZGl2IGlkPVwiMVwiPjwvZGl2PjxkaXYgaWQ9XCIyXCI+PC9kaXY+LCBpdCBiZWNvbWVzXG4gKiBhIE5vZGVMaXN0LiBIVE1MNSBieSBkZWZhdWx0IGRvZXMgbm90IHByb3ZpZGUgYSB3YXkgdG8gc2VhcmNoIHRoaXMgZm9yIGEgc2VsZWN0b3IuXG4gKi9cbmZ1bmN0aW9uIG5vZGVMaXN0U2VsZWN0b3JBbGwobm9kZXMsIHNlbGVjdG9yKSB7XG4gICAgLy8gQmVjYXVzZSB0aGUgYnJvd3NlciBjYW4gbG9zZSByZWZlcmVuY2VzIHdoZW4gbW92aW5nIG5vZGVzLCB0aGlzIGNhbiBhbHNvIHRha2UgYSByZWd1bGFyIGFycmF5LlxuICAgIC8vIEJlY2F1c2UgSFRNTDUgaGFzIHRvdGFsbHkgZmFsbGVuIG92ZXIsIGl0J3Mgbm90IHBvc3NpYmxlIGZvciB0aGUgZml4ZWQgbm9kZUxpc3RTZWxlY3RvckFsbFxuICAgIC8vIHRvIG1hdGNoIHRoZSBvdXRwdXQgc2lnbmF0dXJlIG9mIHF1ZXJ5U2VsZWN0b3JBbGwgKE5vZGVMaXN0T2Y8RWxlbWVudD4gaW5zdGVhZCBvZiBhcnJheSkuXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgICBpZiAoISgnbWF0Y2hlcycgaW4gbm9kZSkpIHtcbiAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgdGV4dCBub2Rlc1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUubWF0Y2hlcyhzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2ggPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAgICByZXN1bHRzLnB1c2goLi4uQXJyYXkuZnJvbShzZWFyY2gpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5leHBvcnRzLm5vZGVMaXN0U2VsZWN0b3JBbGwgPSBub2RlTGlzdFNlbGVjdG9yQWxsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIElmIHRoZSBkb2N1bWVudCBjb250YWlucyBhbnkgZHVwbGljYXRlIElEcywgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZURvbUlkcygpIHtcbiAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoY29uc3QgZm9vIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJypbaWRdJykpIHtcbiAgICAgICAgaWRzLmFkZChmb28uaWQpO1xuICAgICAgICBpKys7XG4gICAgICAgIGlmIChpZHMuc2l6ZSAhPT0gaSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgRE9NIElEcyBmb3VuZC4gVGhlIGZpcnN0IGR1cGxpY2F0ZSBpZCBpcyAke2Zvb30uYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVW5pcXVlRG9tSWRzID0gdmFsaWRhdGVVbmlxdWVEb21JZHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENyZWF0ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL0NyZWF0ZUVsZW1lbnRcIik7XG5jb25zdCBFbGVtZW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRWxlbWVudFR5cGVcIik7XG5jb25zdCBFc2NhcGVIdG1sXzEgPSByZXF1aXJlKFwiLi4vSHRtbC9Fc2NhcGVIdG1sXCIpO1xuY29uc3QgRXh0cmFjdE5vZGVDb250ZW50XzEgPSByZXF1aXJlKFwiLi4vSHRtbC9FeHRyYWN0Tm9kZUNvbnRlbnRcIik7XG5jb25zdCBGb3JtRmllbGRWYWx1ZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRm9ybUZpZWxkVmFsdWVcIik7XG5jb25zdCBRdWVyeVNlbGVjdG9yTm9kZUxpc3RfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL1F1ZXJ5U2VsZWN0b3JOb2RlTGlzdFwiKTtcbmNvbnN0IElPYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwiLi4vT2JzZXJ2YWJsZS9JT2JzZXJ2YWJsZVwiKTtcbmNvbnN0IE9ic2VydmFibGVQcm9wZXJ0eV8xID0gcmVxdWlyZShcIi4uL09ic2VydmFibGUvT2JzZXJ2YWJsZVByb3BlcnR5XCIpO1xuY29uc3QgT2JzZXJ2YWJsZVN0YXRlXzEgPSByZXF1aXJlKFwiLi4vT2JzZXJ2YWJsZS9PYnNlcnZhYmxlU3RhdGVcIik7XG5jb25zdCBDb25zdHJ1Y3RhYmxlXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1R5cGVzL0NvbnN0cnVjdGFibGVcIik7XG5jb25zdCBOb25lVHlwZV8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9UeXBlcy9Ob25lVHlwZVwiKTtcbmNvbnN0IENvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vQ29tcG9uZW50XCIpO1xuY29uc3QgQ29tcG9uZW50TWFwXzEgPSByZXF1aXJlKFwiLi9Db21wb25lbnRNYXBcIik7XG5jb25zdCBLZXl3b3JkQXJndW1lbnRzXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1R5cGVzL0tleXdvcmRBcmd1bWVudHNcIik7XG5jb25zdCBFbHZpc18xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9VdGlsaXR5L0VsdmlzXCIpO1xuLyoqXG4gKiBBIHN1cGVyLWJhc2ljIGNvbXBvbmVudCB0aGF0IGFsbG93cyBjb25maWd1cmF0aW9uIG9mIGRhdGEtYmluZGluZyBmdW5jdGlvbnMgdXNpbmcgc3BlY2lhbGx5LW5hbWVkIEhUTUwgYXR0cmlidXRlcywgYXMgaW4gQW5ndWxhclxuICogb3IgVnVlLlxuICovXG5jbGFzcyBCb3VuZENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudF8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iodmlld01vZGVsLCBhcmdzKSB7XG4gICAgICAgIHN1cGVyKGFyZ3MpO1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVCaW5kaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLl93cml0ZVRhcmdldHMgPSBbXTsgLy8gQ2FuIG9ubHkgd3JpdGUgdG8gVEhJUyBjb21wb25lbnRcbiAgICAgICAgdGhpcy5fY3NzQ2xhc3NTd2l0Y2hlcyA9IFtdO1xuICAgICAgICB0aGlzLl9yZXBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5fYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGVmZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSB2aWV3TW9kZWw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXdpbmRvdy5jdXN0b21FbGVtZW50cy5nZXQoJ2ktdicpKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnaS12JywgVGVtcGxhdGVSZXBsYWNlbWVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBjdXN0b21FbGVtZW50cyBpc24ndCBvZmZpY2lhbGx5IHBhcnQgb2YgYW4gRVMgdmVyc2lvbiB5ZXQgc28gd29uJ3Qgd29yayBldmVuIGluIHNvbWUgcmVjZW50LWlzaCBicm93c2Vyc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzIHx8IHt9O1xuICAgICAgICB0aGlzLl9hc3luYyA9IG9wdGlvbnMuYXN5bmMgfHwgZmFsc2U7XG4gICAgICAgIHRoaXMuX2RlZmVyID0gb3B0aW9ucy5kZWZlciB8fCBmYWxzZTtcbiAgICAgICAgdGhpcy5faWQgPSB0aGlzLmNvbnRlbnQuaWQ7XG4gICAgICAgIC8vIERlZmluZWQgdGhlIGRlZmF1bHQgY29tcG9uZW50IGNsYXNzIGZvciB0aGUgZGVmYXVsdCBsb29wUG9zdFByb2Nlc3MoKSBtZXRob2RcbiAgICAgICAgaWYgKG9wdGlvbnMubG9vcEl0ZW1DbGFzcykge1xuICAgICAgICAgICAgaWYgKCFDb25zdHJ1Y3RhYmxlXzEuY29uc3RydWN0b3JUeXBlR3VhcmQob3B0aW9ucy5sb29wSXRlbUNsYXNzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbG9vcEl0ZW1DbGFzcyBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEob3B0aW9ucy5sb29wSXRlbUNsYXNzIGluc3RhbmNlb2YgQm91bmRDb21wb25lbnQuY29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb29wSXRlbUNsYXNzIGlzIG5vdCBhbiBib3VuZCBjb21wb25lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvb3BQYXJlbnQgPSBvcHRpb25zLmxvb3BQYXJlbnQ7IC8vIHVuZGVmaW5lZCBpbiBtb3N0IGNhc2VzXG4gICAgICAgIHRoaXMuX2xvb3BJdGVtQ2xhc3MgPSBvcHRpb25zLmxvb3BJdGVtQ2xhc3MgfHwgQm91bmRDb21wb25lbnQ7XG4gICAgICAgIHRoaXMuX2NvbmZpZ3VyZUNvbXBvbmVudEJpbmRpbmdzKCk7XG4gICAgICAgIHRoaXMuc2V0VGVtcGxhdGUodGhpcy5jb250ZW50LmlubmVySFRNTCk7IC8vIElubmVySFRNTCBpcyBjdXJyZW50bHkgb25seSBwYXJzZWQgYW5kIHRoZW4gdGhlIG9yaWdpbmFsIHRleHQgaXMgdGhyb3duIGF3YXkuXG4gICAgICAgIC8vIEF1dG8tYWRkIHN1YnNjcmlwdGlvbnMgYmFzZWQgb24gc2V0dGluZ3MuXG4gICAgICAgIGlmIChvcHRpb25zLm9ic2VydmVBbGxWaWV3TW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub2JzZXJ2ZVZpZXdNb2RlbCkge1xuICAgICAgICAgICAgdGhpcy5vYnNlcnZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMub2JzZXJ2ZVRhcmdldHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGd0IG9mIG9wdGlvbnMub2JzZXJ2ZVRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmUodGd0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5vYnNlcnZlQWxsVGFyZ2V0cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0Z3Qgb2Ygb3B0aW9ucy5vYnNlcnZlQWxsVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIHRoaXMub2JzZXJ2ZUFsbCh0Z3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hc3luYykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlbmRlcigpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RydWN0b3IgaW5pdGlhbGl6YXRpb24gaXMgZG9uZS5cbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyB0byBjb252ZXJ0IGVsZW1lbnRzIHRvIGNvbXBvbmVudHMuIEl0J3MgbW9zdCB1c2VmdWwgZm9yIGN1c3RvbSB0YWdzLCBmb3IgZXhhbXBsZSwgPG15LWNvbXBvbmVudD48L215LWNvbXBvbmVudD4uXG4gICAgICogSXQgd2lsbCBiZWNvbWUgPGRpdiBpZD1cImZvb1wiPldoYXRldmVyIHRoZSBjb21wb25lbnQgY29udGVudCBpczwvZGl2Pi5cbiAgICAgKiBUbyByZXBsYWNlIHRoZSBlbGVtZW50IChjb3B5aW5nIGV4aXN0aW5nIGF0dHJpYnV0ZXMpIHNlbmQgdGhlIHJlbGV2YW50IG9wdGlvbnMsIHBsdXMge3JlcGxhY2U6IHRydWV9LlxuICAgICAqXG4gICAgICogSW4gYWxtb3N0IGV2ZXJ5IGNhc2UsIHZpZXdNb2RlbCBzaG91bGQgYmUgc2V0LiBCdXQgaXQncyBub3QgcG9zc2libGUgdG8gY2hhbmdlIHRoYXQgYW5kIHN0aWxsIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxuICAgICAqIGNsYXNzIGluamVjdCgpLiBUaGlzIGlzIGEgdHlwZXNjcmlwdC1vbmx5IGlzc3VlIGJ1dCBpdCBtYWtlcyB0aGluZ3MgdWdseS5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgS2V5d29yZCBBcmd1bWVudHMuIEFuZCBwcmFjdGljYWxseSBkZW1hbmRzIHRoZWlyIHVzZSB0byBzZXQgdmlld01vZGVsLlxuICAgICAqL1xuICAgIHN0YXRpYyBpbmplY3Qoc2VsZWN0b3IgPSAnW2ljaGlnb10nLCBvcHRpb25zLCBjb25zdHJ1Y3Rvciwgdmlld01vZGVsKSB7XG4gICAgICAgICh7IHNlbGVjdG9yID0gJ1tpY2hpZ29dJywgb3B0aW9ucywgY29uc3RydWN0b3IsIHZpZXdNb2RlbCB9ID0gS2V5d29yZEFyZ3VtZW50c18xLkt3YXJnLnBhcnNlQXJncyh7IHNlbGVjdG9yLCBvcHRpb25zLCBjb25zdHJ1Y3Rvciwgdmlld01vZGVsIH0pKTsgLy8ga3dhcmdsaW5lXG4gICAgICAgIGNvbnN0IG5ld0NvbnN0cnVjdG9yID0gY29uc3RydWN0b3IgfHwgdGhpcztcbiAgICAgICAgY29uc3Qgb3B0ID0gdGhpcy5fZ2V0T3B0aW9ucyhvcHRpb25zIHx8IHt9KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZXJGdW5jdGlvbiA9IChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVwbGFjZUVsZW1lbnRXaXRoQm91bmRDb21wb25lbnQoZWxlbWVudCwgdmlld01vZGVsLCBvcHQsIG5ld0NvbnN0cnVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29udmVydGVyRnVuY3Rpb24gPSAoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRFbGVtZW50VG9Cb3VuZENvbXBvbmVudChlbGVtZW50LCB2aWV3TW9kZWwsIG9wdCwgbmV3Q29uc3RydWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0KHNlbGVjdG9yLCBvcHQsIHJlcGxhY2VyRnVuY3Rpb24sIGNvbnZlcnRlckZ1bmN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0byBpbmplY3QoKSB3aXRoIGEgY2xlYW5lciBhcmd1bWVudCBvcmRlci5cbiAgICAgKi9cbiAgICBzdGF0aWMgaW5qZWN0QmluZCh2aWV3TW9kZWwsIHNlbGVjdG9yID0gJ1tpY2hpZ29dJywgb3B0aW9ucywgY29uc3RydWN0b3IpIHtcbiAgICAgICAgKHsgc2VsZWN0b3IgPSAnW2ljaGlnb10nLCBvcHRpb25zLCBjb25zdHJ1Y3Rvciwgdmlld01vZGVsIH0gPSBLZXl3b3JkQXJndW1lbnRzXzEuS3dhcmcucGFyc2VBcmdzKHsgc2VsZWN0b3IsIG9wdGlvbnMsIGNvbnN0cnVjdG9yLCB2aWV3TW9kZWwgfSkpOyAvLyBrd2FyZ2xpbmVcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0KHNlbGVjdG9yLCBvcHRpb25zLCBjb25zdHJ1Y3Rvciwgdmlld01vZGVsKTtcbiAgICB9XG4gICAgc3RhdGljIF9yZXBsYWNlRWxlbWVudFdpdGhCb3VuZENvbXBvbmVudChleGlzdGluZ0VsZW1lbnQsIHZpZXdNb2RlbCwgb3B0aW9ucywgY29uc3RydWN0b3IpIHtcbiAgICAgICAgY29uc3Qgb3B0ID0gdGhpcy5fbWVyZ2VQcm9wZXJ0aWVzQW5kQXR0cmlidXRlcyhleGlzdGluZ0VsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgY29uc3RydWN0b3Iodmlld01vZGVsLCBvcHQpO1xuICAgICAgICB0aGlzLl9yZXBsYWNlRWxlbWVudChleGlzdGluZ0VsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBfY29udmVydEVsZW1lbnRUb0JvdW5kQ29tcG9uZW50KGV4aXN0aW5nRWxlbWVudCwgdmlld01vZGVsLCBvcHRpb25zLCBjb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyBXQVJOOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSB0cnVlLiBUaGVyZSdzIG5vIHdheSB0byBjaGVjayB0aGF0IHRoZSB0YWdzIG1hdGNoLlxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHsgZWxlbWVudDogZXhpc3RpbmdFbGVtZW50IH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yKHZpZXdNb2RlbCwgb3B0KTtcbiAgICB9XG4gICAgd3JpdGUoZXZ0KSB7XG4gICAgICAgIGlmICghdGhpcy5fd3JpdGVUYXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBldnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBGb3JtRmllbGRWYWx1ZV8xLmdldEZvcm1GaWVsZFZhbHVlKGVsZW1lbnQpO1xuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIGNhc2VzIHdoZXJlIHZhbHVlIGlzIHVuZGVmaW5lZC4gRWl0aGVyIHRoZSBlbGVtZW50IGlzIG5vdCBhIGZvcm0gZWxlbWVudCBvciBpdCdzIGFuIHVubmFtZWQgcmFkaW8gYnV0dG9uXG4gICAgICAgIC8vIHRoYXQgaXMgbm90IHNlbGVjdGVkLiBJbiBib3RoIGNhc2VzLCB3ZSBkb24ndCB3YW50IHRvIHVwZGF0ZSB0aGUgbW9kZWwgd2l0aCB1bmRlZmluZWQsIHdoaWNoIGlzIHVzZWxlc3MuXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMganVzdGlmaWNhdGlvbiB2YWxpZD9cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBXQVJOOiBDYW5ub3QgdHlwZSBjaGVjayB0aGlzIGR5bmFtaWNhbGx5LiBUeXBlU2NyaXB0IGlzIGJ1aWxkLXRpbWUgY2hlY2tpbmcgb25seS4gUnVudGltZSBjb2RlIGNhbid0IGV2ZW4gc2VlIHRoZSB0eXBlLlxuICAgICAgICAvLyBJZiB5b3Ugd2FudCB0byBiZSBwcmVjaXNlLCBhbGwgcHJvcGVydGllcyBpbiBfd3JpdGVCaW5kaW5ncyBzaG91bGQgYmUgRm9ybUl0ZW1WYWx1ZSwgYnV0IGFzIF93cml0ZUJpbmRpbmdzIGlzIHBvcHVsYXRlZFxuICAgICAgICAvLyB2aWEgc3RyaW5nLCB0aGVyZSdzIG5vIHdheSB0byBlbmZvcmNlIHRoYXQuIFNvIGlmIHlvdSBmaWxsIGEgc3RyaW5nIHZhbHVlIGZyb20gYSBtdWx0aXBsZSBzZWxlY3QsIGl0J2xsIHByb2R1Y2UgYnVncy5cbiAgICAgICAgLy8gU28gYmUgY2FyZWZ1bC4gSXQncyBvbiB5b3UuXG4gICAgICAgIGZvciAoY29uc3QgYmluZCBvZiB0aGlzLl93cml0ZVRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmIChiaW5kLnN0YXJ0c1dpdGgoJ3RoaXMuJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzW2JpbmQuc2xpY2UoNSldO1xuICAgICAgICAgICAgICAgIHdyaXRlVmFsdWUodGFyZ2V0LCAoKSA9PiB0aGlzW2JpbmQuc2xpY2UoNSldID0gdmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmluZCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9ic2VydmFibGVTdGF0ZV8xLm9ic2VydmFibGVTdGF0ZUNoZWNrKHRoaXMudmlld01vZGVsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIHZpZXcgbW9kZWwgaXMgZWl0aGVyIEZvcm1GaWVsZFZhbHVlIG9yIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlVmFsdWUodGhpcy52aWV3TW9kZWwsICgpID0+IHRoaXMudmlld01vZGVsID0gdmFsdWUsIHRoaXMudmlld01vZGVsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiaW5kLnN0YXJ0c1dpdGgoJ14nKSAmJiBFbHZpc18xLmVfKHRoaXMubG9vcFBhcmVudCkudmlld01vZGVsICYmIHR5cGVvZiB0aGlzLmxvb3BQYXJlbnQudmlld01vZGVsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IE5vdCBkb2luZyBhICdeJyBieSBpdHNlbGYgYmVjYXVzZSB0aGF0J3MgYSBwcmV0dHkgQlMgY2FzZS4gSWYgdGhpcyBpcyB0aGUgbG9vcCBjaGlsZCwgdGhlIHBhcmVudCBpcyBwcm9iYWJseVxuICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvciBhbiBpdGVyYWJsZSwgbm90IHJlYWxseSBzb21ldGhpbmcgeW91J2xsIHJlYWQgb3Igd3JpdGUgdG8gZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgLy8gTWlnaHQgZG8gYSBzaG9ydGN1dCB0byB0aGUgcGFyZW50IGNvbXBvbmVudCdzICd0aGlzJ1xuICAgICAgICAgICAgICAgIHdyaXRlVG9WaWV3TW9kZWxPYmplY3QodGhpcy5sb29wUGFyZW50LCBiaW5kLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLnZpZXdNb2RlbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB3cml0ZVRvVmlld01vZGVsT2JqZWN0KHRoaXMsIGJpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlVmFsdWUodGFyZ2V0LCB3cml0ZVRvUHJvcGVydHksIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYnNlcnZhYmxlUHJvcGVydHlfMS5vYnNlcnZhYmxlUHJvcGVydHlDaGVjayh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBhIGZ1bmN0aW9uIHRvIGJlIGZsZXhpYmxlLCBiZWNhdXNlIGlmIHRhcmdldCBpcyBhIHZhbHVlIHR5cGUgb3IgaW1tdXRhYmxlLCB3cml0aW5nXG4gICAgICAgICAgICAvLyBpdCBkaXJlY3RseSByZXBsYWNlcyBvbmx5IHRoZSB2YWx1ZSB3aXRob3V0IHVwZGF0aW5nIHRoZSBtb2RlbC5cbiAgICAgICAgICAgIHdyaXRlVG9Qcm9wZXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHdyaXRlVG9WaWV3TW9kZWxPYmplY3QoY29tcCwgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIGlmIChPYnNlcnZhYmxlU3RhdGVfMS5vYnNlcnZhYmxlU3RhdGVDaGVjayhjb21wLnZpZXdNb2RlbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaXRoIG9ic2VydmFibGUgc3RhdGUsIHdlIG5lZWQgdG8gZ2V0IHRoZSBzdGF0ZSwgdXBkYXRlIGl0LCBhbmQgd3JpdGUgdGhlIHdob2xlIHRoaW5nIGJhY2suXG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgaXQgaXMgcG9zc2libGUgdG8gdXBkYXRlIGEgc2luZ2xlIHByb3BlcnR5IGluIHNvbWUgY2FzZXMsIGl0IGRvZXNuJ3QgYWxsb3cgcmV1c2Ugb2YgYWxyZWFkeS13b3JraW5nIGNvZGUuXG4gICAgICAgICAgICAgICAgY29uc3QgdG1wID0gY29tcC52aWV3TW9kZWwudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdG1wW3Byb3BlcnR5XTtcbiAgICAgICAgICAgICAgICB3cml0ZVZhbHVlKHRhcmdldCwgKCkgPT4gdG1wW3Byb3BlcnR5XSA9IHZhbHVlLCB0bXApO1xuICAgICAgICAgICAgICAgIGNvbXAudmlld01vZGVsLnZhbHVlID0gdG1wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gY29tcC52aWV3TW9kZWxbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIHdyaXRlVmFsdWUodGFyZ2V0LCAoKSA9PiBjb21wLnZpZXdNb2RlbFtwcm9wZXJ0eV0gPSB2YWx1ZSwgY29tcC52aWV3TW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhpcy5yZW5kZXIoKSB0byB0aGUgbW9kZWwgcGFzc2VkIGluLCBvciB0aGUgdmlldyBtb2RlbCBpZiBub25lIHBhc3NlZCBpbi5cbiAgICAgKi9cbiAgICBvYnNlcnZlKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwgfHwgdGhpcy52aWV3TW9kZWw7XG4gICAgICAgIGlmIChJT2JzZXJ2YWJsZV8xLm9ic2VydmFibGVDaGVjayhtb2RlbCkpIHtcbiAgICAgICAgICAgIG1vZGVsLnN1YnNjcmliZSh0aGlzLnJlbmRlciwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhpcy5yZW5kZXIoKSB0byBhbGwgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIGZvdW5kIGluIHRoZSBtb2RlbCBwYXNzZWQgaW4sXG4gICAgICogb3IgdGhlIHZpZXcgbW9kZWwgaWYgbm9uZSBwYXNzZWQgaW4uIFRoaXMgb25seSBnb2VzIG9uZSBsZXZlbCBkZWVwLCBzbyBpdFxuICAgICAqIHdvbid0IHBpY2sgdXAgbmVzdGVkIG9iamVjdHMsIGJ1dCBpdCdzIHByb2JhYmx5IGdvb2QgZW5vdWdoIGluIDYwJSBvZiBjYXNlcy5cbiAgICAgKi9cbiAgICBvYnNlcnZlQWxsKG1vZGVsKSB7XG4gICAgICAgIG1vZGVsID0gbW9kZWwgfHwgdGhpcy52aWV3TW9kZWw7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub2JzZXJ2ZShtb2RlbCk7XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtb2RlbCkpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZShtb2RlbFttXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgLy8gU2VlIGlmIHdlIG5lZWQgdG8gZGVmZXIgcmVuZGVyaW5nIHVudGlsIGFmdGVyIGluaXRpYWxpemF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9kZWZlciAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9hdHRyaWJ1dGVCaW5kaW5ncykge1xuICAgICAgICAgICAgaWYgKGl0ZW0uYm9vbCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBib29sZWFuIGF0dHJpYnV0ZXMsIHRoZSB2ZXJ5IGV4aXN0ZW5jZSBvZiB0aGUgYXR0cmlidXRlIG1lYW5zIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgdHJ1ZS5cbiAgICAgICAgICAgICAgICBsZXQgdmFsID0gdGhpcy5fZ2V0VW50eXBlZFZhbHVlKGl0ZW0uc291cmNlLCBpdGVtLm90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9ICF2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSAhIXZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKGl0ZW0uYXR0cmlidXRlLCB2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnJlbW92ZUF0dHJpYnV0ZShpdGVtLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZShpdGVtLmF0dHJpYnV0ZSwgdGhpcy5fZ2V0U3RyaW5nVmFsdWUoaXRlbS5zb3VyY2UsIGZhbHNlLCBpdGVtLm90aGVyQ29tcG9uZW50SWQpIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdmFsdWVBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIC8vIENhbGxzIHNldEZvcm1GaWVsZFZhbHVlIGJlaGluZCB0aGUgc2NlbmVzLlxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuX2dldFVudHlwZWRWYWx1ZSh0aGlzLl92YWx1ZUF0dHJpYnV0ZS5zb3VyY2UsIHRoaXMuX3ZhbHVlQXR0cmlidXRlLm90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jc3NDbGFzc2VzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lID0gdGhpcy5fZ2V0U3RyaW5nVmFsdWUodGhpcy5fY3NzQ2xhc3Nlcy5jc3NDbGFzcywgZmFsc2UsIHRoaXMuX2Nzc0NsYXNzZXMub3RoZXJDb21wb25lbnRJZCkgfHwgJyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuX2Nzc0NsYXNzU3dpdGNoZXMpIHtcbiAgICAgICAgICAgIC8vIElmIHRydXRoeSwgYWRkIGNsYXNzLCBlbHNlIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgIGxldCB2YWwgPSAhIXRoaXMuX2dldFVudHlwZWRWYWx1ZShpdGVtLnNvdXJjZSwgaXRlbS5vdGhlckNvbXBvbmVudElkKTtcbiAgICAgICAgICAgIGlmIChpdGVtLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gIXZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZChpdGVtLmNsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5jbGFzc0xpc3QucmVtb3ZlKGl0ZW0uY2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jc3NTdHlsZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpcy5fZ2V0U3RyaW5nVmFsdWUodGhpcy5fY3NzU3R5bGUuc3R5bGUsIGZhbHNlLCB0aGlzLl9jc3NTdHlsZS5vdGhlckNvbXBvbmVudElkKSB8fCAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5jc3NUZXh0ID0gdmFsO1xuICAgICAgICAgICAgaWYgKHZhbCAmJiAhdGhpcy5jb250ZW50LnN0eWxlLmNzc1RleHQpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBzdHlsZSB0ZXh0IGluIGNvbXBvbmVudDogJHt2YWx9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xvb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhYmxlID0gdGhpcy5fZ2V0VW50eXBlZFZhbHVlKHRoaXMuX2xvb3Auc291cmNlLCB0aGlzLl9sb29wLm90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICAgICAgaWYgKGl0ZXJhYmxlICYmIHR5cGVvZiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDb250ZW50ID0gRXh0cmFjdE5vZGVDb250ZW50XzEuZXh0cmFjdE5vZGVDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCByb3cgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMuX2xvb3AuZnJhZ21lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBcyBzb29uIGFzIHdlIGFkZCB0aGUgY2xvbmUgdG8gY29udGVudCwgY2hpbGROb2RlcyBsb3NlcyByZWZlcmVuY2UgdG8gaXRzIGNoaWxkIG5vZGVzLCBzbyBjb3B5IGl0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IEFycmF5LmZyb20oY2xvbmUuY2hpbGROb2Rlcykuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xvb3AucG9zdFByb2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9vcFBvc3RQcm9jZXNzKHJvdywgbm9kZXMsIGl0ZXJhYmxlLCBwcmV2aW91c0NvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jc3NEaXNwbGF5KSB7XG4gICAgICAgICAgICAvLyBJZiBmYWxzeSwgc2V0IGRpc3BsYXk6IG5vbmUgKHNhdmluZyBwcmV2aW91cyB2YWx1ZSkuIElmIHRydXRoeSwgcmVzdG9yZSBwcmV2aW91cyB2YWx1ZSAoaWYgYmxvY2ssIGZsZXgsIGJ1dCBub3QgaWYgbm9uZSlcbiAgICAgICAgICAgIGxldCB2YWwgPSB0aGlzLl9nZXRVbnR5cGVkVmFsdWUodGhpcy5fY3NzRGlzcGxheS5zb3VyY2UsIHRoaXMuX2Nzc0Rpc3BsYXkub3RoZXJDb21wb25lbnRJZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3NzRGlzcGxheS5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhbCA9ICF2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgdGhpcy5fcHJldmlvdXNDc3NEaXNwbGF5U2V0dGluZyB8fCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LnN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c0Nzc0Rpc3BsYXlTZXR0aW5nID0gdGhpcy5jb250ZW50LnN0eWxlLmRpc3BsYXkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuc2V0UHJvcGVydHkoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZUh0bWxSZXBsYWNlbWVudHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFRlbXBsYXRlKHRlbXBsYXRlVGV4dCwgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0ZW1wbGF0ZVRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIGV4ZWN1dGVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gVGhlIHVwZGF0ZSBwYXJhbSBzaG91bGQgbm90IGJlIHNldC5cbiAgICAgICAgaWYgKHVwZGF0ZSAmJiAhdGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIHNob3VsZCBub3QgYmUgdHJ1ZSB3aGVuIGNhbGxlZCBpbnRlcm5hbGx5LicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpbmNlIHdlJ3JlIGNyZWF0aW5nIGFuIGVsZW1lbnQgdGhhdCdzIG5vdCBvbiB0aGUgcGFnZSwgd2UgcHJvYmFibHkgY291bGQgYXZvaWQgdXNpbmcgYSBmcmFnbWVudCxcbiAgICAgICAgLy8gYnV0IHRoaXMgaXMgd2hhdCBmcmFnbWVudHMgYXJlIGZvci5cbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBDcmVhdGVFbGVtZW50XzEuY3JlYXRlRWxlbWVudChFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxUZW1wbGF0ZUVsZW1lbnQpO1xuICAgICAgICB0ZW1wbGF0ZS5pbm5lckhUTUwgPSB0ZW1wbGF0ZVRleHQ7XG4gICAgICAgIGNvbnN0IGNsb25lID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0ZW1wbGF0ZS5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB1c2VkIHRvIHJlcGxhY2UgdGhlIGV4aXN0aW5nIHRlbXBsYXRlLCB3ZSBuZWVkIHRvIHdpcGUgb3V0IHRoZSBwcmV2aW91cyB2YWx1ZXNcbiAgICAgICAgdGhpcy5fcmVwbGFjZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIFdvcmtpbmcgb24gYSBjbG9uZSBoZXJlLCBzbyB3ZSBkb24ndCBzZWUgdGhlIGJvZHkgYmVpbmcgYnVpbHQgc3RlcCBieSBzdGVwIGluIHRoZSBicm93c2VyLlxuICAgICAgICBmb3IgKGNvbnN0IHJlcGwgb2YgY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnaS12JykpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IDMgd2F5cyB0byByZWZlcmVuY2UgYSBjb21wb25lbnQsIGVpdGhlciBieSAjaWQgKGZvciBwZW9wbGUgd2hvIGxpa2UgcXVpY2tuZXNzKSwgYnkgY29tcG9uZW50IChmb3IgcGVvcGxlIHdobyBsaWtlXG4gICAgICAgICAgICAvLyBjb21wbGlhbmNlKSwgb3IgYnkgZGF0YS1jb21wb25lbnQgKGZvciBwZW9wbGUgd2hvIFJFQUxMWSBsaWtlIGNvbXBsaWFuY2UpXG4gICAgICAgICAgICBsZXQgcmVsYXRlZENvbXBvbmVudElkID0gJyc7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cHJlZmVyLWZvci1vZlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXBsLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBOYW1lID0gcmVwbC5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmICh0bXBOYW1lLnN0YXJ0c1dpdGgoJyMnKSkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGVkQ29tcG9uZW50SWQgPSB0bXBOYW1lLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlbGF0ZWRDb21wb25lbnRJZCAmJiByZXBsLmhhc0F0dHJpYnV0ZSgnY29tcG9uZW50JykpIHtcbiAgICAgICAgICAgICAgICByZWxhdGVkQ29tcG9uZW50SWQgPSAocmVwbC5nZXRBdHRyaWJ1dGUoJ2NvbXBvbmVudCcpIHx8ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVsYXRlZENvbXBvbmVudElkKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZENvbXBvbmVudElkID0gcmVwbC5kYXRhc2V0LmNvbXBvbmVudCB8fCAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGNvbXBvbmVudCBpcyBzcGVjaWZpZWQsIHRoaXMgY29tcG9uZW50IG11c3QgaGF2ZSB0aGF0IGFzIGFuIGlkXG4gICAgICAgICAgICBpZiAodGhpcy5faWQgJiYgcmVsYXRlZENvbXBvbmVudElkICYmIHJlbGF0ZWRDb21wb25lbnRJZC50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLl9pZC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2VzY2FwZSA9IHJlcGwuaGFzQXR0cmlidXRlKCdub2VzY2FwZScpICYmIHJlcGwuZ2V0QXR0cmlidXRlKCdub2VzY2FwZScpICE9PSAnZmFsc2UnO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJDb21wb25lbnRJZCA9IHJlcGwuZ2V0QXR0cmlidXRlKCdpNV9zb3VyY2UnKSB8fCByZXBsLmdldEF0dHJpYnV0ZSgnc291cmNlJykgfHwgcmVwbC5kYXRhc2V0Lmk1X3NvdXJjZSB8fCByZXBsLmRhdGFzZXQuc291cmNlIHx8IHJlcGwuZ2V0QXR0cmlidXRlKCc6c291cmNlJyk7XG4gICAgICAgICAgICB0aGlzLl9yZXBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogcmVwbCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHJlcGwuaW5uZXJIVE1MLFxuICAgICAgICAgICAgICAgIG5vZXNjYXBlOiBub2VzY2FwZSxcbiAgICAgICAgICAgICAgICBvdGhlckNvbXBvbmVudElkOiBvdGhlckNvbXBvbmVudElkIHx8IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gdGhlIG9yaWdpbmFsIGJ1aWxkIG9mIHRoZSBvYmplY3QsIGYgYW55IHJlcGxhY2VtZW50cyBzdGFydCB3aXRoIFwidGhpcy5cIiB3ZSBuZWVkIHRvIGRlZmVyLlxuICAgICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkICYmICF0aGlzLl9kZWZlcikge1xuICAgICAgICAgICAgdGhpcy5fZGVmZXIgPSB0aGlzLl9kZWZlciB8fCAhIXRoaXMuX3JlcGxhY2VtZW50cy5maW5kKGYgPT4gZi5zb3VyY2Uuc3RhcnRzV2l0aCgndGhpcy4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2VlIGlmIHdlIG5lZWQgdG8gZGVmZXIgcmVuZGVyaW5nIHVudGlsIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGxlYWQgdG8gYSBGT1VDLCBtYXliZSBtaWxsaXNlY29uZHMsIG1heWJlIGxvbmdlci5cbiAgICAgICAgaWYgKCF0aGlzLl9kZWZlciB8fCB0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgY29tcGxldGVkIHZhbHVlcyBiZWZvcmUgYWRkaW5nIHRvIHRoZSB2aXNpYmxlIHBhZ2UuIFRoaXMgaXMgc2xpZ2h0bHkgcmVkdW5kYW50LCBiZWNhdXNlIHRoaXMgaGFwcGVucyBpbiB0aGUgcmVuZGVyKClcbiAgICAgICAgICAgIC8vIHN0ZXAsIGJ1dCBJIGhhdGUgaXQgd2hlbiBJIHNlZSBhIGZsYXNoIG9mIHVucmVwbGFjZWQgY29udGVudCBvbiBzaXRlcy5cbiAgICAgICAgICAgIC8vIFRoZSByZWFzb24gdGhpcyB3b3JrcyBpcyBiZWNhdXNlIF9yZXBsYWNlbWVudHMgcmVmZXJlbmNlcyBjbG9uZSwgd2hpY2ggaXNuJ3QgdmlzaWJsZSB1bnRpbCBhbG1vc3QgdGhlIGxhc3QgbGluZS5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUh0bWxSZXBsYWNlbWVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgZnJvbnQtZW5kIHRleHQuIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgdGhpbmcgdG8gcmVwbGFjZS4gT3RoZXJ3aXNlLCB5b3UncmUganVzdCB3aXBpbmcgb3V0IHBlcmZlY3RseVxuICAgICAgICAvLyB2YWxpZCBIVE1MNSByZWZlcmVuY2VzIGZvciBubyByZWFzb24uXG4gICAgICAgIGlmICh0aGlzLl9yZXBsYWNlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvIGEgZnVsbCB1cGRhdGUgaWYgcmVxdWVzdGVkIHRvXG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldEh0bWxUZW1wbGF0ZSh0ZW1wbGF0ZVByb3BlcnR5ID0gJy4nLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRUZW1wbGF0ZSgnPGktdiBub2VzY2FwZT4nICsgdGVtcGxhdGVQcm9wZXJ0eSArICc8L2ktdj4nLCB1cGRhdGUpO1xuICAgIH1cbiAgICBzZXRUZXh0VGVtcGxhdGUodGVtcGxhdGVQcm9wZXJ0eSA9ICcuJywgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0VGVtcGxhdGUoJzxpLXY+JyArIHRlbXBsYXRlUHJvcGVydHkgKyAnPC9pLXY+JywgdXBkYXRlKTtcbiAgICB9XG4gICAgc2V0TG9vcChzb3VyY2UgPSAnLicsIGZyYWdtZW50LCBza2lwUG9zdFByb2Nlc3MgPSBmYWxzZSwgdXBkYXRlID0gZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UgfHwgIWZyYWdtZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcmFnbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gQ3JlYXRlRWxlbWVudF8xLmNyZWF0ZUZyYWdtZW50KGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb29wID0geyBzb3VyY2UsIHBvc3RQcm9jZXNzOiAhc2tpcFBvc3RQcm9jZXNzLCBmcmFnbWVudCwgb3RoZXJDb21wb25lbnRJZCB9O1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVMb29wKHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHNldFZhbHVlQXR0cmlidXRlKHNvdXJjZSA9ICcuJywgdXBkYXRlID0gZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVBdHRyaWJ1dGUgPSB7IHNvdXJjZSwgb3RoZXJDb21wb25lbnRJZCB9O1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRWaXNpYmlsaXR5KHNvdXJjZSA9ICcuJywgbmVnYXRpdmUgPSBmYWxzZSwgdXBkYXRlID0gZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nzc0Rpc3BsYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jc3NEaXNwbGF5ID0geyBzb3VyY2UsIG5lZ2F0aXZlLCBvdGhlckNvbXBvbmVudElkIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkQXR0cmlidXRlTWFwcGluZyhhdHRyaWJ1dGUsIHNvdXJjZSA9ICcuJywgdXBkYXRlID0gZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpIHtcbiAgICAgICAgaWYgKCFzb3VyY2UgfHwgIWF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGJpbmQgYSBzaW5nbGUgcHJvcGVydHkgdG8gbXVsdGlwbGUgdGhpbmdzXG4gICAgICAgIGlmICghdGhpcy5fYXR0cmlidXRlQmluZGluZ3MuZmluZChmID0+IGYuYXR0cmlidXRlID09PSBhdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVCaW5kaW5ncy5wdXNoKHsgYXR0cmlidXRlLCBzb3VyY2UsIGJvb2w6IGZhbHNlLCBuZWdhdGl2ZTogZmFsc2UsIG90aGVyQ29tcG9uZW50SWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkQm9vbGVhbkF0dHJpYnV0ZU1hcHBpbmcoYXR0cmlidXRlLCBzb3VyY2UgPSAnLicsIG5lZ2F0aXZlID0gZmFsc2UsIHVwZGF0ZSA9IGZhbHNlLCBvdGhlckNvbXBvbmVudElkKSB7XG4gICAgICAgIGlmICghc291cmNlIHx8ICFhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCBiaW5kIGEgc2luZ2xlIHByb3BlcnR5IHRvIG11bHRpcGxlIHRoaW5nc1xuICAgICAgICBpZiAoIXRoaXMuX2F0dHJpYnV0ZUJpbmRpbmdzLmZpbmQoZiA9PiBmLmF0dHJpYnV0ZSA9PT0gYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlQmluZGluZ3MucHVzaCh7IGF0dHJpYnV0ZSwgc291cmNlLCBib29sOiB0cnVlLCBuZWdhdGl2ZSwgb3RoZXJDb21wb25lbnRJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVBdHRyaWJ1dGVNYXBwaW5nKGF0dHJpYnV0ZSwgdXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0gdGhpcy5fYXR0cmlidXRlQmluZGluZ3MuZmlsdGVyKGYgPT4gZi5hdHRyaWJ1dGUgIT09IGF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZUJpbmRpbmdzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZUJpbmRpbmdzLnB1c2goLi4uZmlsdGVyZWQpO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRDc3NDbGFzcyhjbHMgPSAnLicsIHVwZGF0ZSA9IGZhbHNlLCBvdGhlckNvbXBvbmVudElkKSB7XG4gICAgICAgIHRoaXMuX2Nzc0NsYXNzZXMgPSB7IGNzc0NsYXNzOiBjbHMsIG90aGVyQ29tcG9uZW50SWQgfTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc2V0Q3NzU3R5bGUoc3R5bGUgPSAnLicsIHVwZGF0ZSA9IGZhbHNlLCBvdGhlckNvbXBvbmVudElkKSB7XG4gICAgICAgIHRoaXMuX2Nzc1N0eWxlID0geyBzdHlsZSwgb3RoZXJDb21wb25lbnRJZCB9O1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRDc3NDbGFzc1N3aXRjaChjbHMsIHNvdXJjZSA9ICcuJywgbmVnYXRpdmUgPSBmYWxzZSwgdXBkYXRlID0gZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpIHtcbiAgICAgICAgaWYgKCFjbHMgfHwgIXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IGJpbmQgYSBzaW5nbGUgcHJvcGVydHkgdG8gbXVsdGlwbGUgdGhpbmdzXG4gICAgICAgIGlmICghdGhpcy5fY3NzQ2xhc3NTd2l0Y2hlcy5maW5kKGYgPT4gZi5jbGFzcyA9PT0gY2xzKSkge1xuICAgICAgICAgICAgdGhpcy5fY3NzQ2xhc3NTd2l0Y2hlcy5wdXNoKHsgY2xhc3M6IGNscywgc291cmNlLCBuZWdhdGl2ZSwgb3RoZXJDb21wb25lbnRJZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmVDc3NDbGFzc1N3aXRjaChjbHMsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghY2xzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHRoaXMuX2Nzc0NsYXNzU3dpdGNoZXMuZmlsdGVyKGYgPT4gZi5jbGFzcyAhPT0gY2xzKTtcbiAgICAgICAgdGhpcy5fY3NzQ2xhc3NTd2l0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9jc3NDbGFzc1N3aXRjaGVzLnB1c2goLi4uZmlsdGVyZWQpO1xuICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRXcml0ZUV2ZW50KCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLndyaXRlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkV3JpdGVUYXJnZXQodGFyZ2V0ID0gJy4nLCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgYmluZCBhIHNpbmdsZSBwcm9wZXJ0eSB0byBtdWx0aXBsZSB0aGluZ3NcbiAgICAgICAgaWYgKCF0aGlzLl93cml0ZVRhcmdldHMuZmluZChmID0+IGYgPT09IHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3dyaXRlVGFyZ2V0cy5wdXNoKHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlV3JpdGVUYXJnZXQodGFyZ2V0LCB1cGRhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB0aGlzLl93cml0ZVRhcmdldHMuZmlsdGVyKGYgPT4gZiAhPT0gdGFyZ2V0KTtcbiAgICAgICAgdGhpcy5fd3JpdGVUYXJnZXRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX3dyaXRlVGFyZ2V0cy5wdXNoKC4uLmZpbHRlcmVkKTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBdXRvLUluamVjdCBjYWxscyB0aGUgZGVmYXVsdCBpbmplY3RCaW5kKCkgb24gdGhlIGRlZmF1bHQgQm91bmRDb21wb25lbnQgY2xhc3MsIHdpdGggbm8gb3B0aW9ucyBleGNlcHQgc2VsZWN0b3IuXG4gICAgICogSWYgeW91IHBhc3Mgbm8gaW5wdXRzLCBpdCBzZWVrcyBvdXQgYWxsIGNoaWxkIGVsZW1lbnRzIHRoYXQgaGF2ZSBhdCBsZWFzdCBvbmUgaWNoaWdvIGN1c3RvbSBwcm9wZXJ0eS4gS2VlcCBpbiBtaW5kXG4gICAgICogdGhhdCB3aGVuIHlvdSBoYXZlIG5lc3RlZCBvYmplY3RzLCB0aGlzIHdpbGwgdXN1YWxseSBtZWFuIHNvbWV0aGluZyB3aWxsIGJsb3cgdXAgYmVjYXVzZSB5b3UgdHJpZWQgdG8gYmluZCBhbiBlbGVtZW50XG4gICAgICogdHdpY2UuIEl0IGFsc28gd2lsbCBwZXJmb3JtIG11Y2ggd29yc2UuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgcGFzcyBhIHNlbGVjdG9yLCBpdCBhY3RzIHRoZSBzYW1lIGFzIEJvdW5kQ29tcG9uZW50LmluamVjdEJpbmQoKSB3aXRoIHRoYXQgc2VsZWN0b3IuXG4gICAgICpcbiAgICAgKiBJbiBteSBleHBlcmllbmNlLCB0aGlzIGlzIGFsbW9zdCBjb21wbGV0ZWx5IHVzZWxlc3MuIEVpdGhlciB0aGUgbGFjayBvZiBvcHRpb25zIGJyZWFrcyBpdCAocHJldHR5IHVzZWxlc3MgaWYgeW91IGNhbid0XG4gICAgICogb2JzZXJ2ZSBhbiBvYnNlcnZhYmxlKSBvciB0aGUgc2ltcGxlIGFjdCBvZiBiaW5kaW5nIGJyZWFrcyBzdHVmZi5cbiAgICAgKi9cbiAgICBhdXRvSW5qZWN0KHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgQm91bmRDb21wb25lbnQuaW5qZWN0QmluZCh0aGlzLnZpZXdNb2RlbCwgc2VsZWN0b3IsIHsgcGFyZW50OiB0aGlzLmNvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBBcnJheS5mcm9tKGUuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZS5zdGFydHNXaXRoKCdpNV8nKSB8fCBhdHRyLm5hbWUuc3RhcnRzV2l0aCgnOicpIHx8IGF0dHIubmFtZS5zdGFydHNXaXRoKCdkYXRhLWk1XycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBCb3VuZENvbXBvbmVudC5pbmplY3RCaW5kKHRoaXMudmlld01vZGVsLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byB1bmJpbmQgYSB2aWV3IGZyb20gYW4gb2JzZXJ2YWJsZS5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAoQ29tcG9uZW50TWFwXzEuQ29tcG9uZW50TWFwLmNvbXBvbmVudHMpIHtcbiAgICAgICAgICAgIENvbXBvbmVudE1hcF8xLkNvbXBvbmVudE1hcC5jb21wb25lbnRzLmRlbGV0ZSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgaWYgeW91IG5lZWQgdG8gZG8gc29tZXRoaW5nIGVsc2UgYWZ0ZXIgdGhlIGxvb3AgaXMgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgKi9cbiAgICBsb29wUG9zdFByb2Nlc3Mocm93LCBhZGRlZENvbnRlbnQsIGFsbFJvd3MsIHByZXZpb3VzQ29udGVudCkge1xuICAgICAgICBpZiAoIWFkZGVkQ29udGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgdHlwZXNjcmlwdCBwYXJ0IG9mIHRoZSBmb2xsb3dpbmcgd2VyZSBpbXBvcnRhbnQsIHRoaXMgd291bGQgYmUgYSBwcm9ibGVtXG4gICAgICAgIC8vIGlmIHRoaXMgd2VyZSBhIGRlcml2ZWQgY2xhc3MuXG4gICAgICAgIGNvbnN0IHRoaXNjbGFzcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gUXVlcnlTZWxlY3Rvck5vZGVMaXN0XzEubm9kZUxpc3RTZWxlY3RvckFsbChhZGRlZENvbnRlbnQsICdbaTVfaXRlbV0sIFtcXFxcMDAwMDNBaXRlbV0sIFtkYXRhLWk1X2l0ZW1dJyk7XG4gICAgICAgIC8vIElmIG5vIGk1X2l0ZW0gbWF0Y2hlcywgdGhlbiBncmFiIHRoZSBmaXJzdCBlbGVtZW50LlxuICAgICAgICBpZiAoIW5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3ROb2RlID0gUXVlcnlTZWxlY3Rvck5vZGVMaXN0XzEubm9kZUxpc3RTZWxlY3RvcihhZGRlZENvbnRlbnQsICcqJyk7XG4gICAgICAgICAgICBpZiAoZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChmaXJzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9vcEl0ZW1DbGFzcy5pbmplY3RCaW5kKHJvdywgbm9kZXMsIHtcbiAgICAgICAgICAgIHJlcGxhY2U6IGZhbHNlLFxuICAgICAgICAgICAgbG9vcFBhcmVudDogdGhpcyxcbiAgICAgICAgICAgIGFzeW5jOiB0aGlzLl9hc3luY1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFN0cmluZ1ZhbHVlKG5hbWUsIHNraXBFc2NhcGUgPSBmYWxzZSwgc291cmNlQ29tcG9uZW50SWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9nZXRVbnR5cGVkVmFsdWUobmFtZSwgc291cmNlQ29tcG9uZW50SWQpO1xuICAgICAgICBpZiAoTm9uZVR5cGVfMS5pc05vbmUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNraXBFc2NhcGUgPyB2YWx1ZSA6IEVzY2FwZUh0bWxfMS5lc2NhcGVIdG1sKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBza2lwRXNjYXBlID8gdmFsdWUudG9TdHJpbmcoKSA6IEVzY2FwZUh0bWxfMS5lc2NhcGVIdG1sKHZhbHVlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9nZXRVbnR5cGVkVmFsdWUobmFtZSwgc291cmNlQ29tcG9uZW50SWQpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBzb3VyY2U7XG4gICAgICAgIGlmIChzb3VyY2VDb21wb25lbnRJZCkge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gQ29tcG9uZW50TWFwXzEuZ2V0Q29tcG9uZW50KHNvdXJjZUNvbXBvbmVudElkKSB8fCBjb21wb25lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSSdtIHByZXR0eSBzdXJlIHRoaXMgaXMgYmVpbmcgdmFsaWRhdGVkIGR1cmluZyBjb25zdHJ1Y3Rpb24gYnV0IGJlIHNhZmVcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRoaXNBcmcgPSBjb21wb25lbnQudmlld01vZGVsO1xuICAgICAgICAvLyBJZiBWTSBpcyBhIHN0YXRlLCBnZXQgdGhlIGN1cnJlbnQgc3RhdGUgdmFsdWUuXG4gICAgICAgIGlmIChPYnNlcnZhYmxlU3RhdGVfMS5vYnNlcnZhYmxlU3RhdGVDaGVjayh0aGlzQXJnKSkge1xuICAgICAgICAgICAgdGhpc0FyZyA9IHRoaXNBcmcudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgndGhpcy4nKSkge1xuICAgICAgICAgICAgdGhpc0FyZyA9IGNvbXBvbmVudDtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDUpO1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBjb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoaXMuJHtuYW1lfSBkb2VzIG5vdCBleGlzdCBvbiB2aWV3LmApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IGNvbXBvbmVudFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ14nKSAmJiBFbHZpc18xLmVfKGNvbXBvbmVudC5sb29wUGFyZW50KS52aWV3TW9kZWwgJiYgdHlwZW9mIEVsdmlzXzEuZV8oY29tcG9uZW50Lmxvb3BQYXJlbnQpLnZpZXdNb2RlbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IE5vdCBkb2luZyBhICdeJyBieSBpdHNlbGYgYmVjYXVzZSB0aGF0J3MgYSBwcmV0dHkgQlMgY2FzZS4gSWYgdGhpcyBpcyB0aGUgbG9vcCBjaGlsZCwgdGhlIHBhcmVudCBpcyBwcm9iYWJseVxuICAgICAgICAgICAgLy8gYW4gb2JqZWN0IG9yIGFuIGl0ZXJhYmxlLCBub3QgcmVhbGx5IHNvbWV0aGluZyB5b3UnbGwgcmVhZCBvciB3cml0ZSB0byBkaXJlY3RseS5cbiAgICAgICAgICAgIC8vIE1pZ2h0IGRvIGEgc2hvcnRjdXQgdG8gdGhlIHBhcmVudCBjb21wb25lbnQncyAndGhpcydcbiAgICAgICAgICAgIHRoaXNBcmcgPSBjb21wb25lbnQubG9vcFBhcmVudC52aWV3TW9kZWw7XG4gICAgICAgICAgICBpZiAoIShuYW1lLnNsaWNlKDEpIGluIHRoaXNBcmcpKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gZG9lcyBub3QgZXhpc3Qgb24gdmlld01vZGVsIHBhcmVudCB2aWV3IG1vZGVsLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXNBcmdbbmFtZS5zbGljZSgxKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzQXJnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzQXJnID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiB0aGlzQXJnKSkge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGlzLiR7bmFtZX0gZG9lcyBub3QgZXhpc3Qgb24gdmlld01vZGVsLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZSA9IHRoaXNBcmdbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ09OU0lERVI6IENvbnNpZGVyIGFkZGluZyBjdXN0b20gYXR0cmlidXRlcyB0byBhbGxvdyBleGVjdXRpbmcgbWV0aG9kIHdpdGggc3RyaW5nIHBhcmFtZXRlcnMuIGk1X3BhcmFtMDE9XCJ2YWwgMVwiLCBpNV9wYXJhbTAyPVwidmFsIDJcIlxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5jYWxsKHRoaXNBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9ic2VydmFibGVQcm9wZXJ0eV8xLm9ic2VydmFibGVQcm9wZXJ0eUNoZWNrKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVIdG1sUmVwbGFjZW1lbnRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlcGwgb2YgdGhpcy5fcmVwbGFjZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX2dldFN0cmluZ1ZhbHVlKHJlcGwuc291cmNlLCByZXBsLm5vZXNjYXBlLCByZXBsLm90aGVyQ29tcG9uZW50SWQpIHx8ICcnO1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlcGwuZWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb25maWd1cmVDb21wb25lbnRCaW5kaW5ncygpIHtcbiAgICAgICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBBcnJheS5mcm9tKHRoaXMuY29udGVudC5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLmZpbHRlcihmID0+IGYudmFsdWUgfHwgZi5uYW1lID09PSAnaTVfaW5wdXQnIHx8IGYubmFtZSA9PT0gJzppbnB1dCcpXG4gICAgICAgICAgICAubWFwKG0gPT4gKHtcbiAgICAgICAgICAgIG5hbWU6IG0ubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBtLnZhbHVlIHx8ICcnXG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgaXQncyBpbnZhbGlkIHRvIGFkZCBjdXN0b20gYXR0cmlidXRlcyB0byByZWd1bGFyIGVsZW1lbnRzLCBzbyB0ZWNobmljYWxseSA8cmVwbGFjZS1tZSA6c3dpdGNoOnJlZHRleHQ9XCJ3YXJuaW5nXCI+XG4gICAgICAgIC8vIGlzIGxlZ2FsIGJ1dCBpZiBpZiBpdCB3ZXJlIGEgZGl2LCB0aGF0IHdvdWxkIGJlIGlsbGVnYWwuIFNvIHdlJ2xsIGFsbG93IDxkaXYgZGF0YS1pNV9zd2l0Y2hfcmVkdGV4dD1cIndhcm5pbmdcIj4uXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGUgd2VpcmQgbmFtZSBoYW5kbGluZyBvZiBkYXRhIGF0dHJpYnV0ZXMgY291bGQgYnJlYWsgeW91ciBjb2RlIGlmIHlvdSB0cnkgdG8gdXNlIHRoaXMuIFlvdSBtYXkgbmVlZCB0byBkbyBleHRyYVxuICAgICAgICAvLyB3b3JrIHRvIG1ha2UgeW91ciBjb2RlIHdvcmssIGFsbCBpbiB0aGUgbmFtZSBvZiBzdHJpY3QgYWRoZXJlbmNlIHRvIHN0YW5kYXJkcy4gSXQncyB1cCB0byB5b3UuXG4gICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzLmNvbnRlbnQuZGF0YXNldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jb250ZW50LmRhdGFzZXRbYXR0cl07XG4gICAgICAgICAgICBpZiAodmFsdWUgfHwgYXR0ciA9PT0gJ2k1X2lucHV0Jykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnB1c2goeyBuYW1lOiBhdHRyLCB2YWx1ZTogdmFsdWUgfHwgJycgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBhbHRlcm5hdGUgc291cmNlIElkXG4gICAgICAgIGNvbnN0IG90aGVyQ29tcG9uZW50SWQgPSBFbHZpc18xLmVfKGN1cnJlbnRBdHRyaWJ1dGVzLmZpbmQoZiA9PiBmLm5hbWUgPT09ICdpNV9zb3VyY2UnIHx8IGYubmFtZSA9PT0gJzpzb3VyY2UnKSkudmFsdWU7XG4gICAgICAgIGxldCB0ZXh0SHRtbFNldCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgY3VycmVudEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLl9wYXJzZUF0dHJpYnV0ZU5hbWUocHJvcC5uYW1lKTtcbiAgICAgICAgICAgIGxldCBuZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gUmVndWxhciBhdHRyaWJ1dGVzIHdpbGwgYWxsIG1hdGNoIHRoaXMuXG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xOZWdhdGl2ZVwiOlxuICAgICAgICAgICAgICAgICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlLmRldGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZyBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9vbGVhbkF0dHJpYnV0ZU1hcHBpbmcodHlwZS5kZXRhaWwsIHByb3AudmFsdWUsIG5lZ2F0aXZlLCBmYWxzZSwgb3RoZXJDb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVySWZOZWVkZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlLmRldGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZyBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlTWFwcGluZyh0eXBlLmRldGFpbCwgcHJvcC52YWx1ZSwgZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcklmTmVlZGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzd2l0Y2hDbGFzc05lZ2F0aXZlXCI6XG4gICAgICAgICAgICAgICAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlIFwic3dpdGNoQ2xhc3NcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlLmRldGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZyBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ3NzQ2xhc3NTd2l0Y2godHlwZS5kZXRhaWwsIHByb3AudmFsdWUsIG5lZ2F0aXZlLCBmYWxzZSwgb3RoZXJDb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVySWZOZWVkZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRIdG1sU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzZXQgaTVfdGV4dCBhbmQgaTVfaHRtbCBhdCBzYW1lIHRpbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGV4dEh0bWxTZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuaW5uZXJIVE1MID0gYDxpLXY+JHtwcm9wLnZhbHVlfTwvaS12PmA7IC8vIFVzZSB0aGlzIGFzIHRoZSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBkZWZlcklmTmVlZGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0SHRtbFNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2V0IGk1X3RleHQgYW5kIGk1X2h0bWwgYXQgc2FtZSB0aW1lXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRleHRIdG1sU2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IGA8aS12IG5vZXNjYXBlPiR7cHJvcC52YWx1ZX08L2ktdj5gOyAvLyBVc2UgdGhpcyBhcyB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJJZk5lZWRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0dHJpYnV0ZShwcm9wLnZhbHVlLCBmYWxzZSwgb3RoZXJDb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVySWZOZWVkZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImlmTmVnYXRpdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgXCJpZlwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkocHJvcC52YWx1ZSwgbmVnYXRpdmUsIGZhbHNlLCBvdGhlckNvbXBvbmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJJZk5lZWRlZC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDc3NTdHlsZShwcm9wLnZhbHVlLCBmYWxzZSwgb3RoZXJDb21wb25lbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmVySWZOZWVkZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3NzQ2xhc3MocHJvcC52YWx1ZSwgZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcklmTmVlZGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFdyaXRlRXZlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9wLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVsc2UgZmFsbCB0aHJvdWdoLCB1c2luZyB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGF0dHJpYnV0ZSBhcyBhIHRhcmdldCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0IGk1X2lucHV0X2ZvbyBpcyB0aGUgc2FtZSBhcyBpNV90YXJnZXQ9XCJmb29cIiBpNV92YWx1ZT1cImZvb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgb25seSB3cml0ZSB0byB0aGUgbG9jYWwgdmlldyBtb2RlbCwgbm90IGFub3RoZXIgY29tcG9uZW50J3NcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlLmRldGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZUF0dHJpYnV0ZShwcm9wLnZhbHVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidGFyZ2V0XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkV3JpdGVUYXJnZXQocHJvcC52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcklmTmVlZGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsb29wXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgdGhlIGJhc2UgY29udGVudCBmb3IgdGhlIGxvb3AsIHB1bGxpbmcgaXQgb3V0IG9mIHRoZSBET00uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9vcChwcm9wLnZhbHVlLCBFeHRyYWN0Tm9kZUNvbnRlbnRfMS5leHRyYWN0Tm9kZUNvbnRlbnQodGhpcy5jb250ZW50KSwgdHlwZS5kZXRhaWwgPT09ICdudWxsJywgZmFsc2UsIG90aGVyQ29tcG9uZW50SWQpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcklmTmVlZGVkLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpdGVtXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgdXNlZCBhcyBhIHNlbGVjdG9yLiBIYXMgbm8gZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgSW1wbGVtZW50ZWQgSWNoaWdvIGF0dHJpYnV0ZTogXCIgKyB0eXBlLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZGVmZXJJZk5lZWRlZCgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWZlciA9IHRoaXMuX2RlZmVyIHx8IHByb3AudmFsdWUuc3RhcnRzV2l0aCgndGhpcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfcGFyc2VBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICAgICAgICAvLyBHZW5lcmFsIGljaGlnbyBzaG9ydGN1dFxuICAgICAgICAgICAgbmFtZSA9ICdpNV8nICsgbmFtZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSA9PT0gJ2k1X2l0ZW0nKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gaW5kaWNhdGUgYW4gaXRlbSBjb21wb25lbnQsIG5vdGhpbmcgZWxzZS5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnaTVfc291cmNlJykge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGluZGljYXRlIGEgc291cmNlIGNvbXBvbmVudC4gSXQncyByZWFkIHNlcGFyYXRlbHkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSA9PT0gJ2k1X2V2ZW50Jykge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB1c2VkIG9ubHkgaW4gQ29tcG9uZW50LmFkZElubGluZUV2ZW50TGlzdGVuZXJzKCkuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW5hbWUuc3RhcnRzV2l0aCgnaTVfJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKCdpNV9hdHRyJykpIHtcbiAgICAgICAgICAgIGlmIChuYW1lWzddICE9PSAnOicgJiYgbmFtZVs3XSAhPT0gJ18nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBiaW5kaW5nIHN5bnRheCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUubGVuZ3RoIDwgOSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpbmRpbmcgYXR0cmlidXRlIG5hbWUgaXMgbWlzc2luZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnYXR0cicsIGRldGFpbDogbmFtZS5zbGljZSg4KSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaTVfYm9vbCcpKSB7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuYW1lWzddICE9PSAnOicgJiYgbmFtZVs3XSAhPT0gJ18nICYmIG5hbWVbN10gIT09ICctJyAmJiBuYW1lWzddICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGJpbmRpbmcgc3ludGF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZVs3XSA9PT0gJy0nIHx8IG5hbWVbN10gPT09ICcwJykge1xuICAgICAgICAgICAgICAgIG5lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCA3KSArIG5hbWUuc2xpY2UoOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPCA5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmluZGluZyBhdHRyaWJ1dGUgbmFtZSBpcyBtaXNzaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IG5lZ2F0aXZlID8gJ2Jvb2xOZWdhdGl2ZScgOiAnYm9vbCcsIGRldGFpbDogbmFtZS5zbGljZSg4KSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaTVfc3dpdGNoJykpIHtcbiAgICAgICAgICAgIGxldCBuZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKG5hbWVbOV0gIT09ICc6JyAmJiBuYW1lWzldICE9PSAnXycgJiYgbmFtZVs5XSAhPT0gJy0nICYmIG5hbWVbOV0gIT09ICcwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzd2l0Y2ggYmluZGluZyBzeW50YXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYW1lWzldID09PSAnLScgfHwgbmFtZVs5XSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNsaWNlKDAsIDkpICsgbmFtZS5zbGljZSgxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZS5sZW5ndGggPCAxMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsYXNzIHN3aXRjaCBuYW1lIGlzIG1pc3NpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogbmVnYXRpdmUgPyAnc3dpdGNoQ2xhc3NOZWdhdGl2ZScgOiAnc3dpdGNoQ2xhc3MnLCBkZXRhaWw6IG5hbWUuc2xpY2UoMTApIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdpNV9pZicpKSB7XG4gICAgICAgICAgICBsZXQgbmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChuYW1lLnNsaWNlKC0xKSA9PT0gJy0nIHx8IG5hbWUuc2xpY2UoLTEpID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBuZWdhdGl2ZSA/ICdpZk5lZ2F0aXZlJyA6ICdpZicgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2k1X2xvb3AnKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdpNV9sb29wOm51bGwnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2xvb3AnLCBkZXRhaWw6ICdudWxsJyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2xvb3AnIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKCdpNV90YXJnZXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuICh7IHR5cGU6ICd0YXJnZXQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aCgnaTVfaW5wdXQnKSkge1xuICAgICAgICAgICAgY29uc3QgdHdvV2F5ID0gbmFtZS5lbmRzV2l0aCgnX3ZhbHVlJykgfHwgbmFtZS5lbmRzV2l0aCgnOicpO1xuICAgICAgICAgICAgcmV0dXJuICh7IHR5cGU6ICdpbnB1dCcsIGRldGFpbDogdHdvV2F5ID8gJzJ3YXknIDogJycgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogbmFtZS5zbGljZSgzKSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQm91bmRDb21wb25lbnQgPSBCb3VuZENvbXBvbmVudDtcbi8vIFVzZSBhIGN1c3RvbSBlbGVtZW50IHRvIGNyZWF0ZSBhIHJlcGxhY2VtZW50IHRhZyB0aGF0IGlzIG5vdCBsaW1pdGVkLCBhcyBzcGFuIGlzLCB0byBjb250YWluaW5nIG5vIGJsb2NrIGVsZW1lbnRzLlxuLy8gTm8gbG9naWMsIG5vIHNwZWNpYWwgZGlzcGxheSBkZXRhaWxzLlxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZW1wbGF0ZVJlcGxhY2VtZW50VmFsdWUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZW1wbGF0ZVJlcGxhY2VtZW50VmFsdWUgPSBUZW1wbGF0ZVJlcGxhY2VtZW50VmFsdWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENyZWF0ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL0NyZWF0ZUVsZW1lbnRcIik7XG5jb25zdCBFbGVtZW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRWxlbWVudFR5cGVcIik7XG5jb25zdCBGb3JtRmllbGRWYWx1ZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRm9ybUZpZWxkVmFsdWVcIik7XG5jb25zdCBRdWVyeVNlbGVjdG9yTm9kZUxpc3RfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL1F1ZXJ5U2VsZWN0b3JOb2RlTGlzdFwiKTtcbmNvbnN0IEtleXdvcmRBcmd1bWVudHNfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVHlwZXMvS2V5d29yZEFyZ3VtZW50c1wiKTtcbmNvbnN0IEdldFVuaXF1ZUlkXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1V0aWxpdHkvR2V0VW5pcXVlSWRcIik7XG5jb25zdCBDb21wb25lbnRNYXBfMSA9IHJlcXVpcmUoXCIuL0NvbXBvbmVudE1hcFwiKTtcbi8qKlxuICogQSBjbGFzcyB3aXRoIGEgY29udGVudCBwcm9wZXJ0eSB0aGF0IHBvaW50cyB0byBzb21ldGhpbmcgb24gdGhlIHBhZ2UsIGFsb25nIHdpdGggc29tZSBvZiBoZWxwZXIgbWV0aG9kcy5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgYSBiYXNlIGNsYXNzIGZvciBvdGhlciBjbGFzc2VzLCBzbyBpdCdzIG1hcmtlZCBhYnN0cmFjdC4gSXQganVzdCBkb2Vzbid0XG4gKiBtYWtlIHNlbnNlIHRvIG1lIHRvIGNyZWF0ZSBDb21wb25lbnQgd2l0aCBub3RoaW5nIGN1c3RvbWl6ZWQuIEp1c3QgY3JlYXRlIGFuIEhUTUxFbGVtZW50LiBUaGUgaGVscGVycyBhcmVuJ3QgcmVhbGx5XG4gKiB0aGF0IGltcHJlc3NpdmUsIHdoZW4geW91IGNvbnNpZGVyIHRoYXQgdGhlIHRyYWRlb2ZmIGlzIGhhdmluZyB0byByZWZlcmVuY2Ugb2JqLmNvbnRlbnQgdG8gbW9kaWZ5IHRoZSBET00uXG4gKi9cbmNsYXNzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICAvLyBUeXBlc2NyaXB0IGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGF0IHRoaXMuY29udGVudCBpcyBzZXQgaW4gQUxMIG9mIHRoZSBwcml2YXRlIGN0b3IgZnVuY3Rpb25zLlxuICAgICAgICB0aGlzLmNvbnRlbnQgPSBudWxsO1xuICAgICAgICBpZiAoYXJncyAmJiB0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIF9jdG9yX3N0cmluZy5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3MgJiYgYXJncy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKGFyZ3MuaW5uZXJIdG1sKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihhcmdzLnByb3BlcnRpZXMgfHwge30sIHsgaW5uZXJIVE1MOiBhcmdzLmlubmVySHRtbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jdG9yX2xvb2t1cC5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhcmdzKSB7XG4gICAgICAgICAgICBfY3Rvcl9lbXB0eS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3MuZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGFyZ3MuaW5uZXJIdG1sKSB7XG4gICAgICAgICAgICAgICAgYXJncy5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihhcmdzLnByb3BlcnRpZXMgfHwge30sIHsgaW5uZXJIVE1MOiBhcmdzLmlubmVySHRtbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jdG9yX2V4aXN0aW5nRWxlbWVudC5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFyZ3Mub3V0ZXJIdG1sKSB7XG4gICAgICAgICAgICBfY3Rvcl9vdXRlckh0bWwuY2FsbCh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9jdG9yX2lubmVySHRtbC5jYWxsKHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoZWNrSW5saW5lRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gQW5ndWxhciBtYXRlcmlhbCBkb2VzIHNvbWV0aGluZyBsaWtlIHRoaXMuIEluIHRoaXMgY2FzZSwgdGhlcmUncyBubyBmdW5jdGlvbmFsaXR5IGJlaGluZCBpdCwgYnV0IGl0IGRvZXMgbWFrZSBpdFxuICAgICAgICAvLyB1c2VmdWwgZm9yIGEgZGV2ZWxvcGVyIHRvIHNlZSB0aGF0IGFuIGVsZW1lbnQgaXMgYSBjb21wb25lbnQgYW5kIHdoYXQgdHlwZSBpdCBpcy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNuYWtlX2Nhc2UgPSAnaXZfJyArIHRoaXMuY29uc3RydWN0b3IubmFtZS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHRoaXMuY29uc3RydWN0b3IubmFtZS5zbGljZSgxKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFcrL2csICcgJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFthLXpdKShbQS1aXSkoW2Etel0pL2csIFwiJDEgJDIkM1wiKVxuICAgICAgICAgICAgICAgIC5zcGxpdCgvXFxCKD89W0EtWl17Mix9KS8pXG4gICAgICAgICAgICAgICAgLmpvaW4oJyAnKVxuICAgICAgICAgICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgICAgICAgICAgLmpvaW4oJ18nKVxuICAgICAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnNldEF0dHJpYnV0ZShzbmFrZV9jYXNlLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBoYXMgc29tZSB3ZWlyZCBuYW1lLCBubyBwcm9ibGVtLiBUaGlzIGlzIGp1c3QgYW4gaW5mbyBmaWVsZCBhbnl3YXkuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXBDb21wb25lbnQoKTtcbiAgICAgICAgZnVuY3Rpb24gX2N0b3JfZW1wdHkoKSB7XG4gICAgICAgICAgICAvLyBObyBhcmd1bWVudHNcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgZmluZSBhcyBsb25nIGFzIFRFbGVtZW50IGlzIERJVi4gTm8gd2F5IHRvIHZlcmlmeSB0aGF0IGFzIGl0J3MgYSB0eXBlc2NyaXB0IGlsbHVzaW9uLiBKUyBkb2Vzbid0IHNlZSB0eXBlIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBDcmVhdGVFbGVtZW50XzEuY3JlYXRlRWxlbWVudChFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCB7IGlkOiBHZXRVbmlxdWVJZF8xLmdldFVuaXF1ZUlkKCkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2N0b3JfbG9va3VwKGV4aXN0aW5nRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGV4aXN0aW5nRWxlbWVudC5cbiAgICAgICAgICAgIC8vIFRoZSBtYWluIHJlYXNvbiBpdCBleGlzdHMgaXMgdGhhdCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCBkb2Vzbid0IHJldHVybiB0aGUgY29ycmVjdCB0eXBlIChpdCdzIG5vdCBnZW5lcmljKSxcbiAgICAgICAgICAgIC8vIHNvIHR5cGVzY3JpcHQgZnJlYWtzIG91dCBhbmQgdGhpbmtzIGl0IHNob3VsZCBiZSBhIFNUUklORywgaW4gc3BpdGUgb2YgdGhlIHR5cGUgZGVmaW5pdGlvbiBub3QgYmVpbmcgYW55dGhpbmdcbiAgICAgICAgICAgIC8vIGxpa2UgdGhhdC4gSXQncyBqdXN0IGVhc2llciB0byB1c2UgdGhpcyB0aGFuIHRvIHJlbWVtYmVyIFwib2gsIHJpZ2h0LCBpIGhhdmUgdG8gdXNlIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoKSwgd2hpY2ggaXMgZ2VuZXJpY1wiLlxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IChleGlzdGluZ0VsZW1lbnQucGFyZW50IHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yKGV4aXN0aW5nRWxlbWVudC5zZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgc2VsZWN0b3IgY291bGQgbm90IGZpbmQgZWxlbWVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbmFzdHkgYnV0IGl0IG1ha2VzIFR5cGVTY3JpcHQgaGFwcHkgd2l0aG91dCBjcmVhdGluZyBhIG5ldyBvYmplY3QgY29weVxuICAgICAgICAgICAgZXhpc3RpbmdFbGVtZW50LmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICAgICAgX2N0b3JfZXhpc3RpbmdFbGVtZW50LmNhbGwodGhpcywgZXhpc3RpbmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfY3Rvcl9leGlzdGluZ0VsZW1lbnQoZXhpc3RpbmdFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQgPSBleGlzdGluZ0VsZW1lbnQuZWxlbWVudDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRyeSBhdHRyaWJ1dGVzICh3aGljaCBhcmUgdGhlIGluaXRpYWwgdmFsdWVzKVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhdHRyIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGV4aXN0aW5nRWxlbWVudC5hdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc2V0QXR0cmlidXRlKGF0dHIsIGV4aXN0aW5nRWxlbWVudC5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuIG92ZXJ3cml0ZSB3aXRoIHByb3BlcnRpZXMgKHdoaWNoIGFyZSBjdXJyZW50KVxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nRWxlbWVudC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmNvbnRlbnQsIGV4aXN0aW5nRWxlbWVudC5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfY3Rvcl9pbm5lckh0bWwobmV3RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gTmV3IGVsZW1lbnQuIFVzZXIgc3BlY2lmaWVzIHRoZSBpbm5lciBIVE1MIGZvciB0aGUgY29udGVudC5cbiAgICAgICAgICAgIC8vIFRoaXMgY291bGQgYmUgYW4gZW1wdHkgb2JqZWN0IGxpa2Uge30sIHByYWN0aWNhbGx5IHRoZSBzYW1lIGFzIGNhbGxpbmcgaXQgd2l0aCBubyBhcmdzXG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHsgaW5uZXJIVE1MOiBuZXdFbGVtZW50LmlubmVySHRtbCB8fCAnJyB9O1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wcywgbmV3RWxlbWVudC5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IENyZWF0ZUVsZW1lbnRfMS5jcmVhdGVFbGVtZW50KG5ld0VsZW1lbnQudHlwZSB8fCBFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCBwcm9wcywgbmV3RWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChuZXdFbGVtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmlkID0gbmV3RWxlbWVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmNvbnRlbnQuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuaWQgPSBHZXRVbmlxdWVJZF8xLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gX2N0b3Jfb3V0ZXJIdG1sKG5ld0VsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIFVzZXIgc3BlY2lmaWVzIHRoZSBmdWxsIEhUTUwgZm9yIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGl0IGNhbid0IGJlIHR5cGUgY2hlY2tlZC4gSlMgY2FuJ3Qgc2VlIHdoYXQgVEVsZW1lbnQgaXMuXG4gICAgICAgICAgICBjb25zdCB0bXBkaXYgPSBDcmVhdGVFbGVtZW50XzEuZGl2KG5ld0VsZW1lbnQub3V0ZXJIdG1sLnRyaW0oKSk7XG4gICAgICAgICAgICBpZiAodG1wZGl2LmNoaWxkTm9kZXMubGVuZ3RoICE9PSAxIHx8ICF0bXBkaXYuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGVySHRtbCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29udGVudCA9IHRtcGRpdi5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgICAgICAgIC8vIEZpcnN0IHRyeSBhdHRyaWJ1dGVzICh3aGljaCBhcmUgdGhlIGluaXRpYWwgdmFsdWVzKVxuICAgICAgICAgICAgaWYgKG5ld0VsZW1lbnQuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYXR0ciBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuZXdFbGVtZW50LmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgbmV3RWxlbWVudC5hdHRyaWJ1dGVzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuIG92ZXJ3cml0ZSB3aXRoIHByb3BlcnRpZXMgKHdoaWNoIGFyZSBjdXJyZW50KVxuICAgICAgICAgICAgaWYgKG5ld0VsZW1lbnQucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZW50LCBuZXdFbGVtZW50LnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3BlY2lmaWVkIElEIHRha2VzIHByZWNlZGVuY2VcbiAgICAgICAgICAgIGlmIChuZXdFbGVtZW50LmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LmlkID0gbmV3RWxlbWVudC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBfY3Rvcl9zdHJpbmcobmV3RWxlbWVudCkge1xuICAgICAgICAgICAgLy8gU3RyaW5nIGJ5IGl0c2VsZiBpcyBhIHNob3J0Y3V0IGZvciBvdXRlckh0bWxcbiAgICAgICAgICAgIF9jdG9yX291dGVySHRtbC5jYWxsKHRoaXMsIHsgb3V0ZXJIdG1sOiBuZXdFbGVtZW50IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIHRvIGNvbnZlcnQgZWxlbWVudHMgdG8gY29tcG9uZW50cy4gSXQncyBtb3N0IHVzZWZ1bCBmb3IgY3VzdG9tIHRhZ3MsIGZvciBleGFtcGxlLCA8bXktY29tcG9uZW50PjwvbXktY29tcG9uZW50Pi5cbiAgICAgKiBJdCB3aWxsIGJlY29tZSA8ZGl2IGlkPVwiZm9vXCI+V2hhdGV2ZXIgdGhlIGNvbXBvbmVudCBjb250ZW50IGlzPC9kaXY+LlxuICAgICAqXG4gICAgICogSXQgZG9lc24ndCBoYXZlIHRvIGJlIGEgY3VzdG9tIHRhZy4gSXQgY291bGQgYmUgYSBjbGFzcywgbGlrZSA8cCBjbGFzcz0nYmluZC10by1tb2RlbFwiPiAoc2VsZWN0b3I9Jy5iaW5kLXRvLW1vZGVsJylcbiAgICAgKiBvciA8cCBpY2hpZ28+IChzZWxlY3Rvcj0nW2ljaGlnb10nKS5cbiAgICAgKlxuICAgICAqIFRvIGNvbXBsZXRlbHkgcmVwbGFjZSB0aGUgZXhpc3RpbmcgZWxlbWVudCAoY29weWluZyBleGlzdGluZyBhdHRyaWJ1dGVzKSBzZW5kIHRoZSByZWxldmFudCBvcHRpb25zLCBwbHVzIHtyZXBsYWNlOiB0cnVlfS5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgS2V5d29yZCBBcmd1bWVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGluamVjdChzZWxlY3RvciA9ICdbaWNoaWdvXScsIG9wdGlvbnMsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgICh7IHNlbGVjdG9yID0gJ1tpY2hpZ29dJywgb3B0aW9ucywgY29uc3RydWN0b3IgfSA9IEtleXdvcmRBcmd1bWVudHNfMS5Ld2FyZy5wYXJzZUFyZ3MoeyBzZWxlY3Rvciwgb3B0aW9ucywgY29uc3RydWN0b3IgfSkpOyAvLyBrd2FyZ2xpbmVcbiAgICAgICAgY29uc3QgbmV3Q29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvciB8fCB0aGlzO1xuICAgICAgICBjb25zdCBvcHQgPSB0aGlzLl9nZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXBsYWNlckZ1bmN0aW9uID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXBsYWNlRWxlbWVudFdpdGhDb21wb25lbnQoZWxlbWVudCwgb3B0LCBuZXdDb25zdHJ1Y3Rvcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlckZ1bmN0aW9uID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb252ZXJ0RWxlbWVudFRvQ29tcG9uZW50KGVsZW1lbnQsIG5ld0NvbnN0cnVjdG9yKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luamVjdChzZWxlY3Rvciwgb3B0LCByZXBsYWNlckZ1bmN0aW9uLCBjb252ZXJ0ZXJGdW5jdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBfaW5qZWN0KHNlbGVjdG9yID0gJ1tpY2hpZ29dJywgb3B0aW9ucywgcmVwbGFjZXJGdW5jdGlvbiwgY29udmVydGVyRnVuY3Rpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBjb25zdCBjb250YWluZXJzID0gdGhpcy5fbG9va1VwQ29udGFpbmVyc1RvSW5qZWN0KHNlbGVjdG9yLCBvcHRpb25zLnBhcmVudCk7XG4gICAgICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIGNvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW4ndCBoYXZlIGR1cGUgSURzIGJlaW5nIGNyZWF0ZWQgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvbnRhaW5lcnMuIFRoZXJlIGFyZSAzIHBsYWNlcyB3aGVyZSBJRCBjYW4gYmUgc2V0LlxuICAgICAgICAgICAgICAgIGlmIChjb250YWluZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgncHJvcGVydGllcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMucHJvcGVydGllcy5pZDsgLy8gRE9NIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdhdHRyaWJ1dGVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0aW9ucy5hdHRyaWJ1dGVzLmlkOyAvLyBIVE1MIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXBsYWNlckZ1bmN0aW9uKGNvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNvbnZlcnRlckZ1bmN0aW9uKGNvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBzdGF0aWMgX21lcmdlUHJvcGVydGllc0FuZEF0dHJpYnV0ZXMoZXhpc3RpbmdFbGVtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoaXMgYXR0ZW1wdHMgdG8gcHJlc2VydmUgdGhlIGF0dHJpYnV0ZXMgc2V0IG9uIHRoZSByZXBsYWNlZCBlbGVtZW50LiBUaGF0IG9wZW5zIGFuIHVnbHkgY2FuIG9mIHdvcm1zLFxuICAgICAgICAvLyBidXQgaXQgc2hvdWxkIG1ha2UgcmVwbGFjZW1lbnQgY29tcG9uZW50cyBtb3JlIHVzZWZ1bCBiZWNhdXNlIGl0IGFsbG93cyB0aGVtIHRvIHZhcnkuXG4gICAgICAgIC8vIEl0IGRvZXMgbWFrZSBhIGJydXRhbCBqdWdnbGluZyBhY3Q6XG4gICAgICAgIC8vIElmIHRoZSBleGlzdGluZyBlbGVtZW50IGhhcyBpbm5lckhUTUwsIHdlIHdhbnQgdG8gdGFrZSBpdC5cbiAgICAgICAgLy8gSWYgb3V0ZXJIVE1MIGlzIHByb3ZpZGVkLCB0aGUgb3V0ZXJIVE1MJ3MgaW5uZXJIVE1MIHNob3VsZCBvdmVycmlkZSB0aGUgZXhpc3RpbmcgZWxlbWVudCdzLlxuICAgICAgICAvLyBJZiB0aGUgZXhpc3RpbmcgZWxlbWVudCBoYXMgYXR0cmlidXRlcywgd2Ugd2FudCB0byB0YWtlIHRoZW0uXG4gICAgICAgIC8vIElmIG91dGVySFRNTCBpcyBwcm92aWRlZCwgdGhlIG91dGVySFRNTCdzIGF0dHJpYnV0ZXMgc2hvdWxkIG92ZXJyaWRlIHRoZW0uXG4gICAgICAgIC8vIEZvciBhbnkgYXR0cmlidXRlcyBwYXNzZWQgaW4gT1BUSU9OUywgdGhleSBzaG91bGQgb3ZlcnJpZGUgYW55dGhpbmcgdGhhdCBjYW1lIGJlZm9yZS5cbiAgICAgICAgLy8gRm9yIGFueSBwcm9wZXJ0aWVzIHBhc3NlZCBpbiBPUFRJT05TLCB0aGV5IHNob3VsZCBvdmVycmlkZSBhbnl0aGluZyB0aGF0IGNhbWUgYmVmb3JlLlxuICAgICAgICAvLyBPbmx5IHRoZSBsYXN0IDIgYXJlIGhhbmRsZWQgaW4gdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3Rvci4gQW5kIGlmIHdlJ3JlIG5vdCBjYXJlZnVsLCB3ZSBjb3VsZCBicmVhayB0aGVtLlxuICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0geyBpbm5lckhUTUw6IGV4aXN0aW5nRWxlbWVudC5pbm5lckhUTUwgfTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgQXJyYXkuZnJvbShleGlzdGluZ0VsZW1lbnQuYXR0cmlidXRlcykpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIC8vIFRoaXMgaXMgdWdseSBiZWNhdXNlIGl0IGhhcHBlbnMgYWdhaW4gaW4gdGhlIGNvbnN0cnVjdG9yLiBObyBvdGhlciBjbGVhbiB3YXkgdG8gcGFyc2UgdGhlIGVsZW1lbnQgYXR0cmlidXRlcywgdGhvdWdoLlxuICAgICAgICBpZiAob3B0Lm91dGVySHRtbCkge1xuICAgICAgICAgICAgY29uc3QgdG1wID0gQ3JlYXRlRWxlbWVudF8xLmRpdihvcHQub3V0ZXJIdG1sLnRyaW0oKSk7XG4gICAgICAgICAgICBpZiAodG1wLmNoaWxkTm9kZXMubGVuZ3RoICE9PSAxIHx8ICF0bXAuZmlyc3RFbGVtZW50Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ091dGVySHRtbCBtdXN0IGNvbnRhaW4gZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRtcDIgPSB0bXAuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgICAgICAvLyBUaGUgb3V0ZXIgSFRNTCBhdHRyaWJ1dGVzIGdldCBwaWNrZWQgdXAgYXV0b21hdGljYWxseSB3aGVuIGFkZGVkIHRvIHRoZSBET00sIHNvIHdlIHJlYWxseVxuICAgICAgICAgICAgLy8ganVzdCBuZWVkIHRvIGRpc2NhcmQgdGhlIG1hdGNoaW5nIHByb3BlcnRpZXMgYW5kIGF0dHJpYnV0ZXMgb2YgdGhlIGV4aXN0aW5nIGVsZW1lbnQuXG4gICAgICAgICAgICBkZWxldGUgcHJvcGVydGllcy5pbm5lckhUTUw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgQXJyYXkuZnJvbSh0bXAyLmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2F0dHIubmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG9wdC5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBvcHQucHJvcGVydGllcyk7XG4gICAgICAgIG9wdC5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihhdHRyaWJ1dGVzLCBvcHQuYXR0cmlidXRlcyk7XG4gICAgICAgIHJldHVybiBvcHQ7XG4gICAgfVxuICAgIHN0YXRpYyBfZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGxldCBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gU2hvcnRjdXQgZm9yIHJlcGxhY2luZyB0aGUgb3V0ZXIgSFRNTFxuICAgICAgICAgICAgb3B0ID0geyByZXBsYWNlOiB0cnVlLCBvdXRlckh0bWw6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAvLyBUeXBlc2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0IG9wdGlvbnMgIT09ICdzdHJpbmcnIChjYW4ndCByZWFkIFwiZWxzZSBpZlwiIGNsYXVzZSlcbiAgICAgICAgICAgIG9wdCA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHQgPSB7IHJlcGxhY2U6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdDtcbiAgICB9XG4gICAgc3RhdGljIF9yZXBsYWNlRWxlbWVudChleGlzdGluZ0VsZW1lbnQsIGNvbXBvbmVudCkge1xuICAgICAgICBpZiAoZXhpc3RpbmdFbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nRWxlbWVudC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChjb21wb25lbnQuY29udGVudCwgZXhpc3RpbmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlcGxhY2VDaGlsZChjb21wb25lbnQuY29udGVudCwgZXhpc3RpbmdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3JlcGxhY2VFbGVtZW50V2l0aENvbXBvbmVudChleGlzdGluZ0VsZW1lbnQsIG9wdGlvbnMsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnN0IG9wdCA9IHRoaXMuX21lcmdlUHJvcGVydGllc0FuZEF0dHJpYnV0ZXMoZXhpc3RpbmdFbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gbmV3IGNvbnN0cnVjdG9yKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLl9yZXBsYWNlRWxlbWVudChleGlzdGluZ0VsZW1lbnQsIGNvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBjb21wb25lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBfY29udmVydEVsZW1lbnRUb0NvbXBvbmVudChleGlzdGluZ0VsZW1lbnQsIGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgY29uc3RydWN0b3IoeyBlbGVtZW50OiBleGlzdGluZ0VsZW1lbnQgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBfbG9va1VwQ29udGFpbmVyc1RvSW5qZWN0KHNlbGVjdG9yID0gJ1tpY2hpZ29dJywgcGFyZW50KSB7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSSd2ZSBkb25lIHRoaXMgbXlzZWxmLCB3aGljaCByZXN1bHRzIGluIGEgc2lsZW50IGZhaWx1cmUgaWYgYWNjaWRlbnRhbC5cbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0luamVjdGlvbiBzZWxlY3RvciBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgfHwgJ1tpY2hpZ29dJztcbiAgICAgICAgLy8gTG9vayB1cCB0aGUgZWxlbWVudHMgdG8gZWl0aGVyIHJlcGxhY2Ugb3IgY29udmVydFxuICAgICAgICBsZXQgY29udGFpbmVycztcbiAgICAgICAgaWYgKHBhcmVudCAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQgfHwgZG9jdW1lbnQ7XG4gICAgICAgICAgICBjb250YWluZXJzID0gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcnMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzZWxlY3RvciBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgICAgICAgICBjb250YWluZXJzID0gQXJyYXkuZnJvbShzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RvcikpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcnMgPSBzZWxlY3RvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcnMgPSBbc2VsZWN0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250YWluZXJzO1xuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuaWQ7XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQuaWQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGlubmVySFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5pbm5lckhUTUw7XG4gICAgfVxuICAgIHNldCBpbm5lckhUTUwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LmlubmVySFRNTCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIC8vIFdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiBjb250ZW50IGlzIG5vdCBhIGZvcm0gZmllbGQgdHlwZVxuICAgICAgICByZXR1cm4gRm9ybUZpZWxkVmFsdWVfMS5nZXRGb3JtRmllbGRWYWx1ZSh0aGlzLmNvbnRlbnQpO1xuICAgIH1cbiAgICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICAgICAgLy8gV2lsbCBsb2cgYSB3YXJuaW5nIGlmIGNvbnRlbnQgaXMgbm90IGEgZm9ybSBmaWVsZCB0eXBlXG4gICAgICAgIEZvcm1GaWVsZFZhbHVlXzEuc2V0Rm9ybUZpZWxkVmFsdWUodGhpcy5jb250ZW50LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldCBjbGFzc05hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuY2xhc3NOYW1lO1xuICAgIH1cbiAgICBzZXQgY2xhc3NOYW1lKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5jbGFzc05hbWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGNsYXNzTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5jbGFzc0xpc3Q7XG4gICAgfVxuICAgIGdldCBzdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5zdHlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGFuIEhUTUwgZXZlbnQgbGlzdGVuZXIgb24gdGhlIENvbXBvbmVudCBjb250ZW50LiBGbHVlbnQuXG4gICAgICovXG4gICAgYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY29udGVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VhcmNoIHRoZSBIVE1MIGZvciBpNV9ldmVudCBvciA6ZXZlbnQgYXR0cmlidXRlcyBhbmQgYWRkIGV2ZW50IGxpc3RlbmVycyBhY2NvcmRpbmcgdG8gaW5saW5lIGN1c3RvbSBhdHRyaWJ1dGVzLlxuICAgICAqIEZpbHRlciBieSBtYXRjaGluZyB0aGUgY29tcG9uZW50RmlsdGVyIGlucHV0IHdpdGggYW4gYXR0cmlidXRlIGxpa2UgY29tcG9uZW50PVwiY29tcG9uZW50RmlsdGVyXCIuXG4gICAgICogRW5jbG9zZSB0aGUgZXZlbnQgdHlwZSBpbiBwYXJlbnRoZXNlcywgYW5kIGZvciB0aGUgdmFsdWUsIGVudGVyIHRoZSBuYW1lIG9mIGEgbWV0aG9kIGluIHRoaXMgY29tcG9uZW50LlxuICAgICAqIEV4YW1wbGU6IDxmb3JtIDpldmVudCAoY2xpY2spPVwic3VibWl0VGhlRm9ybVwiPjwvZm9ybT5cbiAgICAgKiBUaGlzIGlzIGFsc28gYWxsb3dlZDogPGZvcm0gOmV2ZW50IF9jbGlja189XCJzdWJtaXRUaGVGb3JtXCI+PC9mb3JtPlxuICAgICAqL1xuICAgIGFkZElubGluZUV2ZW50TGlzdGVuZXJzKGNvbXBvbmVudEZpbHRlcikge1xuICAgICAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHdlIGNvdWxkIHNraXAgdGhpcyBpbml0aWFsIGZpbHRlciwgbGlrZSBhbmd1bGFyIGRvZXMuIEJ1dCB0aGVyZSBpcyBubyBDU1Mgc2VsZWN0b3IgZm9yXG4gICAgICAgIC8vIGF0dHJpYnV0ZSBuYW1lIGJlZ2lucyB3aXRoIG9yIGVuZHMgd2l0aC4gW2F0dHJePV0gaXMgZm9yIHRoZSBWQUxVRSBiZWdpbm5pbmcgd2l0aCBzb21ldGhpbmcuXG4gICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhlIGNvbnRlbnQgaXRzZWxmIGluIGl0cyBjaGVjay5cbiAgICAgICAgZm9yIChjb25zdCBlbGUgb2YgUXVlcnlTZWxlY3Rvck5vZGVMaXN0XzEubm9kZUxpc3RTZWxlY3RvckFsbChbdGhpcy5jb250ZW50XSwgJ1tpNV9ldmVudF0sIFtcXFxcMDAwMDNBZXZlbnRdLCBbZGF0YS1pNV9ldmVudF0nKSkge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudEZpbHRlciAmJiBlbGUuZ2V0QXR0cmlidXRlKCdjb21wb25lbnQnKSAhPT0gY29tcG9uZW50RmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50QXR0cmlidXRlcyA9IEFycmF5LmZyb20oZWxlLmF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgbGV0IGV2ZW50RGVmaW5pdGlvbiA9IGN1cnJlbnRBdHRyaWJ1dGVzLmZpbmQoZiA9PiBmLm5hbWUuc3RhcnRzV2l0aCgnKCcpICYmIGYubmFtZS5lbmRzV2l0aCgnKScpICYmIGYubmFtZS5sZW5ndGggPiAyKTtcbiAgICAgICAgICAgIGlmICghZXZlbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYnkgYWx0ZXJuYXRlIHN5bnRheC4gVGhpcyBvbmUgd29ya3MgYmV0dGVyIHdpdGggc2V0QXR0cmlidXRlKCkuXG4gICAgICAgICAgICAgICAgZXZlbnREZWZpbml0aW9uID0gY3VycmVudEF0dHJpYnV0ZXMuZmluZChmID0+IGYubmFtZS5zdGFydHNXaXRoKCdfJykgJiYgZi5uYW1lLmVuZHNXaXRoKCdfJykgJiYgZi5uYW1lLmxlbmd0aCA+IDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFldmVudERlZmluaXRpb24gfHwgIWV2ZW50RGVmaW5pdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXZlbnQgZGVmaW5pdGlvbiBub3QgZGVjbGFyZWQgZm9yIGVsZW1lbnQgJHtlbGUuaWQgfHwgZWxlLnRhZ05hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXRob2QgPSB0aGlzW2V2ZW50RGVmaW5pdGlvbi52YWx1ZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSGFuZGxlciBtZXRob2QgZm9yIGVsZW1lbnQgJHtlbGUuaWQgfHwgZWxlLnRhZ05hbWV9ICR7ZXZlbnREZWZpbml0aW9uLnZhbHVlfSBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnREZWZpbml0aW9uLm5hbWUuc2xpY2UoMSwgLTEpLCBtZXRob2QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFwcGVuZChuZXdDaGlsZCkge1xuICAgICAgICBpZiAoZ3VhcmQobmV3Q2hpbGQpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobmV3Q2hpbGQuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBmdW5jdGlvbiBndWFyZChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogJiYgJ2NvbnRlbnQnIGluIG9iaiAmJiBvYmouY29udGVudCBpbnN0YW5jZW9mIE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXBwZW5kQ2hpbGQobmV3Q2hpbGQpIHtcbiAgICAgICAgaWYgKGd1YXJkKG5ld0NoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5hcHBlbmRDaGlsZChuZXdDaGlsZC5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuYXBwZW5kQ2hpbGQobmV3Q2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGd1YXJkKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIG9iaiAmJiAnY29udGVudCcgaW4gb2JqICYmIG9iai5jb250ZW50IGluc3RhbmNlb2YgTm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcHBlbmRUb1BhcmVudChwYXJlbnQpIHtcbiAgICAgICAgaWYgKGd1YXJkKHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5jb250ZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZnVuY3Rpb24gZ3VhcmQob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmICdjb250ZW50JyBpbiBvYmogJiYgb2JqLmNvbnRlbnQgaW5zdGFuY2VvZiBOb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgY29tcG9uZW50IHRvIENvbXBvbmVudE1hcC5cbiAgICAgKi9cbiAgICBtYXBDb21wb25lbnQoKSB7XG4gICAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIHRoZSBjb250ZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVsYXRlZCB0byBhIGRpZmZlcmVudCBjb21wb25lbnRcbiAgICAgICAgaWYgKENvbXBvbmVudE1hcF8xLmdldENvbXBvbmVudCh0aGlzLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRlbnQgYWxyZWFkeSByZWZlcmVuY2VkIGJ5IGEgY29tcG9uZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgQ29tcG9uZW50TWFwXzEuQ29tcG9uZW50TWFwLmNvbXBvbmVudHMuc2V0KHRoaXMuY29udGVudCwgdGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgdGhlIGNvbXBvbmVudCBmcm9tIENvbXBvbmVudE1hcC4gU29tZXRpbWVzIHlvdSBtaWdodCBuZWVkIHRvIHVzZSB0aGlzLiBCdXQgaG9wZWZ1bGx5IHJhcmVseSwgYmVjYXVzZSBpdCdzIHVzaW5nIGEgV2Vha01hcCxcbiAgICAgKi9cbiAgICB1bm1hcENvbXBvbmVudCgpIHtcbiAgICAgICAgQ29tcG9uZW50TWFwXzEuQ29tcG9uZW50TWFwLmNvbXBvbmVudHMuZGVsZXRlKHRoaXMuY29udGVudCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBsaXN0IG9mIGNvbXBvbmVudHMgdGhhdCBhcmUgbmVzdGVkIGluc2lkZSB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICAqZ2V0QWxsQ2hpbGRDb21wb25lbnRzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyonKSkge1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50ID0gQ29tcG9uZW50TWFwXzEuZ2V0Q29tcG9uZW50KGUpO1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ3N0cmluZycgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIC8vIFRTIGp1c3QgZm9yZ290IHRoYXQgcHJvcGVydHkgaXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPi5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBwcm9wZXJ0eVtwcm9wXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkQ2xhc3MoY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAoIWNsYXNzTmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gXCJzdHJpbmdcIiAmJiBjbGFzc05hbWVzLmluY2x1ZGVzKFwiIFwiKSkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuc3BsaXQoXCIgXCIpLmZpbHRlcihxID0+IHEgIT09IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzID0gW2NsYXNzTmFtZXNdO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmVjYXVzZSBhZGRJbmxpbmVFdmVudExpc3RlbmVycygpIHNlYXJjaGVzIGFsbCB0aGUgd2F5IGRvd24sIGludG8gbmVzdGVkIGNvbXBvbmVudHMsIGl0IGNhbid0IGJlIGNhbGxlZFxuICAgICAqIGJ5IGRlZmF1bHQuIEl0IGp1c3QgdGhyb3dzIGVycm9ycyBvbiBhbGwgYnV0IHNpbXBsZSB0ZXN0IGNhc2VzLiBCdXQgYmVjYXVzZSB0aGVzZSBldmVudHMgYWxtb3N0IGFsd2F5cyBleGlzdFxuICAgICAqIGludGVybmFsIHRvIHRoZSBjb21wb25lbnQgKGUuZy4gb24gYnV0dG9ucyksIGl0IGNhbid0IGJlIGxpbWl0ZWQuIFRoaXMgY2FuIGJlIGNvbmZ1c2luZyB3aXRob3V0IHNvbWUga2luZCBvZlxuICAgICAqIG1lc3NhZ2UuXG4gICAgICovXG4gICAgX2NoZWNrSW5saW5lRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlIG9mIFF1ZXJ5U2VsZWN0b3JOb2RlTGlzdF8xLm5vZGVMaXN0U2VsZWN0b3JBbGwoW3RoaXMuY29udGVudF0sICdbaTVfZXZlbnRdLCBbXFxcXDAwMDAzQWV2ZW50XSwgW2RhdGEtaTVfZXZlbnRdJykpIHtcbiAgICAgICAgICAgIGlmICghd2luZG93Ll9fZXZlbnRfd2FybmluZ19fKSB7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oJ0lubGluZSBldmVudCBsaXN0ZW5lcnMgYXJlIGNvbmZpZ3VyZWQuIFJlbWVtYmVyIHRvIGNhbGwgYWRkSW5saW5lRXZlbnRMaXN0ZW5lcnMoKS4nKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuX19ldmVudF93YXJuaW5nX18gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBkZWxldGUgd2luZG93Ll9fZXZlbnRfd2FybmluZ19fLCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRoZSBxdWVzdGlvbiBuZWVkcyB0byBiZSBhc2tlZDogaWYgeW91IGNhbiBhZGQgYSBjb21wb25lbnQgdG8gYSBwYWdlIGJ5IGRvaW5nIGVsZW1lbnQuYXBwZW5kQ2hpbGQoY29tcG9uZW50LmNvbnRlbnQpLFxuICogaG93IGRvIHlvdSBkbyBmcm9tIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb28nKSBhbmQgZ2V0IHRvIGNvbXBvbmVudCwgbm90IGNvbXBvbmVudC5jb250ZW50PyBUaGlzIGlzIGhvdy5cbiAqXG4gKiB2YXIgY29tcG9uZW50ID0gQ29tcG9uZW50TWFwLmNvbXBvbmVudHMuZ2V0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb28nKSk7XG4gKlxuICogVGhpcyB3aWxsIHdvcmsgYXMgbG9uZyBhcyBDb21wb25lbnRNYXAuY29tcG9uZW50cy5zZXQoY29udGVudCwgY29tcG9uZW50KSBoYXMgYmVlbiBjYWxsZWQgYXQgc29tZSBwb2ludC5cbiAqXG4gKiBUaGlzIGlzIHRoZSBhcHByb3ZlZCB3YXkgb2YgZG9pbmcgaXQuIEFub3RoZXIgcG9zc2libGUgc29sdXRpb24gd291bGQgYmUgdGhlIHVzZSBvZiBleHBhbmRvIHByb3BlcnRpZXMsXG4gKiBmb3IgZXhhbXBsZSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vJykucmVsYXRlZENvbXBvbmVudCA9IGNvbXBvbmVudC4gVGhpcyB3b3JrcyBhbmQgaXQncyBzdXBlciBzaW1wbGUsXG4gKiBidXQgc2VlbXMgdG8gYmUgZnJvd25lZCB1cG9uIC4uLiBpdCBoYXMgYmVlbiBrbm93biB0byBjcmVhdGUgbWVtb3J5IGxlYWtzIGluIHRoZSBwYXN0LiBXZWFrTWFwIGlzIHRoZSBvYmplY3RcbiAqIHNwZWNpZmljYWxseSBjcmVhdGVkIGZvciB0aGlzIHVzZSBjYXNlLCBzbyB0aGF0IGlzIHVzZWQgaGVyZS5cbiAqXG4gKiBJZiBleHRlbnNpb24gbWV0aG9kcyBhcmUgbG9hZGVkLCB5b3UgY2FuIHVzZSB0aGUgZWxlbWVudC5nZXRDb21wb25lbnQoKSBzaG9ydGN1dC5cbiAqL1xuY2xhc3MgQ29tcG9uZW50TWFwIHtcbn1cbkNvbXBvbmVudE1hcC5jb21wb25lbnRzID0gbmV3IFdlYWtNYXAoKTtcbmV4cG9ydHMuQ29tcG9uZW50TWFwID0gQ29tcG9uZW50TWFwO1xuZnVuY3Rpb24gZ2V0Q29tcG9uZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBvbmVudE1hcC5jb21wb25lbnRzLmdldChlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBDb21wb25lbnRNYXAuY29tcG9uZW50cy5nZXQoZWxlbWVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRDb21wb25lbnQgPSBnZXRDb21wb25lbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG4vKipcbiAqIFRyeSB0byBwcm92aWRlIHNvbWUgY3VzdG9tIGNsYXNzZXMgdG8gaGVscCBjbGVhbiB1cCB0aGUgbWVzcyB0aGF0IFR5cGVTY3JpcHQgYW5kIFZTQ29kZSBwcm92aWRlcyB3aGVuZXZlclxuICogdGhlIG1lc3MgdGhleSBjYWxsIG92ZXJsb2FkaW5nIGV4cGxvZGVzLiBJZiB5b3UgbWVzcyB1cCBhIHByb3BlcnR5LCB0aGUgZXJyb3IgbWVzc2FnZSBjb21wbGFpbnMgdGhhdFxuICogdGhlIG9iamVjdCB5b3UgcHJvdmlkZWQgZG9lc24ndCBpbmNsdWRlIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgb2YgdGhlIHN0cmluZyBvYmplY3QsIHdoaWNoIGlzbid0IGhlbHBmdWwuXG4gKi9cbmNsYXNzIENvbXBvbmVudEJpbmRpbmdPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9uZW50QmluZGluZ09wdGlvbnMgPSBDb21wb25lbnRCaW5kaW5nT3B0aW9ucztcbi8qKlxuICogVHJ5IHRvIHByb3ZpZGUgc29tZSBjdXN0b20gY2xhc3NlcyB0byBoZWxwIGNsZWFuIHVwIHRoZSBtZXNzIHRoYXQgVHlwZVNjcmlwdCBhbmQgVlNDb2RlIHByb3ZpZGVzIHdoZW5ldmVyXG4gKiB0aGUgbWVzcyB0aGV5IGNhbGwgb3ZlcmxvYWRpbmcgZXhwbG9kZXMuIElmIHlvdSBtZXNzIHVwIGEgcHJvcGVydHksIHRoZSBlcnJvciBtZXNzYWdlIGNvbXBsYWlucyB0aGF0XG4gKiB0aGUgb2JqZWN0IHlvdSBwcm92aWRlZCBkb2Vzbid0IGluY2x1ZGUgdGhlIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgc3RyaW5nIG9iamVjdCwgd2hpY2ggaXNuJ3QgaGVscGZ1bC5cbiAqL1xuY2xhc3MgRXhpc3RpbmdFbGVtZW50QmluZGluZ09wdGlvbnMgZXh0ZW5kcyBDb21wb25lbnRCaW5kaW5nT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0KTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gb3B0LmVsZW1lbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5FeGlzdGluZ0VsZW1lbnRCaW5kaW5nT3B0aW9ucyA9IEV4aXN0aW5nRWxlbWVudEJpbmRpbmdPcHRpb25zO1xuLyoqXG4gKiBUcnkgdG8gcHJvdmlkZSBzb21lIGN1c3RvbSBjbGFzc2VzIHRvIGhlbHAgY2xlYW4gdXAgdGhlIG1lc3MgdGhhdCBUeXBlU2NyaXB0IGFuZCBWU0NvZGUgcHJvdmlkZXMgd2hlbmV2ZXJcbiAqIHRoZSBtZXNzIHRoZXkgY2FsbCBvdmVybG9hZGluZyBleHBsb2Rlcy4gSWYgeW91IG1lc3MgdXAgYSBwcm9wZXJ0eSwgdGhlIGVycm9yIG1lc3NhZ2UgY29tcGxhaW5zIHRoYXRcbiAqIHRoZSBvYmplY3QgeW91IHByb3ZpZGVkIGRvZXNuJ3QgaW5jbHVkZSB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIG9mIHRoZSBzdHJpbmcgb2JqZWN0LCB3aGljaCBpc24ndCBoZWxwZnVsLlxuICovXG5jbGFzcyBFeGlzdGluZ0xvb2t1cEJpbmRpbmdPcHRpb25zIGV4dGVuZHMgQ29tcG9uZW50QmluZGluZ09wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBzdXBlcihvcHQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBvcHQuc2VsZWN0b3I7XG4gICAgfVxufVxuZXhwb3J0cy5FeGlzdGluZ0xvb2t1cEJpbmRpbmdPcHRpb25zID0gRXhpc3RpbmdMb29rdXBCaW5kaW5nT3B0aW9ucztcbi8qKlxuICogVHJ5IHRvIHByb3ZpZGUgc29tZSBjdXN0b20gY2xhc3NlcyB0byBoZWxwIGNsZWFuIHVwIHRoZSBtZXNzIHRoYXQgVHlwZVNjcmlwdCBhbmQgVlNDb2RlIHByb3ZpZGVzIHdoZW5ldmVyXG4gKiB0aGUgbWVzcyB0aGV5IGNhbGwgb3ZlcmxvYWRpbmcgZXhwbG9kZXMuIElmIHlvdSBtZXNzIHVwIGEgcHJvcGVydHksIHRoZSBlcnJvciBtZXNzYWdlIGNvbXBsYWlucyB0aGF0XG4gKiB0aGUgb2JqZWN0IHlvdSBwcm92aWRlZCBkb2Vzbid0IGluY2x1ZGUgdGhlIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgc3RyaW5nIG9iamVjdCwgd2hpY2ggaXNuJ3QgaGVscGZ1bC5cbiAqL1xuY2xhc3MgSW5uZXJIdG1sQmluZGluZ09wdGlvbnMgZXh0ZW5kcyBDb21wb25lbnRCaW5kaW5nT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0KTtcbiAgICB9XG59XG5leHBvcnRzLklubmVySHRtbEJpbmRpbmdPcHRpb25zID0gSW5uZXJIdG1sQmluZGluZ09wdGlvbnM7XG4vKipcbiAqIFRyeSB0byBwcm92aWRlIHNvbWUgY3VzdG9tIGNsYXNzZXMgdG8gaGVscCBjbGVhbiB1cCB0aGUgbWVzcyB0aGF0IFR5cGVTY3JpcHQgYW5kIFZTQ29kZSBwcm92aWRlcyB3aGVuZXZlclxuICogdGhlIG1lc3MgdGhleSBjYWxsIG92ZXJsb2FkaW5nIGV4cGxvZGVzLiBJZiB5b3UgbWVzcyB1cCBhIHByb3BlcnR5LCB0aGUgZXJyb3IgbWVzc2FnZSBjb21wbGFpbnMgdGhhdFxuICogdGhlIG9iamVjdCB5b3UgcHJvdmlkZWQgZG9lc24ndCBpbmNsdWRlIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgb2YgdGhlIHN0cmluZyBvYmplY3QsIHdoaWNoIGlzbid0IGhlbHBmdWwuXG4gKi9cbmNsYXNzIE91dGVySHRtbEJpbmRpbmdPcHRpb25zIGV4dGVuZHMgQ29tcG9uZW50QmluZGluZ09wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBzdXBlcihvcHQpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdCk7XG4gICAgICAgIHRoaXMub3V0ZXJIdG1sID0gb3B0Lm91dGVySHRtbDtcbiAgICB9XG59XG5leHBvcnRzLk91dGVySHRtbEJpbmRpbmdPcHRpb25zID0gT3V0ZXJIdG1sQmluZGluZ09wdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVHJ5IHRvIHByb3ZpZGUgc29tZSBjdXN0b20gY2xhc3NlcyB0byBoZWxwIGNsZWFuIHVwIHRoZSBtZXNzIHRoYXQgVHlwZVNjcmlwdCBhbmQgVlNDb2RlIHByb3ZpZGVzIHdoZW5ldmVyXG4gKiB0aGUgbWVzcyB0aGV5IGNhbGwgb3ZlcmxvYWRpbmcgZXhwbG9kZXMuIElmIHlvdSBtZXNzIHVwIGEgcHJvcGVydHksIHRoZSBlcnJvciBtZXNzYWdlIGNvbXBsYWlucyB0aGF0XG4gKiB0aGUgb2JqZWN0IHlvdSBwcm92aWRlZCBkb2Vzbid0IGluY2x1ZGUgdGhlIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgc3RyaW5nIG9iamVjdCwgd2hpY2ggaXNuJ3QgaGVscGZ1bC5cbiAqL1xuY2xhc3MgRXhpc3RpbmdFbGVtZW50T3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0KTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gb3B0LmVsZW1lbnQ7XG4gICAgfVxufVxuZXhwb3J0cy5FeGlzdGluZ0VsZW1lbnRPcHRpb25zID0gRXhpc3RpbmdFbGVtZW50T3B0aW9ucztcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBMb29rIHVwIGFuIGV4aXN0aW5nIGVsZW1lbnQgaW4gdGhlIERPTSBhbmQgY29udmVydCBpdCB0byBhIGNvbXBvbmVudC4gVGhpcyBpcyBqdXN0IGEgd2F5IHRvIHNpbXBsaWZ5IHRoZSBsb29rdXAgcHJvY2VzcyB2cyBkb2luZ1xuICogaXQgbWFudWFsbHkgYmVmb3JlIHVzaW5nIElFeGlzdGluZ0VsZW1lbnRPcHRpb25zLlxuICogTm90ZTogVHlwZXNjcmlwdCBjYW4ndCB2ZXJpZnkgeW91ciB0eXBlIGFubm90YXRpb25zIGlmIHlvdSBkbyBpdCB0aGlzIHdheS5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUcnkgdG8gcHJvdmlkZSBzb21lIGN1c3RvbSBjbGFzc2VzIHRvIGhlbHAgY2xlYW4gdXAgdGhlIG1lc3MgdGhhdCBUeXBlU2NyaXB0IGFuZCBWU0NvZGUgcHJvdmlkZXMgd2hlbmV2ZXJcbiAqIHRoZSBtZXNzIHRoZXkgY2FsbCBvdmVybG9hZGluZyBleHBsb2Rlcy4gSWYgeW91IG1lc3MgdXAgYSBwcm9wZXJ0eSwgdGhlIGVycm9yIG1lc3NhZ2UgY29tcGxhaW5zIHRoYXRcbiAqIHRoZSBvYmplY3QgeW91IHByb3ZpZGVkIGRvZXNuJ3QgaW5jbHVkZSB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIG9mIHRoZSBzdHJpbmcgb2JqZWN0LCB3aGljaCBpc24ndCBoZWxwZnVsLlxuICovXG5jbGFzcyBFeGlzdGluZ0xvb2t1cE9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3IgPSBvcHQuc2VsZWN0b3I7XG4gICAgfVxufVxuZXhwb3J0cy5FeGlzdGluZ0xvb2t1cE9wdGlvbnMgPSBFeGlzdGluZ0xvb2t1cE9wdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVHJ5IHRvIHByb3ZpZGUgc29tZSBjdXN0b20gY2xhc3NlcyB0byBoZWxwIGNsZWFuIHVwIHRoZSBtZXNzIHRoYXQgVHlwZVNjcmlwdCBhbmQgVlNDb2RlIHByb3ZpZGVzIHdoZW5ldmVyXG4gKiB0aGUgbWVzcyB0aGV5IGNhbGwgb3ZlcmxvYWRpbmcgZXhwbG9kZXMuIElmIHlvdSBtZXNzIHVwIGEgcHJvcGVydHksIHRoZSBlcnJvciBtZXNzYWdlIGNvbXBsYWlucyB0aGF0XG4gKiB0aGUgb2JqZWN0IHlvdSBwcm92aWRlZCBkb2Vzbid0IGluY2x1ZGUgdGhlIHZhcmlvdXMgcHJvcGVydGllcyBvZiB0aGUgc3RyaW5nIG9iamVjdCwgd2hpY2ggaXNuJ3QgaGVscGZ1bC5cbiAqL1xuY2xhc3MgSW5uZXJIdG1sT3B0aW9ucyB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgb3B0KTtcbiAgICB9XG59XG5leHBvcnRzLklubmVySHRtbE9wdGlvbnMgPSBJbm5lckh0bWxPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIFRyeSB0byBwcm92aWRlIHNvbWUgY3VzdG9tIGNsYXNzZXMgdG8gaGVscCBjbGVhbiB1cCB0aGUgbWVzcyB0aGF0IFR5cGVTY3JpcHQgYW5kIFZTQ29kZSBwcm92aWRlcyB3aGVuZXZlclxuICogdGhlIG1lc3MgdGhleSBjYWxsIG92ZXJsb2FkaW5nIGV4cGxvZGVzLiBJZiB5b3UgbWVzcyB1cCBhIHByb3BlcnR5LCB0aGUgZXJyb3IgbWVzc2FnZSBjb21wbGFpbnMgdGhhdFxuICogdGhlIG9iamVjdCB5b3UgcHJvdmlkZWQgZG9lc24ndCBpbmNsdWRlIHRoZSB2YXJpb3VzIHByb3BlcnRpZXMgb2YgdGhlIHN0cmluZyBvYmplY3QsIHdoaWNoIGlzbid0IGhlbHBmdWwuXG4gKi9cbmNsYXNzIE91dGVySHRtbE9wdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdCk7XG4gICAgICAgIHRoaXMub3V0ZXJIdG1sID0gb3B0Lm91dGVySHRtbDtcbiAgICB9XG59XG5leHBvcnRzLk91dGVySHRtbE9wdGlvbnMgPSBPdXRlckh0bWxPcHRpb25zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudEhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vRXZlbnRIYW5kbGVyL0V2ZW50SGFuZGxlclwiKTtcbmZ1bmN0aW9uIG9ic2VydmFibGVDaGVjayhvYmopIHtcbiAgICAvLyBOb3QgYW4gZXhoYXVzdGl2ZSB0ZXN0IGJ1dCBpdCdzIHRoZSBpbXBvcnRhbnQgYml0LlxuICAgIHJldHVybiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgJ2NoYW5nZUhhbmRsZXInIGluIG9iaiAmJiBvYmouY2hhbmdlSGFuZGxlciBpbnN0YW5jZW9mIEV2ZW50SGFuZGxlcl8xLkV2ZW50SGFuZGxlcjtcbn1cbmV4cG9ydHMub2JzZXJ2YWJsZUNoZWNrID0gb2JzZXJ2YWJsZUNoZWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcnJheUNoYW5nZWRFdmVudEFyZ3NfMSA9IHJlcXVpcmUoXCIuLi8uLi9TeXN0ZW0vRXZlbnRIYW5kbGVyL0FycmF5Q2hhbmdlZEV2ZW50QXJnc1wiKTtcbmNvbnN0IE9iamVjdEZ1bGxBc3NpZ25fMSA9IHJlcXVpcmUoXCIuLi8uLi9TeXN0ZW0vVXRpbGl0eS9PYmplY3RGdWxsQXNzaWduXCIpO1xuY29uc3QgT2JzZXJ2YWJsZUJhc2VfMSA9IHJlcXVpcmUoXCIuLi9PYnNlcnZhYmxlQmFzZVwiKTtcbmNsYXNzIFRyYWl0U291cmNlIGV4dGVuZHMgT2JzZXJ2YWJsZUJhc2VfMS5PYnNlcnZhYmxlQmFzZSB7XG4gICAgY29uc3RydWN0b3IoZGlzYWJsZUFzeW5jKSB7XG4gICAgICAgIHN1cGVyKHsgbmFtZTogJ0FycmF5UHJveHknLCBkaXNhYmxlQXN5bmMgfSk7XG4gICAgfVxufVxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBBcnJheU9ic2VydmFibGUgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE1lcmdlZE9ic2VydmFibGUoYXJncywgZGlzYWJsZUFzeW5jKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgSSByZWFsbHkgbmVlZCBtdWx0aXBsZSBpbmhlcml0YW5jZS4gVGhpcyBuZWVkcyB0byBpbmhlcml0IGZyb20gQXJyYXlcbiAgICAgICAgLy8gYmVjYXVzZSBpdCdzIGV4dGVuZGluZyBhIGJ1aWx0LWluIGNsYXNzLiBJdCBhbHNvIG5lZWRzIHRvIGluaGVyaXQgZnJvbSBPYnNlcnZhYmxlQmFzZS5cbiAgICAgICAgLy8gVGhyZWUgY2hvaWNlczpcbiAgICAgICAgLy8gMSkgNTAgbGluZXMgb2YgY2xpcGJvYXJkIGluaGVyaXRhbmNlLlxuICAgICAgICAvLyAyKSBDaGVhdCBoZWF2aWx5IGJ5IHRha2luZyBhIHRyYWl0IGFwcHJvYWNoLiBUaGlzIG1lYW5zIGhhY2tlcnkgdG8gbWFrZSBUUyBoYXBweS5cbiAgICAgICAgLy8gMykgRG8gdGhlIHNhbWUgYXMgMiB3aXRoIHRoZSBidWlsdC1pbiBBcnJheSBjbGFzcy4gTm90IGEgcHJvYmxlbSBidXQgd2l0aCAjMiB0aGUgY2xhc3MgbmFtZSBhY3RzXG4gICAgICAgIC8vIGFzIGEgaGludCB0aGF0IGl0J3Mgbm90IGEgZGVmYXVsdCBhcnJheSwgd2hpY2ggaXMgYmV0dGVyLlxuICAgICAgICAvLyAjMiB3aW5zLlxuICAgICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXlPYnNlcnZhYmxlKC4uLmFyZ3MpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3RGdWxsQXNzaWduXzEub2JqZWN0RnVsbEFzc2lnbihhcnIsIG5ldyBUcmFpdFNvdXJjZShkaXNhYmxlQXN5bmMpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ2NoYW5nZUhhbmRsZXInLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBPYmplY3RzIGNyZWF0ZWQgdGhyb3VnaCBtYXAsIGZpbHRlciwgZXRjLCBzaG91bGQgYmUgZ2VuZXJpYyBhcnJheXMuXG4gICAgc3RhdGljIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICByZXR1cm4gQXJyYXk7XG4gICAgfVxuICAgIC8vIE5lZWRzIHRvIGJlIHB1YmxpYyBzbyB0aGUgcHJveHkgY2FuIGNhbGwgaXQsIGJ1dCBzaG91bGQgbm90IGJlIGNhbGxlZCBvdXRzaWRlIHRoZSBBUEkuIEltYWdpbmUgaXQncyBpbnRlcm5hbC5cbiAgICBwdWJsaXNoQ29sbGVjdGlvbkNoYW5nZWQodHlwZSwgcHJvcGVydHlOYW1lLCBhcmdzLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNlbmRlcikge1xuICAgICAgICAvLyBUaGlzIHJlcXVpcmVzIGEgY2hlYXQuIEl0IHdpbGwgZmFpbCBpZiB0aGUgb2JqZWN0IGlzIGNyZWF0ZWQgd2l0aCBuZXcoKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VIYW5kbGVyLmludm9rZShuZXcgQXJyYXlDaGFuZ2VkRXZlbnRBcmdzXzEuQXJyYXlDaGFuZ2VkRXZlbnRBcmdzKHsgdHlwZSwgcHJvcGVydHlOYW1lLCBhcmdzLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNlbmRlciB9KSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2UoKTtcbiAgICB9XG59XG5leHBvcnRzLkFycmF5T2JzZXJ2YWJsZSA9IEFycmF5T2JzZXJ2YWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgSXNJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vLi4vU3lzdGVtL1V0aWxpdHkvSXNJbnRlZ2VyXCIpO1xuY2xhc3MgQXJyYXlQcm94eUhhbmRsZXIge1xuICAgIGdldCh0YXJnZXQsIGtleSwgcHJveHkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZENhbGxlZCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCBwcm94eSk7XG4gICAgICAgICAgICAvLyBTaWxlbnQgcGFzcy10aHJvdWdoIG9mIG90aGVyIG1ldGhvZHNcbiAgICAgICAgICAgIGlmIChBcnJheVByb3h5SGFuZGxlci5tZXRob2RzVG9XYXRjaC5pbmRleE9mKGtleS50b1N0cmluZygpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kQ2FsbGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTmVlZCB0byBldmFsdWF0ZSBwZXJmb3JtYW5jZSBvZiBjb3BpZXNcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmUgPSB0YXJnZXQuc2xpY2UoKTsgLy8gVGhpcyBjb3VsZCBiZSB1c2VmdWwgYnV0IGl0IGNvdWxkIGFsc28gYmUgYSBwZXJmb3JtYW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbCA9IG1ldGhvZENhbGxlZC5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gdGFyZ2V0LnNsaWNlKCk7IC8vIFRoaXMgY291bGQgYmUgdXNlZnVsIGJ1dCBpdCBjb3VsZCBhbHNvIGJlIGEgcGVyZm9ybWFuY2UgcHJvYmxlbS5cbiAgICAgICAgICAgICAgICB0YXJnZXQucHVibGlzaENvbGxlY3Rpb25DaGFuZ2VkKCdjYWxsJywga2V5LCBhcmdzLCBiZWZvcmUsIGFmdGVyLCBwcm94eSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblZhbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcHJveHkpIHtcbiAgICAgICAgLy8gUHJvYmxlbTogV2Ugd2FudCB0byBjYXB0dXJlIG9ubHkgbGVuZ3RoIGFuZCBbaW5kZXhlcl0gY2FsbHMsIGJ1dCBKUyBoYXMgbm8gY29uc2lzdGVudFxuICAgICAgICAvLyB3YXkgb2YgZGVmaW5pbmcgW2luZGV4ZXJdLiBXaGF0IG1ha2VzIGl0IHdvcnNlIGlzIHRoYXQgaWYgYSBzdHJpbmcgaXMgYW4gaW50ZWdlciwgaXQgaXNcbiAgICAgICAgLy8gY29udmVydGVkIHRvIGEgbnVtYmVyLiBBbmQgSlMgZG9lcyBub3QgaW5jbHVkZSBhIGJ1aWx0LWluIHdheSB0byB0ZXN0IGlmIGEgbnVtYmVyIGlzIGFuIGludGVnZXIuXG4gICAgICAgIC8vIFNvbHV0aW9uOiBBIHJlZ2V4LWJhc2VkIGNoZWNrLiBJY2suIFdheSB0byByZW1pbmQgbWUgSSdtIHVzaW5nIEpTLlxuICAgICAgICBpZiAoa2V5ICYmIChrZXkudG9TdHJpbmcoKSA9PT0gJ2xlbmd0aCcgfHwgdHlwZW9mIGtleSA9PT0gJ251bWJlcicgfHwgSXNJbnRlZ2VyXzEuaXNQb3NpdGl2ZUludGVnZXJTdHJpbmcoa2V5KSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IE5lZWQgdG8gZXZhbHVhdGUgcGVyZm9ybWFuY2Ugb2YgY29waWVzXG4gICAgICAgICAgICBjb25zdCBiZWZvcmUgPSB0YXJnZXQuc2xpY2UoKTsgLy8gVGhpcyBjb3VsZCBiZSB1c2VmdWwgYnV0IGl0IGNvdWxkIGFsc28gYmUgYSBwZXJmb3JtYW5jZSBwcm9ibGVtLlxuICAgICAgICAgICAgUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCBwcm94eSk7XG4gICAgICAgICAgICBjb25zdCBhZnRlciA9IHRhcmdldC5zbGljZSgpOyAvLyBUaGlzIGNvdWxkIGJlIHVzZWZ1bCBidXQgaXQgY291bGQgYWxzbyBiZSBhIHBlcmZvcm1hbmNlIHByb2JsZW0uXG4gICAgICAgICAgICB0YXJnZXQucHVibGlzaENvbGxlY3Rpb25DaGFuZ2VkKCdzZXQnLCBrZXksIFt2YWx1ZV0sIGJlZm9yZSwgYWZ0ZXIsIHByb3h5KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVmbGVjdC5zZXQodGFyZ2V0LCBrZXksIHZhbHVlLCBwcm94eSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGVQcm9wZXJ0eSh0YXJnZXQsIGtleSkge1xuICAgICAgICBjb25zdCBiZWZvcmUgPSB0YXJnZXQuc2xpY2UoKTsgLy8gVGhpcyBjb3VsZCBiZSB1c2VmdWwgYnV0IGl0IGNvdWxkIGFsc28gYmUgYSBwZXJmb3JtYW5jZSBwcm9ibGVtLlxuICAgICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwga2V5KTtcbiAgICAgICAgY29uc3QgYWZ0ZXIgPSB0YXJnZXQuc2xpY2UoKTsgLy8gVGhpcyBjb3VsZCBiZSB1c2VmdWwgYnV0IGl0IGNvdWxkIGFsc28gYmUgYSBwZXJmb3JtYW5jZSBwcm9ibGVtLlxuICAgICAgICAvLyBDYW5ub3QgcmVwb3J0IHByb3h5IGFzIHNlbmRlciBiZWNhdXNlIHByb3h5IG5vdCBzZW50IHRvIHRoaXMgbWV0aG9kXG4gICAgICAgIHRhcmdldC5wdWJsaXNoQ29sbGVjdGlvbkNoYW5nZWQoJ2RlbGV0ZScsIGtleSwgW10sIGJlZm9yZSwgYWZ0ZXIsIG51bGwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyBUaGVzZSBhcmUgYWxsIHRoZSBtZXRob2RzLCBub3QgY291bnRpbmcgY3VzdG9tIHNldHRlcnMsIHRoYXQgbXV0YXRlIGFuIGFycmF5LlxuQXJyYXlQcm94eUhhbmRsZXIubWV0aG9kc1RvV2F0Y2ggPSBbJ2NvcHlXaXRoaW4nLCAnZmlsbCcsICdwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcbmV4cG9ydHMuQXJyYXlQcm94eUhhbmRsZXIgPSBBcnJheVByb3h5SGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzXzEgPSByZXF1aXJlKFwiLi4vLi4vU3lzdGVtL0V2ZW50SGFuZGxlci9Qcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3NcIik7XG5jb25zdCBPYnNlcnZhYmxlQmFzZV8xID0gcmVxdWlyZShcIi4uL09ic2VydmFibGVCYXNlXCIpO1xuY29uc3QgT2JqZWN0RnVsbEFzc2lnbl8xID0gcmVxdWlyZShcIi4uLy4uL1N5c3RlbS9VdGlsaXR5L09iamVjdEZ1bGxBc3NpZ25cIik7XG5jbGFzcyBPYmplY3RPYnNlcnZhYmxlIGV4dGVuZHMgT2JzZXJ2YWJsZUJhc2VfMS5PYnNlcnZhYmxlQmFzZSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gcHJvZHVjZSBhbiBvYmplY3Qgb2JzZXJ2YWJsZSwgZm9yIHJlYXNvbnMgb2Ygc2FmZXR5LlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRNZXJnZWRPYnNlcnZhYmxlKGRhdGEsIGRpc2FibGVBc3luYykge1xuICAgICAgICAvLyBXZSBuZWVkIHNvbWV0aGluZyB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBvZiB0aGUgaW5wdXQgb2JqZWN0IG1lcmdlZCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMuXG4gICAgICAgIC8vIEkgZG9uJ3Qgd2FudCB0byBhY3R1YWxseSBtb2RpZnkgdGhlIGlucHV0IG9iamVjdC4gRXZlbiB0aG91Z2ggaXQgU0hPVUxEIGJlIHRocm93YXdheSwgSSBkb24ndCBrbm93LlxuICAgICAgICAvLyBBbmQgSSBkb24ndCB3YW50IHRvIHRha2UgdGhlIHJpc2sgdGhhdCBzb21ldGhpbmcgaW4gdGhlIGlucHV0LCBhbiB1bmtub3duIGZhY3Rvciwgd2lsbCBtYWtlIHRoaXMgYmxvdyB1cC5cbiAgICAgICAgLy8gSSBrbm93IHRoYXQgdGhpcyBjbGFzcyBoYXMgb25seSAyIGxldmVscyBvZiBpbmhlcml0YW5jZSAoY3VycmVudGx5KSBhbmQgY29udGFpbnMgbm90aGluZyB2ZXJ5IGNvbXBsZXggYXQgYW55IGxldmVsLlxuICAgICAgICBjb25zdCByZXN1bHQgPSBPYmplY3RGdWxsQXNzaWduXzEub2JqZWN0RnVsbEFzc2lnbihkYXRhLCBuZXcgT2JqZWN0T2JzZXJ2YWJsZShkaXNhYmxlQXN5bmMpLCB0cnVlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgJ2NoYW5nZUhhbmRsZXInLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkaXNhYmxlQXN5bmMpIHtcbiAgICAgICAgc3VwZXIoeyBuYW1lOiBcIk9iamVjdFByb3h5XCIsIGRpc2FibGVBc3luYyB9KTtcbiAgICB9XG4gICAgLy8gTmVlZHMgdG8gYmUgcHVibGljIHNvIHRoZSBwcm94eSBjYW4gY2FsbCBpdCwgYnV0IHNob3VsZCBub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIEFQSS4gSW1hZ2luZSBpdCdzIGludGVybmFsLlxuICAgIHB1Ymxpc2hQcm9wZXJ0eUNoYW5nZWQodHlwZSwgcHJvcGVydHlOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNlbmRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZUhhbmRsZXIuaW52b2tlKG5ldyBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3NfMS5Qcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3MoeyB0eXBlLCBwcm9wZXJ0eU5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgc2VuZGVyIH0pKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICAvLyBUaGlzIGZpbHRlcnMgb3V0IHRoZSB0cm91Ymxlc29tZSBjaGFuZ2VIYW5kbGVyIGZpZWxkLlxuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKCk7XG4gICAgfVxufVxuZXhwb3J0cy5PYmplY3RPYnNlcnZhYmxlID0gT2JqZWN0T2JzZXJ2YWJsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgT2JqZWN0UHJveHlIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihfbWV0aG9kc1RvV2F0Y2gsIF93YXRjaFNldCwgX3dhdGNoRGVsZXRlLCBfdHJpZ2dlck9ubHlPbkNoYW5nZSkge1xuICAgICAgICB0aGlzLl9tZXRob2RzVG9XYXRjaCA9IF9tZXRob2RzVG9XYXRjaDtcbiAgICAgICAgdGhpcy5fd2F0Y2hTZXQgPSBfd2F0Y2hTZXQ7XG4gICAgICAgIHRoaXMuX3dhdGNoRGVsZXRlID0gX3dhdGNoRGVsZXRlO1xuICAgICAgICB0aGlzLl90cmlnZ2VyT25seU9uQ2hhbmdlID0gX3RyaWdnZXJPbmx5T25DaGFuZ2U7XG4gICAgfVxuICAgIGdldCh0YXJnZXQsIGtleSwgcHJveHkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZENhbGxlZCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5LCBwcm94eSk7XG4gICAgICAgICAgICAvLyBTaWxlbnQgcGFzcy10aHJvdWdoIG9mIG5vbi13YXRjaGVkIG1ldGhvZHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9tZXRob2RzVG9XYXRjaC5pbmRleE9mKGtleS50b1N0cmluZygpKSA9PT0gLTEgfHwgdHlwZW9mIG1ldGhvZENhbGxlZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2RDYWxsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gYSB3cmFwcGVyIGFyb3VuZCB0aGUgbWV0aG9kIHRoYXQgcHVibGlzaGVzIHRoZSBjaGFuZ2VcbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblZhbCA9IG1ldGhvZENhbGxlZC5hcHBseSh0YXJnZXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5wdWJsaXNoUHJvcGVydHlDaGFuZ2VkKCdjYWxsJywga2V5LCB1bmRlZmluZWQsIGFyZ3MsIHByb3h5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQodGFyZ2V0LCBrZXksIHZhbHVlLCBwcm94eSkge1xuICAgICAgICBpZiAodGhpcy5fd2F0Y2hTZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gUmVmbGVjdC5nZXQodGFyZ2V0LCBrZXksIHByb3h5KTtcbiAgICAgICAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcHJveHkpO1xuICAgICAgICAgICAgLy8gSWYgdG8gYmUgdHJpZ2dlcmVkIG9ubHkgb24gY2hhbmdlLCBjaGVjayBvbGRWYWx1ZSBhbmQgbmV3VmFsdWVcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmlnZ2VyT25seU9uQ2hhbmdlICYmIG9sZFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0LnB1Ymxpc2hQcm9wZXJ0eUNoYW5nZWQoJ3NldCcsIGtleSwgb2xkVmFsdWUsIHZhbHVlLCBwcm94eSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlZmxlY3Quc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcHJveHkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dhdGNoRGVsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IFJlZmxlY3QuZ2V0KHRhcmdldCwga2V5KTtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgLy8gQ2Fubm90IHJlcG9ydCBwcm94eSBhcyBzZW5kZXIgYmVjYXVzZSBwcm94eSBub3Qgc2VudCB0byB0aGlzIG1ldGhvZFxuICAgICAgICAgICAgdGFyZ2V0LnB1Ymxpc2hQcm9wZXJ0eUNoYW5nZWQoJ2RlbGV0ZScsIGtleSwgb2xkVmFsdWUsIHVuZGVmaW5lZCwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLk9iamVjdFByb3h5SGFuZGxlciA9IE9iamVjdFByb3h5SGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgT2JzZXJ2YWJsZVByb3BlcnR5XzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUHJvcGVydHlcIik7XG4vKipcbiAqIFRoaXMgaXMgYSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgT2JqZWN0LmFzc2lnbigpIHRoYXQgdW5kZXJzdGFuZHMgT2JzZXJ2YWJsZVByb3BlcnR5LFxuICogc28gdGhhdCBpdCBjYW4gdXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgcHJvcGVydHkgd2l0aG91dCB3aXBpbmcgb3V0IHJlZmVyZW5jZXMgdG8gdGhlXG4gKiBleGlzdGluZyBwcm9wZXJ0eSB3aXRoIHRoYXQga2V5ICh3aGljaCBpcyB3aGF0IHdvdWxkIGhhcHBlbiBpZiB5b3UgdXNlZCByZWd1bGFyIE9iamVjdC5hc3NpZ24oKVxuICogb24gYSBub24tcHJveGllZCBvYmplY3QpLiAgSXQgY2FuIGFsc28gYmUgdXNlZCB0byByZWFkIHRoZSB2YWx1ZSBvZiBhbiBPYnNlcnZhYmxlUHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVBc3NpZ24odGFyZ2V0LCAuLi5zb3VyY2VzKSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICAgIGZvciAoY29uc3Qgc3JjIG9mIHNvdXJjZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3JjKSkge1xuICAgICAgICAgICAgY29uc3Qgc3Byb3AgPSBzcmNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHRwcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICBsZXQgdmFsO1xuICAgICAgICAgICAgaWYgKE9ic2VydmFibGVQcm9wZXJ0eV8xLm9ic2VydmFibGVQcm9wZXJ0eUNoZWNrKHNwcm9wKSkge1xuICAgICAgICAgICAgICAgIHZhbCA9IHNwcm9wLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gc3Byb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoT2JzZXJ2YWJsZVByb3BlcnR5XzEub2JzZXJ2YWJsZVByb3BlcnR5Q2hlY2sodHByb3ApKSB7XG4gICAgICAgICAgICAgICAgdHByb3AudmFsdWUgPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMub2JzZXJ2YWJsZUFzc2lnbiA9IG9ic2VydmFibGVBc3NpZ247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50SGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9FdmVudEhhbmRsZXIvRXZlbnRIYW5kbGVyXCIpO1xuLyoqXG4gKiBDb21tb24gbG9naWMgYmV0d2VlbiB0aGUgZGlmZmVyZW50IG9ic2VydmFibGUgY2xhc3Nlcy4gVGhlc2UgaW1wbGVtZW50IElPYnNlcnZhYmxlLiBUaGUgaW52b2NhdGlvbiBpdHNlbGYgdmFyaWVzIGZyb20gY2xhc3MgdG8gY2xhc3MuXG4gKi9cbmNsYXNzIE9ic2VydmFibGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGZvcndhcmRUbywgYnViYmxlRnJvbSwgZGlzYWJsZUFzeW5jIH0gPSB7fSkge1xuICAgICAgICB0aGlzLmNoYW5nZUhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIGlmIChkaXNhYmxlQXN5bmMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXJfMS5FdmVudEhhbmRsZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcndhcmRUbykge1xuICAgICAgICAgICAgdGhpcy5zZW5kQ2hhbmdlRXZlbnRzVG8oZm9yd2FyZFRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnViYmxlRnJvbSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBidWJibGVGcm9tKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ2hhbmdlRXZlbnRzRnJvbShjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWdEZWxlZ2F0ZShuYW1lKTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIFR5cGVzY3JpcHQgaGFzIGZvcmdvdHRlbiB0aGF0IEV2ZW50SGFuZGxlciBjYW4gYWNjZXB0IGFuIGFycmF5LlxuICAgICAgICAvLyBJbiBzcGl0ZSBpZiB0aGUgZmFjdCB0aGF0IHRoaXMgc2lnbmF0dXJlIGlzIGlkZW50aWNhbC5cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlSGFuZGxlci5zdWJzY3JpYmUoY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdGhlIGlucHV0J3MgZGVsZWdhdGUgdG8gdGhpcyBvYmplY3QncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHNlbmRDaGFuZ2VFdmVudHNUbyhmb3J3YXJkVG8pIHtcbiAgICAgICAgLy8gSm9pbiB0aGUgb3RoZXIgZXZlbnQgaGFuZGxlciB0byB0aGlzLCBzbyB0aGF0IHdoZW4gdGhpcyBpcyBpbnZva2VkLCBzbyBpcyB0aGUgb3RoZXIuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlKGZvcndhcmRUby5jaGFuZ2VIYW5kbGVyLmRlbGVnYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRoaXMgb2JqZWN0J3MgZGVsZWdhdGUgdG8gdGhlIGlucHV0IG9iamVjdCdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgcmVjZWl2ZUNoYW5nZUV2ZW50c0Zyb20oYnViYmxlRnJvbSkge1xuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gZXZlbnRzIHJhaXNlZCBvbiB0aGUgb3RoZXIgaGFuZGxlciwgc28gdGhhdCB3aGVuIHRoYXQgaXMgaW52b2tlZCwgc28gaXMgdGhpc1xuICAgICAgICAvLyBUaGUgc2FtZSBhcyBmb3J3YXJkQ2hhbmdlRXZlbnRzVG8gZXhjZXB0IHRoYXQgdGhpcyBpcyB0aGUgdGFyZ2V0LCBub3QgdGhlIHNvdXJjZS5cbiAgICAgICAgYnViYmxlRnJvbS5zdWJzY3JpYmUodGhpcy5jaGFuZ2VIYW5kbGVyLmRlbGVnYXRlKTtcbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2VIYW5kbGVyLnVuc3Vic2NyaWJlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIH1cbiAgICB1bnN1YnNjcmliZVNlbmRlcihzZW5kZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlSGFuZGxlci51bnN1YnNjcmliZUxpc3RlbmVyKHNlbmRlcik7XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlRGVsZWdhdGUoZGVsZWdhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlSGFuZGxlci51bnN1YnNjcmliZURlbGVnYXRlKGRlbGVnYXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBwcm9iYWJseSBmcm93bmVkIHVwb24gKHNlZSBob3cgVFMgZG9lc24ndCBsaWtlIGl0KSwgYnV0IGl0J3MgdmFsaWQgSlMuXG4gICAgICogSXQncyBvbmx5IGludGVuZGVkIGZvciB0cm91Ymxlc2hvb3RpbmcsIG5vdCByZWFsIGxvZ2ljLiBUaGVyZSBhcmUgdGltZXMgd2hlbiB5b3UncmVcbiAgICAgKiB0cnlpbmcgdG8gaWRlbnRpZnkgZXhhY3RseSB3aGljaCBkZWxlZ2F0ZXMgYXJlIHN1YnNjcmliZWQsIGFuZCB0aGlzIGlzIHJlYWxseSBoYXJkIHdoZW5cbiAgICAgKiBub3RoaW5nIGhhcyBodW1hbi1yZWFkYWJsZSBuYW1lcy5cbiAgICAgKi9cbiAgICB0YWdEZWxlZ2F0ZShuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZUhhbmRsZXIuZGVsZWdhdGUuX3RhZyA9IG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VIYW5kbGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB4IGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh4ICE9PSBcImNoYW5nZUhhbmRsZXJcIiAmJiB4ICE9PSBcInByaXZhdGVQcm9wZXJ0eTJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdFt4XSA9IHRoaXNbeF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVCYXNlID0gT2JzZXJ2YWJsZUJhc2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEVzY2FwZUh0bWxfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL0VzY2FwZUh0bWxcIik7XG5jb25zdCBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3NfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vRXZlbnRIYW5kbGVyL1Byb3BlcnR5Q2hhbmdlZEV2ZW50QXJnc1wiKTtcbmNvbnN0IE5vbmVUeXBlXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1R5cGVzL05vbmVUeXBlXCIpO1xuY29uc3QgSXNQcmltaXRpdmVfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVXRpbGl0eS9Jc1ByaW1pdGl2ZVwiKTtcbmNvbnN0IElPYnNlcnZhYmxlXzEgPSByZXF1aXJlKFwiLi9JT2JzZXJ2YWJsZVwiKTtcbmNvbnN0IE9ic2VydmFibGVCYXNlXzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlQmFzZVwiKTtcbi8qKlxuICogQW4gT2JzZXJ2YWJsZVByb3BlcnR5IGlzIGEgcHJvcGVydHkgdGhhdCBhdXRvbWF0aWNhbGx5IHJhaXNlcyBhIFByb3BlcnR5Q2hhbmdlZCBldmVudCB3aGVuIGl0IGlzIG1vZGlmaWVkLiBUaGlzIGlzIG1vcmVcbiAqIGNvbnZlbmllbnQgdGhhbiBoYXZpbmcgdG8gZG8gaXQgbWFudWFsbHkgZXZlcnkgdGltZSB5b3UgbmVlZCBpdC5cbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZVByb3BlcnR5IGV4dGVuZHMgT2JzZXJ2YWJsZUJhc2VfMS5PYnNlcnZhYmxlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLl90cmlnZ2VyT25seU9uQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnByb3BlcnR5TmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnJztcbiAgICAgICAgdGhpcy5fdHJpZ2dlck9ubHlPbkNoYW5nZSA9IG9wdGlvbnMub25seVdoZW5DaGFuZ2VkIHx8IGZhbHNlO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG9sZCA9IHRoaXMuX3ZhbHVlO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fdHJpZ2dlck9ubHlPbkNoYW5nZSAmJiBvbGQgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdWJsaXNoUHJvcGVydHlDaGFuZ2VkKCdzZXQnLCB0aGlzLnByb3BlcnR5TmFtZSwgb2xkLCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgKGlmIGEgc3RyaW5nKSB0aGF0IGhhcyBoYWQgc3BlY2lhbCBIVE1MIGNoYXJhY3RlcnMgZXNjYXBlZC5cbiAgICAgKi9cbiAgICBnZXQgc2FmZVZhbHVlKCkge1xuICAgICAgICBpZiAoTm9uZVR5cGVfMS5pc05vbmUodGhpcy5fdmFsdWUpIHx8ICFJc1ByaW1pdGl2ZV8xLmlzUHJpbWl0aXZlKHRoaXMuX3ZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEVzY2FwZUh0bWxfMS5lc2NhcGVIdG1sKFN0cmluZyh0aGlzLl92YWx1ZSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHB1Ymxpc2hQcm9wZXJ0eUNoYW5nZWQodHlwZSwgcHJvcGVydHlOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNlbmRlcikge1xuICAgICAgICB0aGlzLmNoYW5nZUhhbmRsZXIuaW52b2tlKG5ldyBQcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3NfMS5Qcm9wZXJ0eUNoYW5nZWRFdmVudEFyZ3MoeyB0eXBlLCBwcm9wZXJ0eU5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgc2VuZGVyIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVQcm9wZXJ0eSA9IE9ic2VydmFibGVQcm9wZXJ0eTtcbmZ1bmN0aW9uIG9ic2VydmFibGVQcm9wZXJ0eUNoZWNrKG9iaikge1xuICAgIGlmICghSU9ic2VydmFibGVfMS5vYnNlcnZhYmxlQ2hlY2sob2JqKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEkgZG9uJ3QgbGlrZSB0aGlzIGJlY2F1c2UgaXQgc2hvdWxkIGJlIGNoZWNraW5nIGlmIHZhbHVlIGlzIGEgc2V0dGVyLFxuICAgIC8vIGFuZCBpdCBpc24ndCwgYmVjYXVzZSB0aGVyZSBpcyBubyB3YXkgdG8gY2hlY2suXG4gICAgLy8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcigpIGRvZXNuJ3QgY2F0Y2ggaW5oZXJpdGVkIHByb3BlcnRpZXMsIG9mXG4gICAgLy8gd2hpY2ggdGhpcyBpcyBhbG1vc3QgYWx3YXlzIG9uZS5cbiAgICAvLyBJIGhhdmUgdG8gZmFsbCBiYWNrIHRvIGEgYmFzaWMgaW5zdGFuY2UgY2hlY2suXG4gICAgcmV0dXJuIG9iaiAmJiBvYmogaW5zdGFuY2VvZiBPYnNlcnZhYmxlUHJvcGVydHk7XG59XG5leHBvcnRzLm9ic2VydmFibGVQcm9wZXJ0eUNoZWNrID0gb2JzZXJ2YWJsZVByb3BlcnR5Q2hlY2s7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFycmF5T2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcIi4vSW50ZXJuYWwvQXJyYXlPYnNlcnZhYmxlXCIpO1xuY29uc3QgQXJyYXlQcm94eUhhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL0ludGVybmFsL0FycmF5UHJveHlIYW5kbGVyXCIpO1xuY29uc3QgT2JqZWN0T2JzZXJ2YWJsZV8xID0gcmVxdWlyZShcIi4vSW50ZXJuYWwvT2JqZWN0T2JzZXJ2YWJsZVwiKTtcbmNvbnN0IE9iamVjdFByb3h5SGFuZGxlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJuYWwvT2JqZWN0UHJveHlIYW5kbGVyXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVByb3h5IHtcbiAgICBzdGF0aWMgcHJveGltYXRlKG1vZGVsLCBkaXNhYmxlQXN5bmMsIG9ubHlJZkNoYW5nZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZnVuY3Rpb25zLCBub3QgdGhhdCB0aGV5IHdvdWxkIGJlIHZlcnkgdXNlZnVsLlxuICAgICAgICAgICAgLy8gWWVzLCB0ZWNobmljYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gZGVmaW5lIHByb3BlcnRpZXMgb24gYSBmdW5jdGlvbi4gVGhleSBhcmUgYWN0dWFsXG4gICAgICAgICAgICAvLyBvYmplY3RzLiAgSW4gcHJhY3RpY2UsIGhvd2V2ZXIsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIHN0aWxsIG1ha2VzIHRoZW0gdW5kZWZpbmVkLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgICAgICAvLyBBbiBhcnJheSBwcm94eSBhbGxvd3MgY2hhbmdlcyB0byBhbiBhcnJheSB0byBiZSBvYnNlcnZlZC4gVGhlIGRvd24tc2lkZSBpcyB0aGF0IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBhbiBvcmRlciBvZiBtYWduaXR1ZGUgc2xvd2VyIHRoYW4gdXNpbmcgYW4gT2JzZXJ2YWJsZUxpc3QuICBUaGUgdXAtc2lkZSBpcyB0aGF0IGl0IHVzZXNcbiAgICAgICAgICAgIC8vIG1vcmUgdGhhbiBhbiBvcmRlciBvZiBtYWduaXR1ZGUgbGVzcyBjb2RlLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveGltYXRlQXJyYXkobW9kZWwsIGRpc2FibGVBc3luYywgb25seUlmQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vZGVsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveGltYXRlT2JqZWN0KG1vZGVsLCBkaXNhYmxlQXN5bmMsIG9ubHlJZkNoYW5nZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgYSBzaW1wbGUgdmFsdWUgaXMgcmV0dXJuZWQsIHJldHVybiBhIHByb3h5IGhhdmluZyBhIHZhbHVlIHByb3BlcnR5LlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveGltYXRlT2JqZWN0KHsgdmFsdWU6IG1vZGVsIH0sIGRpc2FibGVBc3luYywgb25seUlmQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjb25maWd1cmFibGUgdmVyc2lvbiBvZiBwcm94aW1hdGUoKSBjYWxsZWQgb24gYW4gb2JqZWN0LiBCeSBtYWtpbmcgaXQgZ2VuZXJhbGl6ZWQgYW5kIGNvbmZpZ3VyYWJsZSwgdGhpcyBhbGxvd3MgdGhlIGNhbGxlciB0b1xuICAgICAqIHRyYWNrIG1ldGhvZHMgdGhhdCBhcmUgY2FsbGVkLCBiYXNlZCBvbiBhIGNvbmZpZ3VyYWJsZSBsaXN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIG9iamVjdCBpcyBhIGNvbXBsZXggb2JqZWN0LCB3aGVyZSBjaGlsZCBvYmplY3RzIGFyZSBtb2RpZmllZCwgbm90IHRoZSBtYWluIG9iamVjdCwgY2hhbmdlcyB3b3VsZCBub3QgYmUgY2F1Z2h0LlxuICAgICAqIE9uZSB3YXkgdG8gaGFuZGxlIHRoYXQgaXMgdG8gbWFrZSB0aGUgY2hpbGQgb2JqZWN0IGEgcHJveHkuIEFub3RoZXIgd2F5IGlzIHRvIGFjY2VzcyB0aGUgY2hpbGQgb2JqZWN0IG9ubHkgdGhyb3VnaCBtZXRob2RzXG4gICAgICogYW5kIHVzZSB0aGlzLlxuICAgICAqL1xuICAgIHN0YXRpYyBwcm94aW1hdGVPYmplY3QobW9kZWwsIGRpc2FibGVBc3luYywgb25seUlmQ2hhbmdlZCwgbWV0aG9kc1RvV2F0Y2ggPSBbXSwgd2F0Y2hTZXQgPSB0cnVlLCB3YXRjaERlbGV0ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gV2UgY2FuJ3QgZG8gZnVuY3Rpb25zLCBub3QgdGhhdCB0aGV5IHdvdWxkIGJlIHZlcnkgdXNlZnVsLlxuICAgICAgICAgICAgLy8gWWVzLCB0ZWNobmljYWxseSB5b3Ugc2hvdWxkIGJlIGFibGUgdG8gZGVmaW5lIHByb3BlcnRpZXMgb24gYSBmdW5jdGlvbi4gVGhleSBhcmUgYWN0dWFsXG4gICAgICAgICAgICAvLyBvYmplY3RzLiAgSW4gcHJhY3RpY2UsIGhvd2V2ZXIsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIHN0aWxsIG1ha2VzIHRoZW0gdW5kZWZpbmVkLlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB0eXBlOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBJT2JzZXJ2YWJsZSBtZXRob2RzIHRvIHRoZSBtb2RlbCBzbyB0aGF0IGl0IGNhbiByYWlzZSBldmVudHMuXG4gICAgICAgIC8vIFdlIG11c3QgZXh0ZW5kIHRoZSBvcmlnaW5hbCBjbGFzcyAob3IgYXQgbGVhc3QgdGhlIG9iamVjdCkuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdE9ic2VydmFibGVfMS5PYmplY3RPYnNlcnZhYmxlLmdldE1lcmdlZE9ic2VydmFibGUobW9kZWwsIGRpc2FibGVBc3luYyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgT2JqZWN0UHJveHlIYW5kbGVyXzEuT2JqZWN0UHJveHlIYW5kbGVyKG1ldGhvZHNUb1dhdGNoIHx8IFtdLCB3YXRjaFNldCB8fCBmYWxzZSwgd2F0Y2hEZWxldGUgfHwgZmFsc2UsIG9ubHlJZkNoYW5nZWQgfHwgZmFsc2UpO1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xuICAgICAgICBPYnNlcnZhYmxlUHJveHkuX21vZGVscy5zZXQocHJveHksIHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJveGltYXRlIGFuIGFycmF5LlxuICAgICAqL1xuICAgIHN0YXRpYyBwcm94aW1hdGVBcnJheShtb2RlbCwgZGlzYWJsZUFzeW5jLCBvbmx5SWZDaGFuZ2VkKSB7XG4gICAgICAgIC8vIEFkZCBJT2JzZXJ2YWJsZSBtZXRob2RzIHRvIHRoZSBtb2RlbCBzbyB0aGF0IGl0IGNhbiByYWlzZSBldmVudHMuXG4gICAgICAgIC8vIFdlIG11c3QgZXh0ZW5kIHRoZSBvcmlnaW5hbCBhcnJheSBjbGFzcyAob3IgYXQgbGVhc3QgdGhlIGFycmF5IG9iamVjdCkuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IEFycmF5T2JzZXJ2YWJsZV8xLkFycmF5T2JzZXJ2YWJsZS5nZXRNZXJnZWRPYnNlcnZhYmxlKG1vZGVsLCBkaXNhYmxlQXN5bmMpO1xuICAgICAgICAvLyBUaGUgdHlwZSBoZXJlIGlzbid0IGFjY3VyYXRlLCBidXQgSSBoYXZlIG5vIGdvb2Qgd2F5IHRvIHBhc3MgdGhlIGtleSB0eXBlIHdpdGhvdXQgbWFraW5nIHRoaXMgY2xhc3Mgb25seSB3b3JrIGZvciBhcnJheXMuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBuZXcgQXJyYXlQcm94eUhhbmRsZXJfMS5BcnJheVByb3h5SGFuZGxlcigpO1xuICAgICAgICBjb25zdCBwcm94eSA9IG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xuICAgICAgICBPYnNlcnZhYmxlUHJveHkuX21vZGVscy5zZXQocHJveHksIHRhcmdldCk7XG4gICAgICAgIHJldHVybiBwcm94eTtcbiAgICB9XG59XG4vLyBUaGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdCBuZWVkcyB0byBiZSBzdG9yZWQgc29tZXdoZXJlIHNvIHRoYXQgdGhlIHByb3h5IGNhbiB3b3JrLlxuLy8gVGhlcmUncyBubyByZWFzb24gdGhhdCB0aGUgdXNlciBjYW4ndCBrZWVwIGEgY29weSBidXQgd2Ugc2hvdWxkbid0IGZvcmNlIHRoYXQuXG5PYnNlcnZhYmxlUHJveHkuX21vZGVscyA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnRzLk9ic2VydmFibGVQcm94eSA9IE9ic2VydmFibGVQcm94eTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXNjYXBlSHRtbF8xID0gcmVxdWlyZShcIi4uL0h0bWwvRXNjYXBlSHRtbFwiKTtcbmNvbnN0IFByb3BlcnR5Q2hhbmdlZEV2ZW50QXJnc18xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9FdmVudEhhbmRsZXIvUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzXCIpO1xuY29uc3QgTm9uZVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVHlwZXMvTm9uZVR5cGVcIik7XG5jb25zdCBDbG9uZURlZXBfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVXRpbGl0eS9DbG9uZURlZXBcIik7XG5jb25zdCBJc1ByaW1pdGl2ZV8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9VdGlsaXR5L0lzUHJpbWl0aXZlXCIpO1xuY29uc3QgSU9ic2VydmFibGVfMSA9IHJlcXVpcmUoXCIuL0lPYnNlcnZhYmxlXCIpO1xuY29uc3QgT2JzZXJ2YWJsZUJhc2VfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVCYXNlXCIpO1xuLyoqXG4gKiBBbiBvYnNlcnZhYmxlIHN0YXRlIHRoYXQgc2hvdWxkIG9ubHkgYmUgYWNjZXNzZWQgdXNpbmcgdGhlIHJlbGV2YW50IG1ldGhvZHMsIGFsbG93aW5nIGF0b21pYyBjaGFuZ2VzIHRvIG11bHRpcGxlIHByb3BlcnRpZXNcbiAqIGluIG11bHRpcGxlIG9iamVjdHMsIHJhaXNpbmcgYSBzaW5nbGUgZXZlbnQuXG4gKi9cbmNsYXNzIE9ic2VydmFibGVTdGF0ZSBleHRlbmRzIE9ic2VydmFibGVCYXNlXzEuT2JzZXJ2YWJsZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gXCJcIjtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JzZXJ2YWJsZVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IENsb25lRGVlcF8xLmNsb25lRGVlcCh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IENsb25lRGVlcF8xLmNsb25lRGVlcCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gb3B0aW9ucy5uYW1lIHx8ICdzZXRTdGF0ZSc7XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgLy8gSSB3b3VsZCBwcmVmZXIgdGhhdCB0aGlzIHJldHVybiBSZWFkb25seTxUPiBidXQgZ2V0dGVyIGFuZCBzZXR0ZXIgaGF2ZSB0byBiZSB0aGUgc2FtZSB0eXBlLlxuICAgICAgICAvLyBUaGF0IG1lYW5zIHlvdSB3b3VsZCBoYXZlIHRvIGNhc3QgYW55IHZhbHVlIHlvdSBzZXQgYXMgYSByZWFkb25seSwgd2hpY2ggaXMgYSBQSVRBLlxuICAgICAgICByZXR1cm4gQ2xvbmVEZWVwXzEuY2xvbmVEZWVwKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcndyaXRlcyB0aGUgZW50aXJlIHZhbHVlLlxuICAgICAqL1xuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHZhbHVlLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0U2FmZVZhbHVlKHByb3BlcnR5KSB7XG4gICAgICAgIC8vIElmIHZhbHVlIGlzIHByaW1pdGl2ZSwgdGhlbiBjYWxsIHRoaXMgd2l0aCBubyBhcmd1bWVudHMuXG4gICAgICAgIC8vIFRoYXQgaXMgdGhlIG9ubHkgY2FzZSB3aGVyZSBpdCBpcyBhbGxvd2VkLlxuICAgICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgICAgICBpZiAoIU5vbmVUeXBlXzEuaXNOb25lKHRoaXMuX3ZhbHVlKSAmJiBJc1ByaW1pdGl2ZV8xLmlzUHJpbWl0aXZlKHRoaXMuX3ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFc2NhcGVIdG1sXzEuZXNjYXBlSHRtbChTdHJpbmcodGhpcy5fdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRtcCA9IHRoaXMudmFsdWVbcHJvcGVydHldO1xuICAgICAgICBpZiAoTm9uZVR5cGVfMS5pc05vbmUodG1wKSB8fCAhSXNQcmltaXRpdmVfMS5pc1ByaW1pdGl2ZSh0bXApKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRXNjYXBlSHRtbF8xLmVzY2FwZUh0bWwoU3RyaW5nKHRtcCkpO1xuICAgIH1cbiAgICBnZXRWYWx1ZShwcm9wZXJ0eSkge1xuICAgICAgICAvLyBJZiB2YWx1ZSBpcyBwcmltaXRpdmUsIHRoZW4gY2FsbCB0aGlzIHdpdGggbm8gYXJndW1lbnRzLlxuICAgICAgICAvLyBUaGF0IGlzIHRoZSBvbmx5IGNhc2Ugd2hlcmUgaXQgaXMgYWxsb3dlZC5cbiAgICAgICAgaWYgKCFwcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCFOb25lVHlwZV8xLmlzTm9uZSh0aGlzLl92YWx1ZSkgJiYgSXNQcmltaXRpdmVfMS5pc1ByaW1pdGl2ZSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2xvbmVEZWVwXzEuY2xvbmVEZWVwKHRoaXMuX3ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbcHJvcGVydHldO1xuICAgIH1cbiAgICBnZXRTdGF0ZSgpIHtcbiAgICAgICAgLy8gVGhlIFJlYWRvbmx5IHR5cGUgd29ya3MgZmluZSBhbmQgaXQncyBmYXN0IC4uLiBpbiB0eXBlc2NyaXB0LlxuICAgICAgICAvLyBJbiBqYXZhc2NyaXB0LCBpZiB5b3UganVzdCByZXR1cm4gdGhlIHZhbHVlLCBub3RoaW5nIHByZXZlbnRzIGl0IGZyb20gYmVpbmcgZWRpdGVkLlxuICAgICAgICByZXR1cm4gQ2xvbmVEZWVwXzEuY2xvbmVEZWVwKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBzZXRTdGF0ZSh2YWx1ZSwgb3ZlcldyaXRlQWxsID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBDbG9uZURlZXBfMS5jbG9uZURlZXAodGhpcy5fdmFsdWUpO1xuICAgICAgICBsZXQgbmV3VmFsdWU7XG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgcHJpbWl0aXZlLCB0aGVuIGEgZnVsbCBvdmVyd3JpdGUgaXMgYWxsb3dlZFxuICAgICAgICBpZiAoSXNQcmltaXRpdmVfMS5pc1ByaW1pdGl2ZSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIEZ1bmN0aW9ucyB3aWxsIGV4ZWN1dGUgYnV0IHRoZXkgd29uJ3QgY2hhbmdlIHRoZSB2YWx1ZS4gVGhlIHJlYXNvbiBpcyB0aGUgc2FtZSByZWFzb24gdGhhdCB0aGlzIG1ha2VzIG5vIHBlcm1hbmVudCBjaGFuZ2UgdG8gYmFyOlxuICAgICAgICAgICAgLy8gdmFyIGZvbyA9IGZ1bmN0aW9uKHN0cikgeyBzdHIgPSBzdHIudG9VcHBlckNhc2UoKTsgfTsgdmFyIGJhciA9ICdhYmMnOyBmb28oYmFyKTsgY29uc29sZS5sb2coYmFyID09PSAnYWJjJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCBzZXRTdGF0ZSB3aXRoIGEgZnVuY3Rpb24gaWYgc3RhdGUgaXMgcHJpbWl0aXZlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3ZlcldyaXRlQWxsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3ZlcldyaXRlQWxsKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF9vdnIxX292ZXJ3cml0ZUFsbC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFtuZXdWYWx1ZSwgcmV0dXJuVmFsdWVdID0gX292cjNfZnVuY3Rpb25BcmcuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIHBhcnRpYWwgc3RhdGUgb3IgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3VmFsdWUgPSBfb3ZyMl9wYXJ0aWFsLmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVibGlzaFByb3BlcnR5Q2hhbmdlZCgnY2FsbCcsIHRoaXMucHJvcGVydHlOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHRoaXMpO1xuICAgICAgICByZXR1cm4geyBvbGRWYWx1ZSwgbmV3VmFsdWUsIHJldHVyblZhbHVlIH07XG4gICAgICAgIGZ1bmN0aW9uIF9vdnIxX292ZXJ3cml0ZUFsbChfdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE92ZXJ3cml0ZSB0aGUgZW50aXJlIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gQ2xvbmVEZWVwXzEuY2xvbmVEZWVwKF92YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9vdnIyX3BhcnRpYWwoX3ZhbHVlKSB7XG4gICAgICAgICAgICAvLyBQYXJ0aWFsIG9iamVjdDogT3ZlcndyaXRlIG9ubHkgdGhlIGtleXMgcHJvdmlkZWRcbiAgICAgICAgICAgIGNvbnN0IHRtcCA9IENsb25lRGVlcF8xLmNsb25lRGVlcCh0aGlzLl92YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdG1wW2tleV0gPSBfdmFsdWVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gQ2xvbmVEZWVwXzEuY2xvbmVEZWVwKHRtcCk7XG4gICAgICAgICAgICByZXR1cm4gdG1wO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9vdnIzX2Z1bmN0aW9uQXJnKF92YWx1ZSkge1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGUgZnVuY3Rpb24gcHJvdmlkZWQgYW5kIHVwZGF0ZSB0aGUgb2JqZWN0IGFzIGRpY3RhdGVkXG4gICAgICAgICAgICAvLyBNYXliZSB1bm5lY2Vzc2FyeSBidXQgd2Ugd2FudCB0byBhdm9pZCB0aGUgY2FsbGVyIGV4ZmlsdHJhdGluZyB0aGUgc3RhdGUgdXNpbmcgYSBmdW5jdGlvbixcbiAgICAgICAgICAgIC8vIGJ5IGFjY2lkZW50LiBPZiBjb3Vyc2UsIHRoZXkgY2FuIGp1c3QgYWNjZXNzIF92YWx1ZSBieSBjYXN0aW5nIGFzIGFueSxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGF0J3Mgbm90IGFjY2lkZW50YWwuXG4gICAgICAgICAgICBjb25zdCB0bXAgPSBDbG9uZURlZXBfMS5jbG9uZURlZXAodGhpcy5fdmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgX3JldHVyblZhbHVlID0gX3ZhbHVlLmNhbGwodG1wLCB0bXApO1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSBDbG9uZURlZXBfMS5jbG9uZURlZXAodG1wKTtcbiAgICAgICAgICAgIHJldHVybiBbdG1wLCBfcmV0dXJuVmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICBwdWJsaXNoUHJvcGVydHlDaGFuZ2VkKHR5cGUsIHByb3BlcnR5TmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBzZW5kZXIpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VIYW5kbGVyLmludm9rZShuZXcgUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzXzEuUHJvcGVydHlDaGFuZ2VkRXZlbnRBcmdzKHsgdHlwZSwgcHJvcGVydHlOYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIHNlbmRlciB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy5PYnNlcnZhYmxlU3RhdGUgPSBPYnNlcnZhYmxlU3RhdGU7XG5mdW5jdGlvbiBvYnNlcnZhYmxlU3RhdGVDaGVjayhvYmopIHtcbiAgICBpZiAoIUlPYnNlcnZhYmxlXzEub2JzZXJ2YWJsZUNoZWNrKG9iaikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBJIGRvbid0IGtub3cgaWYgSSBzaG91bGQgY2hlY2sgZm9yIHRoaXMgb3IgZm9yIGdldFN0YXRlKCkgYW5kIHNldFN0YXRlKClcbiAgICByZXR1cm4gb2JqICYmIG9iaiBpbnN0YW5jZW9mIE9ic2VydmFibGVTdGF0ZTtcbn1cbmV4cG9ydHMub2JzZXJ2YWJsZVN0YXRlQ2hlY2sgPSBvYnNlcnZhYmxlU3RhdGVDaGVjaztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ3JlYXRlRWxlbWVudF8xID0gcmVxdWlyZShcIi4uL0h0bWwvQ3JlYXRlRWxlbWVudFwiKTtcbmNvbnN0IERlbGV0ZU5vZGVDb250ZW50XzEgPSByZXF1aXJlKFwiLi4vSHRtbC9EZWxldGVOb2RlQ29udGVudFwiKTtcbmNvbnN0IEVsZW1lbnRUeXBlXzEgPSByZXF1aXJlKFwiLi4vSHRtbC9FbGVtZW50VHlwZVwiKTtcbmNvbnN0IEFycmF5VXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL0NvbGxlY3Rpb25zL0FycmF5VXRpbGl0aWVzXCIpO1xuY29uc3QgQ29uc3RydWN0YWJsZV8xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9UeXBlcy9Db25zdHJ1Y3RhYmxlXCIpO1xuY29uc3QgRWx2aXNfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVXRpbGl0eS9FbHZpc1wiKTtcbi8qKlxuICogSWYgeW91IGNsaWNrIGEgbGluayBpbiBhIHJlYWwgd2ViIHNpdGUsIHRoZSBicm93c2VyIGFza3MgdGhlIHNlcnZlciBmb3IgYSBwYWdlIGFuZCBpdCByb3V0ZXMgeW91IHRvIHRoZSByZWxldmFudFxuICogcGFnZS4gQnV0IGlmIHlvdSBoYXZlIGEgc2luZ2xlIHBhZ2UgYXBwIHJ1bm5pbmcgb24gYSBmaWxlLCB3aXRoIG5vIHdlYiBzZXJ2ZXIsIGxpa2UgdGhlIG9uZSB0aGlzIGZyYW1ld29ya1xuICogd2FzIGJ1aWx0IGZvciwgeW91IG5lZWQgc29tZXRoaW5nIHRvIHNpbXVsYXRlIHRoYXQuXG4gKlxuICogVGhlIEFkdmFuY2VkIHZlcnNpb24gb2YgdGhlIHJvdXRlciB3YXMgY3JlYXRlZCB0byBwcm92aWRlIHRoZSByZWN1cnNpdmVseS1uZXN0ZWQgcm91dGVzIHRoYXQgeW91IGNhbiBnZXQgd2l0aCBBbmd1bGFyLlxuICogSXQgZnVuY3Rpb25zLiBCdXQgSSBoYXRlIGl0LiBJIGRvbid0IGxpa2Ugc2V0dGluZyB1cCByb3V0ZXMgaW4gQW5ndWxhciBiZWNhdXNlIGl0IHRha2VzIGVkaXRpbmcgdG9vIG1hbnkgZmlsZXMgZXZlblxuICogZm9yIHNpbXBsZSBzaXRlcy4gVGhhdCBzYWlkLCBmb3IgYSB2ZXJ5IGxhcmdlIGFuZCBjb21wbGV4IHNpdGUgaXQncyBuaWNlIHRvIGhhdmUgdGhlIG9yZ2FuaXphdGlvbiwgc28gdGhlcmUncyB0aGF0LlxuICpcbiAqIEkgZm91bmQgdGhpcyB0byBiZSBjb21wbGV4IGFuZCBicml0dGxlIGFuZCBpZiB5b3Ugd2FudCB0byB1c2UgdGhlIGFkdmFuY2VkIGZlYXR1cmVzIChpdCdzIHByZXR0eSB0cml2aWFsIHRvIGhhdmUgdGhyZWVcbiAqIGNvbHVtbnMsIGVhY2ggcG9wdWxhdGVkIHZpYSB0aGUgcm91dGUsIGZvciBleGFtcGxlKSwgaXQgY2FuIGdldCBoYXJkIHRvIHNldCB1cCBhbmQgZWFzeSB0byBicmVhayAoYmUgY2FyZWZ1bCBub3RcbiAqIHRvIHRyeSB0byBwb3B1bGF0ZSBhIHJvdXRlci1vdXRsZXQgeW91IGp1c3QgcmVwbGFjZWQpLiBJbiB0ZXJtcyBvZiByZWFsIHVzZSBjYXNlcywgSSB3b3VsZCBwcmVmZXIgc2ltcGxlIHJvdXRlc1xuICogYW5kIGRvIHRoZSB3b3JrIGluIGNvbXBvbmVudHMuXG4gKlxuICogQnV0IHRoaXMgaXMgaGVyZSwgaWYgeW91IHdhbnQgdG8gdXNlIGl0LlxuICpcbiAqIFRoaXMgY2xhc3MgY2xlYXJzIHRoZSByb3V0ZSBjb250YWluZXIsIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3RhdGljIGNvbnRhaW5lciBpbiB0aGUgd3JhcHBlciBIVE1MIHBhZ2UsIG9yIHRoZSBib2R5LlxuICogV2hlbiB5b3UgZ2l2ZSBpdCB0aGUgcmVsZXZhbnQgcm91dGUsIGl0IGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvciByZXR1cm5zIHRoZSB2aWV3L0hUTUwgZWxlbWVudCB5b3UgZGVmaW5lZCBmb3IgdGhlIHJvdXRlLFxuICogYW5kIHN0aWNrcyBpdCBpbnNpZGUgdGhlIGNvbnRhaW5lci4gVGhlbiBpdCBzZWFyY2hlcyBmb3IgY2hpbGQgcm91dGVzIHRvIHB1dCBpbnRvIGNoaWxkIHJvdXRlIGNvbnRhaW5lcnMsIGV0YyxcbiAqIHVudGlsIGl0IHJ1bnMgb3V0IG9mIGNoaWxkcmVuLlxuICovXG5jbGFzcyBBZHZhbmNlZFBhZ2VSb3V0ZXIge1xuICAgIHN0YXRpYyBnZXQgbWF0Y2hlZFJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hlZFJvdXRlIHx8IHsgcm91dGU6ICcnLCBwYXJhbXM6IG5ldyBNYXAoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlZFJvdXRlLnBhcmFtcztcbiAgICB9XG4gICAgc3RhdGljIGdldCBoaXN0b3J5TWF4TGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlzdG9yeU1heExlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIHNldCBoaXN0b3J5TWF4TGVuZ3RoKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9oaXN0b3J5Lmxlbmd0aCA+IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9oaXN0b3J5Lmxlbmd0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hpc3RvcnlNYXhMZW5ndGggPSB2YWx1ZTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBoaXN0b3J5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGlzdG9yeTtcbiAgICB9XG4gICAgc3RhdGljIHNldCBub3RGb3VuZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ub3RGb3VuZCA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgY29uZmlndXJlKHJvdXRlcykge1xuICAgICAgICB0aGlzLl9yb3V0ZXMgPSByb3V0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB1cCBhIHRvcC1sZXZlbCByb3V0ZSwgd2hpY2ggaXMgZXhwZWN0ZWQgdG8gcm91dGUgdG8gdGhlIG1haW4gYXBwIGNvbnRhaW5lci4gVGhpcyBpcyBleHBlY3RlZCB0byBjb250YWluXG4gICAgICogYSBjaGlsZC1jb250YWluZXIgZWxlbWVudCwgd2hpY2ggY29udGFpbnMgbG93ZXIgbGV2ZWwgcm91dGVzIHRoYXQgYXJlIHN0b3JlZCBhcyBjaGlsZHJlbiwgYWRkZWQgdXNpbmcgdGhlIGFkZFJvdXRlKClcbiAgICAgKiBtZXRob2QuXG4gICAgICovXG4gICAgc3RhdGljIGFkZEFwcFJvdXRlKHBheWxvYWQsIHJvdXRlID0gJyonLCB1cmxSb3V0aW5nRW5hYmxlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKHVybFJvdXRpbmdFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBhbGxvd3MgZ29pbmcgdG8gYSBuZXcgcGFnZSBieSBjaGFuZ2luZyB0aGUgVVJMIGluc3RlYWQgb2YgaGF2aW5nIHRvIGlzc3VlIHJvdXRlKCkgY29tbWFuZHMuXG4gICAgICAgICAgICB0aGlzLnR1cm5PblVybFJvdXRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ29uc3RydWN0YWJsZV8xLmNvbnN0cnVjdG9yVHlwZUd1YXJkKHBheWxvYWQpIHx8IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFJvdXRlKHtcbiAgICAgICAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICByb3V0ZUNvbnRhaW5lcjogJ3BhZ2Utcm91dGVyJyxcbiAgICAgICAgICAgICAgICBzdGF0aWNSb3V0ZXJDb250YWluZXI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRSb3V0ZSh7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6ICgpID0+IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgcm91dGVDb250YWluZXI6ICdwYWdlLXJvdXRlcicsXG4gICAgICAgICAgICAgICAgc3RhdGljUm91dGVyQ29udGFpbmVyOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgYWRkUm91dGUocm91dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdXRlcy5maW5kKHEgPT4gcS5yb3V0ZSA9PT0gcm91dGUucm91dGUgJiZcbiAgICAgICAgICAgIChxLnJvdXRlQ29udGFpbmVyIHx8ICdjaGlsZC1jb250YWluZXInKSA9PT0gKHJvdXRlLnJvdXRlQ29udGFpbmVyIHx8ICdjaGlsZC1jb250YWluZXInKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvdXRlIGFuZCBjb250YWluZXIgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICB9XG4gICAgc3RhdGljIGRlbGV0ZVJvdXRlKHJvdXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5fcm91dGVzLmZpbmQocSA9PiBxLnJvdXRlID09PSByb3V0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvdXRlIG5vdCBmb3VuZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZpbmcgaXRlbXMgaXMgc3VjaCBhIHBhaW4uXG4gICAgICAgIGNvbnN0IHJvdXRlcyA9IHRoaXMuX3JvdXRlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyb3V0ZXNbaV0ucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcm91dGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcm91dGUocm91dGUsIHVwZGF0ZVVybCA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFyb3V0ZSkge1xuICAgICAgICAgICAgLy8gQWxsb3cgYWN0dWFsIGxpbmtzIHZpYSB0aGUgaGFzaC4gSGFzaCBsaW5rcyBkb24ndCBmb3JjZSBhIHBhZ2UgcmVsb2FkIGFuZCB0aGV5IHdvcmsgdy9vIGEgd2ViIHNlcnZlci5cbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIGhhdmluZyB0byBjYWxsIHJvdXRlKCkgbWFudWFsbHksIHlvdSBtdXN0IGNhbGwgdHVybk9uVXJsUm91dGluZygpO1xuICAgICAgICAgICAgcm91dGUgPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcHJvYmxlbSwgd2hpY2ggaXMgdGhhdCBzZXR0aW5nIHRoZSBoYXNoIHdpbGwgdHJpZ2dlciBBTk9USEVSIHJvdXRlIGNoYWluZ2UgdmlhIHRoZSBoYXNoY2hhbmdlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSBoYXNoIGNoYW5nZSBhbmQgdGhlbiByZXN0b3JpbmcgaXQgbGF0ZXIgZG9lcyBub3RoaW5nLiBJdCdzIHN0aWxsIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIC8vIFRoaXMgcmVxdWlyZXMgaGFja3dvcmsuIFNvIHlvdSBzZWUgd2h5IHRoaXMgcm91dGVyIGlzIG15IGxlYXN0IGZhdm9yaXRlIHBhcnQgb2YgdGhpcyBmcmFtZXdvcmsuIEl0J3MgYSBwaWxlIG9mIGhhY2tzOlxuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgdHJpZ2dlcmVkIGJ5IGEgaGFzaCBjaGFuZ2UgYW5kIHRoZSByb3V0ZSBpcyB0aGUgc2FtZSwgdGhlbiBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBsYXN0IHJvdXRlIHNvIHRoYXQgaXQgZG9lc24ndCBpbnRlcmZlcmUgd2l0aCB0aGUgbmV4dCBoYXNoIGNoYW5nZS5cbiAgICAgICAgICAgIGlmIChyb3V0ZSA9PT0gdGhpcy5fbGFzdFJvdXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFJvdXRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1cGRhdGVVcmwpIHtcbiAgICAgICAgICAgIC8vIElmIGEgcm91dGUgaXMgc2VudCBpbiwgdGhlbiBzZXQgdGhlIGhhc2guXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHJvdXRlO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Um91dGUgPSByb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgYSBjb3B5IG9mIHJvdXRlcywgYmVjYXVzZSAoMSkgdGhlIGxpc3Qgd2lsbCBiZSBtb2RpZmllZCBhbmQgKDIpIHJlZHVjZSBhY2Nlc3NlcyB0byBzdGF0aWMgcHJvcGVydGllcy5cbiAgICAgICAgLy8gSSdtIG5vdCBzdXJlIGlmIGFzeW5jIGhhc2ggdXBkYXRlIGV2ZW50cyB3aWxsIGFsbCBiZSBpbiB0aGUgc2FtZSB0aHJlYWQsIGJ1dCB0aGlzIGlzbid0IHRocmVhZC1zYWZlLlxuICAgICAgICBjb25zdCByb3V0ZUNvcHkgPSB0aGlzLl9yb3V0ZXMuc2xpY2UoMCkubWFwKG0gPT4gKHsgcm91dGU6IG0gfSkpO1xuICAgICAgICAvLyBGaW5kIG1hdGNoaW5nIHJvdXRlcy4gVHlwaWNhbGx5IHRoZXJlIHdpbGwgYmUgMCB0byAxIGJ1dCB0aGUgcm91dGVyIGFsbG93cyBtdWx0aXBsZXMsIG9uZSBwZXIgY29udGFpbmVyLlxuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHIgb2Ygcm91dGVDb3B5KSB7XG4gICAgICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHQgPSB0aGlzLl9zZWFyY2hSb3V0ZXMocm91dGUsIHIucm91dGUsIHJvdXRlQ29weSk7XG4gICAgICAgICAgICBpZiAoc2VhcmNoUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnB1c2goc2VhcmNoUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2gocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBSb3V0ZSAke3JvdXRlfSBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJOb3RGb3VuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhcmFtZXRlcnMgYXJlIGZvdW5kIGluIG11bHRpcGxlIHJvdXRlcywgdGhlIHBhcmFtcyBhcmUgbWVyZ2VkLCBidXQgT05MWSBUSEUgRklSU1QgdmFsdWUgZm9yIGFueSBwYXJhbSBpcyBrZXB0XG4gICAgICAgIC8vIFBhcmFtcyB3aWxsIGJlIHN0b3JlZCBpbiBhIGdsb2JhbCBjb2xsZWN0aW9uLiBJJ20gbm90IGdvaW5nIHRvIHNwbGl0IHRoZW0gdXAgYW5kIG1ha2UgdGhlIHByb2dyYW1tZXIgaHVudCBmb3IgdGhlbS5cbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgcGFyYW1zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHAuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtZXJnZWQuaGFzKGVudHJ5WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWQuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFN0YXJ0IHdyaXRpbmcgZGF0YSAqL1xuICAgICAgICB0aGlzLl9tYXRjaGVkUm91dGUgPSB7IHJvdXRlOiByb3V0ZSwgcGFyYW1zOiBtZXJnZWQgfTtcbiAgICAgICAgLy8gQWRkIHJvdXRlIHRvIGhpc3RvcnkgaWYgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMgbGF0ZXN0IGhpc3RvcnlcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPT09IDAgfHwgdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAxXSAhPT0gcm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChyb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiB0aGlzLmhpc3RvcnlNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3Rvcnkuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByY0Nsb25lID0gdGhpcy5fcm91dGVDb250YWluZXJzLnNsaWNlKDApO1xuICAgICAgICAvLyBBbnkgY29udGFpbmVycyBmcm9tIHRoZSBwcmV2aW91cyBpdGVyYXRpb24gdGhhdCBhcmUgbm90IG1hdGNoZWQgaW4gdGhpcyBvbmUgc2hvdWxkIGJlIHJlbW92ZWRcbiAgICAgICAgLy8gT25seSBrZWVwIG9uZXMgd2hlcmUgdGhlIHN0YXRpY1JvdXRlckNvbnRhaW5lciBmbGFnIGlzIHNldFxuICAgICAgICBmb3IgKGNvbnN0IHByZXYgb2YgcmNDbG9uZVxuICAgICAgICAgICAgLmZpbHRlcihyYyA9PiAhbWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZSA9PT0gcmMucm91dGUpIHx8ICFyYy5yb3V0ZS5zdGF0aWNSb3V0ZXJDb250YWluZXIpKSB7XG4gICAgICAgICAgICBpZiAocHJldi5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBwcmV2LmNvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmNDbG9uZS5maW5kSW5kZXgoZiA9PiBmID09PSBwcmV2KTtcbiAgICAgICAgICAgIHJjQ2xvbmUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgcm91dGUgY29udGFpbmVycyB0aGF0IGFyZW4ndCBzdGlsbCB0aGVyZSBmcm9tIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgICAgICByY0Nsb25lLnB1c2goLi4ubWF0Y2hlc1xuICAgICAgICAgICAgLmZpbHRlcihtID0+ICFyY0Nsb25lLmZpbmQocmMgPT4gcmMucm91dGUgPT09IG0ucm91dGUpKSk7XG4gICAgICAgIC8vIFRoZSBjb250YWluZXJzIG5lZWQgdG8gYmUgaW4gb3JkZXIgb2YgbWF0Y2hlcywgYnV0IHByZXZpb3VzIGl0ZXJhdGlvbnMgYXJlIHRoZXJlIGVhcmxpZXIuXG4gICAgICAgIC8vIFRoaXMgaXMgdG9vIHdlaXJkIHRvIHdvcmsgaW4gdGhlIHNvcnQgY29tbWFuZCwgYWZhaWtcbiAgICAgICAgY29uc3Qgc291cmNlID0gcmNDbG9uZS5zbGljZSgwKTtcbiAgICAgICAgY29uc3Qgc29ydGVkVGFyZ2V0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3QgciA9IHNvdXJjZS5maW5kKHEgPT4gcS5yb3V0ZSA9PT0gbWF0Y2gucm91dGUpO1xuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb3cgZGlkIGEgcm91dGUgbm90IGdldCBhZGRlZCB0byByb3V0ZUNvbnRhaW5lcnM/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3J0ZWRUYXJnZXQucHVzaChyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3V0ZUNvbnRhaW5lcnMgPSBzb3J0ZWRUYXJnZXQ7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgbGV0IHJvdXRlR3VhcmRzID0gW107XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaC5yb3V0ZS5yb3V0ZUd1YXJkcykpIHtcbiAgICAgICAgICAgICAgICByb3V0ZUd1YXJkcyA9IG1hdGNoLnJvdXRlLnJvdXRlR3VhcmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2gucm91dGUucm91dGVHdWFyZHMpIHtcbiAgICAgICAgICAgICAgICByb3V0ZUd1YXJkcy5wdXNoKG1hdGNoLnJvdXRlLnJvdXRlR3VhcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qgcmcgb2Ygcm91dGVHdWFyZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0ID0gcmcuY2hlY2tWYWxpZChtYXRjaC5yb3V0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUm91dGUgcGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUm91dGUobWF0Y2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBiYWNrKCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgaGlzdG9yeSB0byBnbyBiYWNrIHRvLCBkb24ndCBnbyBiYWNrLlxuICAgICAgICBpZiAodGhpcy5oaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oaXN0b3J5LnBvcCgpOyAvLyBDdXJyZW50IHJvdXRlIHNpdHMgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgY29uc3Qgcm91dGUgPSB0aGlzLl9oaXN0b3J5LnBvcCgpOyAvLyBwcmV2aW91cyByb3V0ZVxuICAgICAgICBpZiAocm91dGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHR1cm5PblVybFJvdXRpbmcoKSB7XG4gICAgICAgIHRoaXMuX2hhc2hDaGFuZ2UgPSAoZXZ0KSA9PiB7IHRoaXMucm91dGUoKTsgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCB0aGlzLl9oYXNoQ2hhbmdlKTtcbiAgICB9XG4gICAgc3RhdGljIF9zZWFyY2hSb3V0ZXModXJsLCByb3V0ZSwgcm91dGVzVG9TZWFyY2gpIHtcbiAgICAgICAgbGV0IHNlYXJjaCA9IFtdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3V0ZS5yb3V0ZSkpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IHJvdXRlLnJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VhcmNoID0gW3JvdXRlLnJvdXRlXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZWFyY2ggdGhlIHJvdXRlIHN0cmluZ3MgYW5kIGlmIHlvdSBmaW5kIG9uZSwgcmV0dXJuIHRoZSBtYXRjaC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IGlmIHlvdSBoYXZlIG11bHRpcGxlIHJvdXRlcyBpbiB0aGUgYXJyYXksIHdpdGggZGlmZmVyZW50IHBhcmFtcywgdGhlIHJlc3VsdHMgd2lsbCBiZSBvbmx5IHRoZSBmaXJzdC5cbiAgICAgICAgLy8gU2VyaW91c2x5LCBkb24ndCBkbyB0aGF0LiBBdCBsZWFzdCBvbmUgb2YgdGhvc2Ugcm91dGVzIGlzIGdpYmJlcmlzaC5cbiAgICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2VhcmNoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaFJlc3VsdCA9IHRoaXMuX3Rlc3RSb3V0ZShzY2gsIHVybCB8fCAnJyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91dGUgaGFzIGNoaWxkcmVuLCB0aGVuIGFkZCB0aGVtIHRvIHRoZSBlbmQgb2YgdGhlIG1hdGNoIGxpc3QgdG8gYmUgdGVzdGVkXG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIEpTIGlzIHBlcmZlY3RseSBPSyB3aXRoIG1vZGlmeWluZyBhbiBhcnJheSB0aGF0IHlvdSBhcmUgaXRlcmF0aW5nLCB1bmxpa2UgQyNcbiAgICAgICAgICAgICAgICBpZiAocm91dGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiByb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVzVG9TZWFyY2gucHVzaCh7IHJvdXRlOiBjaGlsZCwgcGFyZW50OiByb3V0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hSZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgX3Rlc3RSb3V0ZShyb3V0ZVN0cmluZywgdXJsU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKCFyb3V0ZVN0cmluZyB8fCAhdXJsU3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcm91dGVTdHJpbmcgPSByb3V0ZVN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocm91dGVTdHJpbmcuZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICAgICAgcm91dGVTdHJpbmcgPSByb3V0ZVN0cmluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVybFN0cmluZy5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICB1cmxTdHJpbmcgPSB1cmxTdHJpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlQXJyYXkgPSByb3V0ZVN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICBjb25zdCB1cmxBcnJheSA9IHVybFN0cmluZy5zcGxpdCgnLycpO1xuICAgICAgICAvLyBJZiByb3V0ZSBlbmRzIGluICosIGRvbid0IGNoZWNrIGFueXRoaW5nIGZ1cnRoZXIgdGhhbiB0aGF0IGluIHRoZSBVUkxcbiAgICAgICAgaWYgKHJvdXRlQXJyYXlbcm91dGVBcnJheS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICAgICAgICByb3V0ZUFycmF5Lmxlbmd0aC0tO1xuICAgICAgICAgICAgaWYgKHJvdXRlQXJyYXkubGVuZ3RoIDw9IHVybEFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHVybEFycmF5Lmxlbmd0aCA9IHJvdXRlQXJyYXkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNhbWUgbnVtYmVyIG9mIC8gY2hhcmFjdGVycyByZXF1aXJlZC5cbiAgICAgICAgaWYgKHJvdXRlQXJyYXkubGVuZ3RoICE9PSB1cmxBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyb3V0ZVNlZ21lbnQsIHVybFNlZ21lbnRdIG9mIEFycmF5VXRpbGl0aWVzXzEuemlwKHJvdXRlQXJyYXksIHVybEFycmF5KSkge1xuICAgICAgICAgICAgLy8gUGFyYW1ldGVycyBhcmUgYWxsb3dlZC4gT3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgbm90LlxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3Igbm8gb3B0aW9uYWwgcGFyYW1ldGVycyBpcyB0aGF0IGZpbmRpbmcgYSBtYXRjaCBiZXR3ZWVuIC9hLzo/cGFyYW0vYiBhbmQgL2EvYiBpcyB0b28gY29tcGxleC5cbiAgICAgICAgICAgIC8vIElzICdiJyBhIHBhcmFtIHZhbHVlIG9yIHBhcnQgb2YgdGhlIHJvdXRlLiBCYXNpY2FsbHksIG9wdGlvbmFsIHBhcmFtZXRlcnMgb25seSB3b3JrIGF0IHRoZSByb3V0ZSBlbmQuXG4gICAgICAgICAgICAvLyBJIG5vdGljZWQgdGhhdCBBU1AuTkVUIHdvcmtzIHRoYXQgd2F5LCBhbmQgSSBmb3VuZCBpdCBjb25mdXNpbmcgdGhhdCBvcHRpb25hbCBwYXJhbWV0ZXJzIG9ubHkgd29yayBhdCB0aGUgZW5kLlxuICAgICAgICAgICAgLy8gSnVzdCBjcmVhdGUgYSBuZXcgcm91dGUgd2l0aCB0aGUgb3B0aW9uYWwgcGFyYW0gbGVmdCBvdXQuXG4gICAgICAgICAgICBpZiAocm91dGVTZWdtZW50LnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaGFzKHVybFNlZ21lbnQuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgJHtyb3V0ZVN0cmluZ30gY29udGFpbnMgZHVwbGljYXRlcyBvZiB0aGUgc2FtZSBwYXJhbWV0ZXIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmFtcy5zZXQocm91dGVTZWdtZW50LnNsaWNlKDEpLCB1cmxTZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlU2VnbWVudCAhPT0gJyonICYmIHJvdXRlU2VnbWVudCAhPT0gdXJsU2VnbWVudC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHN0YXRpYyBfcmVuZGVyUm91dGUoeyByb3V0ZSwgcGFyZW50IH0pIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fcHJlcGFyZVJvdXRlckNvbnRhaW5lcihyb3V0ZSwgcGFyZW50KTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgaWYgKENvbnN0cnVjdGFibGVfMS5jb25zdHJ1Y3RvclR5cGVHdWFyZChyb3V0ZS5wYXlsb2FkKSkge1xuICAgICAgICAgICAgdmlldyA9IG5ldyByb3V0ZS5wYXlsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm91dGUucGF5bG9hZCkge1xuICAgICAgICAgICAgdmlldyA9IHJvdXRlLnBheWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIHZpZXcgd2FzIHJldHVybmVkXG4gICAgICAgIGlmICh2aWV3ICYmIHZpZXdUeXBlR3VhcmQodmlldykpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWV3LmNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZpZXcpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB2aWV3VHlwZUd1YXJkKHRlc3QpIHtcbiAgICAgICAgICAgIGlmIChcImNvbnRlbnRcIiBpbiB0ZXN0ICYmIHRlc3QuY29udGVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIF9yZW5kZXJOb3RGb3VuZCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gQ3JlYXRlRWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQoJ25vdC1mb3VuZCcsIHsgaWQ6ICdub3QtZm91bmQnIH0pO1xuICAgICAgICBEZWxldGVOb2RlQ29udGVudF8xLmRlbGV0ZU5vZGVDb250ZW50KGRvY3VtZW50LmJvZHkpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChDcmVhdGVFbGVtZW50XzEuY3JlYXRlRWxlbWVudChFbGVtZW50VHlwZV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCB7IGlubmVySFRNTDogdGhpcy5fbm90Rm91bmQgfHwgXCJRdW90aCB0aGUgUmF2ZW4sIDQwNFwiIH0pKTtcbiAgICB9XG4gICAgc3RhdGljIF9wcmVwYXJlUm91dGVyQ29udGFpbmVyKHJvdXRlLCBwYXJlbnRSb3V0ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX21hdGNoZWRSb3V0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9ncmFtbWluZ0Vycm9yOiBfcHJlcGFyZVJvdXRlckNvbnRhaW5lciBjYWxsZWQgb3V0IG9mIG9yZGVyLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvb2sgZm9yIHRoZSByb3V0ZSBjb250YWluZXIgZm9yIHRoZSByb3V0ZS4gSWYgaXQgZXhpc3RzLCBleGl0IGRvaW5nIG5vdGhpbmcuIFdlJ2xsIGtlZXAgaXQuXG4gICAgICAgIGNvbnN0IHJvdXRlQ29udGFpbmVyID0gdGhpcy5fcm91dGVDb250YWluZXJzLmZpbmQoZiA9PiBmLnJvdXRlID09PSByb3V0ZSk7XG4gICAgICAgIGlmICghcm91dGVDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW1taW5nRXJyb3I6IEZvcmdvdCB0byBhZGQgcm91dGVzIHRvIHJvdXRlIGNvbnRhaW5lcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIC8vIFNlZSBpZiB0aGlzIHJvdXRlIGhhcyBhIHBhcmVudCB0aGF0IGlzIG9uIHRoZSBwYWdlXG4gICAgICAgIHBhcmVudCA9IEVsdmlzXzEuZV8odGhpcy5fcm91dGVDb250YWluZXJzLmZpbmQocSA9PiBxLnJvdXRlID09PSBwYXJlbnRSb3V0ZSkpLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhZG9jdW1lbnQuYm9keS5jb250YWlucyhwYXJlbnQpKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHJvdXRlIGhhcyBhIGNvbnRhaW5lciwgdGhhdCBjb250YWluZXIgZXhpc3RzIGluIHRoZSBkb20sIGFuZCB0aGUgc3RhdGljUm91dGVyQ29udGFpbmVyIHNldHRpbmcgaXMgdHJ1ZSwgZXhpdFxuICAgICAgICBpZiAocm91dGUuc3RhdGljUm91dGVyQ29udGFpbmVyICYmIHJvdXRlQ29udGFpbmVyLmNvbnRhaW5lciAmJiAocGFyZW50IHx8IGRvY3VtZW50LmJvZHkpLmNvbnRhaW5zKHJvdXRlQ29udGFpbmVyLmNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJJZCA9IEVsdmlzXzEuZV8ocm91dGUpLnJvdXRlQ29udGFpbmVyIHx8ICdjaGlsZC1jb250YWluZXInO1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IGNvbnRhaW5lciBkb2Vzbid0IGV4aXN0IGluIHRoZSBkb20sIGFkZCB0byB0aGUgYm9keS5cbiAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWRvY3VtZW50LmJvZHkuY29udGFpbnMocGFyZW50KSkge1xuICAgICAgICAgICAgLy8gSSB3b3VsZCB0aGluayB0aGVyZSdzIGFsd2F5cyBhIGJvZHkgZWxlbWVudCwgYnV0IHR5cGVzY3JpcHQgc2VlbXMgdG8gdGhpbmsgaXQgY291bGQgYmUgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBUaGlzIGRpZG4ndCBhY3R1YWxseSBmaXggdGhlIFRTIGVycm9yLCB0aG91Z2guXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdib2R5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5ib2R5O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHRoaXMuX3JvdXRlQ29udGFpbmVycy5maW5kSW5kZXgocSA9PiBxLnJvdXRlID09PSByb3V0ZSk7XG4gICAgICAgIGlmICh0aGlzLl9yb3V0ZUNvbnRhaW5lcnNcbiAgICAgICAgICAgIC5zbGljZSgwLCBjdXJyZW50SW5kZXgpIC8vIE9ubHkgY2hlY2sgZWFybGllciBjb250YWluZXJzXG4gICAgICAgICAgICAuZmluZChxID0+ICEhcS5jb250YWluZXJcbiAgICAgICAgICAgICYmIHEuY29udGFpbmVyLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gY29udGFpbmVySWQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgJiYgISFwYXJlbnQucXVlcnlTZWxlY3Rvcihjb250YWluZXJJZCkpKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2coYFJvdXRlOiBbJHtyb3V0ZS5yb3V0ZX1dLiBDb250YWluZXIgWyR7Y29udGFpbmVySWR9XSBhZGRlZCB0byBET00gYnkgYW5vdGhlciByb3V0ZS4gU2tpcHBpbmcuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Um91dGVyID0gQ3JlYXRlRWxlbWVudF8xLmNyZWF0ZUVsZW1lbnQoY29udGFpbmVySWQpOyAvKiB7IGlkOiBjb250YWluZXJJZCB9ICovXG4gICAgICAgIGNvbnN0IG9sZFJvdXRlciA9IHBhcmVudC5xdWVyeVNlbGVjdG9yKGNvbnRhaW5lcklkKTtcbiAgICAgICAgaWYgKG9sZFJvdXRlcikge1xuICAgICAgICAgICAgKG9sZFJvdXRlci5wYXJlbnRFbGVtZW50IHx8IHBhcmVudCkucmVwbGFjZUNoaWxkKG5ld1JvdXRlciwgb2xkUm91dGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChuZXdSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcm91dGUgY29udGFpbmVyIHJlY29yZCB3aXRoIHRoZSByb3V0aW5nIGNvbnRhaW5lciB3ZSBjcmVhdGVkLlxuICAgICAgICByb3V0ZUNvbnRhaW5lci5jb250YWluZXIgPSBuZXdSb3V0ZXI7XG4gICAgICAgIHJldHVybiBuZXdSb3V0ZXI7XG4gICAgfVxufVxuQWR2YW5jZWRQYWdlUm91dGVyLl9yb3V0ZXMgPSBbXTtcbkFkdmFuY2VkUGFnZVJvdXRlci5faGlzdG9yeSA9IFtdO1xuQWR2YW5jZWRQYWdlUm91dGVyLl9oaXN0b3J5TWF4TGVuZ3RoID0gNTA7XG5BZHZhbmNlZFBhZ2VSb3V0ZXIuX3JvdXRlQ29udGFpbmVycyA9IFtdO1xuZXhwb3J0cy5BZHZhbmNlZFBhZ2VSb3V0ZXIgPSBBZHZhbmNlZFBhZ2VSb3V0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENyZWF0ZUVsZW1lbnRfMSA9IHJlcXVpcmUoXCIuLi9IdG1sL0NyZWF0ZUVsZW1lbnRcIik7XG5jb25zdCBEZWxldGVOb2RlQ29udGVudF8xID0gcmVxdWlyZShcIi4uL0h0bWwvRGVsZXRlTm9kZUNvbnRlbnRcIik7XG5jb25zdCBFbGVtZW50VHlwZV8xID0gcmVxdWlyZShcIi4uL0h0bWwvRWxlbWVudFR5cGVcIik7XG5jb25zdCBBcnJheVV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uL1N5c3RlbS9Db2xsZWN0aW9ucy9BcnJheVV0aWxpdGllc1wiKTtcbmNvbnN0IENvbnN0cnVjdGFibGVfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVHlwZXMvQ29uc3RydWN0YWJsZVwiKTtcbmNvbnN0IEtleXdvcmRBcmd1bWVudHNfMSA9IHJlcXVpcmUoXCIuLi9TeXN0ZW0vVHlwZXMvS2V5d29yZEFyZ3VtZW50c1wiKTtcbmNvbnN0IE5vbmVUeXBlXzEgPSByZXF1aXJlKFwiLi4vU3lzdGVtL1R5cGVzL05vbmVUeXBlXCIpO1xuLyoqXG4gKiBJZiB5b3UgY2xpY2sgYSBsaW5rIGluIGEgcmVhbCB3ZWIgc2l0ZSwgdGhlIGJyb3dzZXIgYXNrcyB0aGUgc2VydmVyIGZvciBhIHBhZ2UgYW5kIGl0IHJvdXRlcyB5b3UgdG8gdGhlIHJlbGV2YW50XG4gKiBwYWdlLiBCdXQgaWYgeW91IGhhdmUgYSBzaW5nbGUgcGFnZSBhcHAgcnVubmluZyBvbiBhIGZpbGUsIHdpdGggbm8gd2ViIHNlcnZlciwgbGlrZSB0aGUgb25lIHRoaXMgZnJhbWV3b3JrXG4gKiB3YXMgYnVpbHQgZm9yLCB5b3UgbmVlZCBzb21ldGhpbmcgdG8gc2ltdWxhdGUgdGhhdC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNsZWFycyB0aGUgcm91dGUgY29udGFpbmVyLCB3aGljaCBpcyBleHBlY3RlZCB0byBiZSBhIHN0YXRpYyBjb250YWluZXIgaW4gdGhlIHdyYXBwZXIgSFRNTCBwYWdlLCBvciB0aGUgYm9keS5cbiAqIFdoZW4geW91IGdpdmUgaXQgdGhlIHJlbGV2YW50IHJvdXRlLCBpdCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb3IgcmV0dXJucyB0aGUgdmlldy9IVE1MIGVsZW1lbnQgeW91IGRlZmluZWQgZm9yIHRoZSByb3V0ZSxcbiAqIGFuZCBzdGlja3MgaXQgaW5zaWRlIHRoZSBjb250YWluZXIuIFRoZSBlbGVtZW50IHJldHVybmVkIGNhbiBiZSB3cmFwcGVkIGluIGEgbGF5b3V0IHZpZXcsIGxpa2UgaW4gQVNQLk5ldC5cbiAqXG4gKiBUaGlzIGlzIGEgc2ltcGxlIHZlcnNpb24sIHdpdGhvdXQgdGhlIHJlY3Vyc2l2ZSByb3V0ZXMgZm91bmQgaW4gdGhlIGFkdmFuY2VkIHJvdXRlci4gSXQgd2FzIGJhc2VkIG1vcmUgb24gQVNQLk5ldCBvciBub2RlLmpzXG4gKiByb3V0aW5nLCB3aGVyZSB5b3UgaGF2ZSBhIGZsYXQgc2V0IG9mIHJvdXRlcyBhbmQgb25jZSB5b3UgZmluZCBhIHJvdXRlLCB5b3UncmUgZG9uZS5cbiAqL1xuY2xhc3MgUGFnZVJvdXRlciB7XG4gICAgc3RhdGljIGdldCBhbGxSb3V0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3V0ZXM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgbWF0Y2hlZFJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF0Y2hlZFJvdXRlIHx8IHsgcm91dGU6ICcnLCBwYXJhbXM6IG5ldyBNYXAoKSwgY29uZmlnOiB7IHJvdXRlOiAnJyB9IH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgcGFyYW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaGVkUm91dGUucGFyYW1zO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGhpc3RvcnlNYXhMZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaXN0b3J5TWF4TGVuZ3RoO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0IGhpc3RvcnlNYXhMZW5ndGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hpc3RvcnkubGVuZ3RoID4gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkubGVuZ3RoID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlzdG9yeU1heExlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IGhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaXN0b3J5O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0IG5vdEZvdW5kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX25vdEZvdW5kID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbXVzdCBiZSBjYWxsZWQgZmlyc3QgYmVmb3JlIHVzaW5nIGl0LCBiZWNhdXNlIEpTIGRvZXNuJ3QgaGF2ZSBzdGF0aWMgY29uc3RydWN0b3JzIGxpa2UgQyMuIEl0IHNldHMgdXAgdGhlXG4gICAgICogcm91dGUgY29udGFpbmVyLCBjdXN0b20gZWxlbWVudHMsIGFuZCBhbHNvIGFsbG93cyBvbmUtc3RlcCBjb25maWd1cmF0aW9uIG9mIHNldmVyYWwgb3RoZXIgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEFjY2VwdHMgS2V5d29yZCBBcmd1bWVudHMuXG4gICAgICovXG4gICAgc3RhdGljIGNvbmZpZ3VyZShyb3V0ZXMgPSBbXSwgZGVmYXVsdExheW91dCwgZGVmYXVsdFN0YXRpY0xheW91dCwgbm90Rm91bmQsIGRlZmF1bHRSb3V0ZSwgdXJsUm91dGluZ0VuYWJsZWQgPSB0cnVlKSB7XG4gICAgICAgICh7IHJvdXRlcywgZGVmYXVsdExheW91dCwgZGVmYXVsdFN0YXRpY0xheW91dCwgbm90Rm91bmQsIGRlZmF1bHRSb3V0ZSwgdXJsUm91dGluZ0VuYWJsZWQgPSB0cnVlIH0gPSBLZXl3b3JkQXJndW1lbnRzXzEuS3dhcmcucGFyc2VBcmdzKHsgcm91dGVzLCBkZWZhdWx0TGF5b3V0LCBkZWZhdWx0U3RhdGljTGF5b3V0LCBub3RGb3VuZCwgZGVmYXVsdFJvdXRlLCB1cmxSb3V0aW5nRW5hYmxlZCB9KSk7IC8vIGt3YXJnbGluZVxuICAgICAgICB0aGlzLl9jb25maWd1cmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKG5vdEZvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RGb3VuZCA9IG5vdEZvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcnRlIG9mIHJvdXRlcykge1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBydGUubGF5b3V0ID0gcnRlLmxheW91dCB8fCBkZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOb25lVHlwZV8xLmlzTm9uZShkZWZhdWx0U3RhdGljTGF5b3V0KSAmJiBOb25lVHlwZV8xLmlzTm9uZShydGUuc3RhdGljTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIHJ0ZS5zdGF0aWNMYXlvdXQgPSBkZWZhdWx0U3RhdGljTGF5b3V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hZGRSb3V0ZShydGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmxSb3V0aW5nRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgYWxsb3dzIGdvaW5nIHRvIGEgbmV3IHBhZ2UgYnkgY2hhbmdpbmcgdGhlIFVSTCBpbnN0ZWFkIG9mIGhhdmluZyB0byBpc3N1ZSByb3V0ZSgpIGNvbW1hbmRzLlxuICAgICAgICAgICAgdGhpcy50dXJuT25VcmxSb3V0aW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3V0ZUNvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3BhZ2Utcm91dGVyJykgfHwgZG9jdW1lbnQuYm9keTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldCgncGFnZS1yb3V0ZXInKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3BhZ2Utcm91dGVyJywgRGl2UGFnZSwgeyBleHRlbmRzOiAnZGl2JyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghd2luZG93LmN1c3RvbUVsZW1lbnRzLmdldCgnbGF5b3V0LWJvZHknKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xheW91dC1ib2R5JywgRGl2TGF5b3V0LCB7IGV4dGVuZHM6ICdkaXYnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF3aW5kb3cuY3VzdG9tRWxlbWVudHMuZ2V0KCdub3QtZm91bmQnKSkge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ25vdC1mb3VuZCcsIERpdk5vdEZvdW5kLCB7IGV4dGVuZHM6ICdkaXYnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGN1c3RvbUVsZW1lbnRzIGlzbid0IG9mZmljaWFsbHkgcGFydCBvZiBhbiBFUyB2ZXJzaW9uIHlldCBzbyB3b24ndCB3b3JrIGV2ZW4gaW4gc29tZSByZWNlbnQtaXNoIGJyb3dzZXJzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZmF1bHRSb3V0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0Um91dGUoZGVmYXVsdFJvdXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3RlOiB0aGVyZSBpcyBubyByZW1vdmVSb3V0ZS4gVGhlcmUgY291bGQgYmUsIGJ1dCBpdCdzIG5ldmVyIG5lZWRlZC5cbiAgICBzdGF0aWMgYWRkUm91dGUocm91dGUpIHtcbiAgICAgICAgbGV0IHJvdXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm91dGUucm91dGUpKSB7XG4gICAgICAgICAgICByb3V0ZXMgPSByb3V0ZS5yb3V0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlcyA9IFtyb3V0ZS5yb3V0ZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBydGUgb2Ygcm91dGVzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcm91dGVzLmZpbmQocSA9PiBxLnJvdXRlID09PSBydGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm91dGUgYWxyZWFkeSBleGlzdHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG1wID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGUpO1xuICAgICAgICAgICAgdG1wLnJvdXRlID0gcnRlO1xuICAgICAgICAgICAgdGhpcy5fcm91dGVzLnB1c2godG1wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBsaW5rZWQgdG8gYSBwYXJ0aWN1bGFyIHBhZ2UgKG9uIHRoZSBoYXNoKSwgZ28gdG8gaXQuIEVsc2UsIGdvIHRvIHRoZSByb3V0ZSBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgc3RhdGljIGRlZmF1bHRSb3V0ZShyb3V0ZSkge1xuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2gpIHtcbiAgICAgICAgICAgIFBhZ2VSb3V0ZXIucm91dGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFBhZ2VSb3V0ZXIucm91dGUocm91dGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyByb3V0ZShyb3V0ZSwgdXBkYXRlVXJsID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZ3VyZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFnZVJvdXRlciBub3QgY29uZmlndXJlZC4gQ2FsbCBjb25maWd1cmUoKSBmaXJzdC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlKSB7XG4gICAgICAgICAgICAvLyBBbGxvdyBhY3R1YWwgbGlua3MgdmlhIHRoZSBoYXNoLiBIYXNoIGxpbmtzIGRvbid0IGZvcmNlIGEgcGFnZSByZWxvYWQgYW5kIHRoZXkgd29yayB3L28gYSB3ZWIgc2VydmVyLlxuICAgICAgICAgICAgLy8gVG8gYXZvaWQgaGF2aW5nIHRvIGNhbGwgcm91dGUoKSBtYW51YWxseSwgeW91IG11c3QgY2FsbCB0dXJuT25VcmxSb3V0aW5nKCk7XG4gICAgICAgICAgICByb3V0ZSA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpO1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBwcm9ibGVtLCB3aGljaCBpcyB0aGF0IHNldHRpbmcgdGhlIGhhc2ggd2lsbCB0cmlnZ2VyIEFOT1RIRVIgcm91dGUgY2hhaW5nZSB2aWEgdGhlIGhhc2hjaGFuZ2Ugb3BlcmF0aW9uLlxuICAgICAgICAgICAgLy8gUmVtb3ZpbmcgdGhlIGhhc2ggY2hhbmdlIGFuZCB0aGVuIHJlc3RvcmluZyBpdCBsYXRlciBkb2VzIG5vdGhpbmcuIEl0J3Mgc3RpbGwgdHJpZ2dlcmVkLlxuICAgICAgICAgICAgLy8gVGhpcyByZXF1aXJlcyBoYWNrd29yay4gRXZlbiB0aGUgc2ltcGxlIHJvdXRlciBoYXMgbW9yZSBoYWNrcyB0aGFuIEkgbGlrZS5cbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIHRyaWdnZXJlZCBieSBhIGhhc2ggY2hhbmdlIGFuZCB0aGUgcm91dGUgaXMgdGhlIHNhbWUsIHRoZW4gZG9uJ3QgZG8gYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgbGFzdCByb3V0ZSBzbyB0aGF0IGl0IGRvZXNuJ3QgaW50ZXJmZXJlIHdpdGggdGhlIG5leHQgaGFzaCBjaGFuZ2UuXG4gICAgICAgICAgICBpZiAocm91dGUgPT09IHRoaXMuX2xhc3RSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RSb3V0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodXBkYXRlVXJsKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJvdXRlIGlzIHNlbnQgaW4sIHRoZW4gc2V0IHRoZSBoYXNoLlxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSByb3V0ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RSb3V0ZSA9IHJvdXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbGFzdFJvdXRlID0gcm91dGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICBsZXQgc2VhcmNoUmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgcnRlIG9mIHRoaXMuX3JvdXRlcykge1xuICAgICAgICAgICAgc2VhcmNoUmVzdWx0ID0gdGhpcy5fdGVzdFJvdXRlKHJ0ZS5yb3V0ZSwgcm91dGUgfHwgJycpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gcnRlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUm91dGUgJHtyb3V0ZX0gbm90IGZvdW5kLmApO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyTm90Rm91bmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1JvdXRlID0gKHRoaXMuX21hdGNoZWRSb3V0ZSB8fCB7fSkuY29uZmlnO1xuICAgICAgICB0aGlzLl9tYXRjaGVkUm91dGUgPSB7IHJvdXRlLCBwYXJhbXM6IHNlYXJjaFJlc3VsdCB8fCBuZXcgTWFwKCksIGNvbmZpZzogbWF0Y2ggfTtcbiAgICAgICAgLy8gQWRkIHJvdXRlIHRvIGhpc3RvcnkgaWYgaXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgcHJldmlvdXMgbGF0ZXN0IGhpc3RvcnlcbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPT09IDAgfHwgdGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAxXSAhPT0gcm91dGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChyb3V0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiB0aGlzLmhpc3RvcnlNYXhMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3Rvcnkuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm91dGVHdWFyZHMgPSBbXTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0Y2gucm91dGVHdWFyZHMpKSB7XG4gICAgICAgICAgICByb3V0ZUd1YXJkcyA9IG1hdGNoLnJvdXRlR3VhcmRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hdGNoLnJvdXRlR3VhcmRzKSB7XG4gICAgICAgICAgICByb3V0ZUd1YXJkcy5wdXNoKG1hdGNoLnJvdXRlR3VhcmRzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJnIG9mIHJvdXRlR3VhcmRzKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0ID0gcmcuY2hlY2tWYWxpZChtYXRjaCk7XG4gICAgICAgICAgICBpZiAodGVzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUm91dGUgcGVybWlzc2lvbiBkZW5pZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVuZGVyUm91dGUobWF0Y2gsIHByZXZpb3VzUm91dGUpO1xuICAgIH1cbiAgICBzdGF0aWMgYmFjaygpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYW55IGhpc3RvcnkgdG8gZ28gYmFjayB0bywgZG9uJ3QgZ28gYmFjay5cbiAgICAgICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGlzdG9yeS5wb3AoKTsgLy8gQ3VycmVudCByb3V0ZSBzaXRzIGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgIGNvbnN0IHJvdXRlID0gdGhpcy5faGlzdG9yeS5wb3AoKTsgLy8gcHJldmlvdXMgcm91dGVcbiAgICAgICAgaWYgKHJvdXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucm91dGUocm91dGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0dXJuT25VcmxSb3V0aW5nKCkge1xuICAgICAgICB0aGlzLl9oYXNoQ2hhbmdlID0gKGV2dCkgPT4geyB0aGlzLnJvdXRlKCk7IH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdoYXNoY2hhbmdlJywgdGhpcy5faGFzaENoYW5nZSk7XG4gICAgfVxuICAgIHN0YXRpYyBfdGVzdFJvdXRlKHJvdXRlU3RyaW5nLCB1cmxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoIXJvdXRlU3RyaW5nIHx8ICF1cmxTdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByb3V0ZVN0cmluZyA9IHJvdXRlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChyb3V0ZVN0cmluZy5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICByb3V0ZVN0cmluZyA9IHJvdXRlU3RyaW5nLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJsU3RyaW5nLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgICAgIHVybFN0cmluZyA9IHVybFN0cmluZy5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm91dGVBcnJheSA9IHJvdXRlU3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IHVybEFycmF5ID0gdXJsU3RyaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgIC8vIFNhbWUgbnVtYmVyIG9mIC8gY2hhcmFjdGVycyByZXF1aXJlZC5cbiAgICAgICAgaWYgKHJvdXRlQXJyYXkubGVuZ3RoICE9PSB1cmxBcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtyb3V0ZVNlZ21lbnQsIHVybFNlZ21lbnRdIG9mIEFycmF5VXRpbGl0aWVzXzEuemlwKHJvdXRlQXJyYXksIHVybEFycmF5KSkge1xuICAgICAgICAgICAgLy8gUGFyYW1ldGVycyBhcmUgYWxsb3dlZC4gT3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgbm90LlxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiBmb3Igbm8gb3B0aW9uYWwgcGFyYW1ldGVycyBpcyB0aGF0IGZpbmRpbmcgYSBtYXRjaCBiZXR3ZWVuIC9hLzo/cGFyYW0vYiBhbmQgL2EvYiBpcyB0b28gY29tcGxleC5cbiAgICAgICAgICAgIC8vIElzICdiJyBhIHBhcmFtIHZhbHVlIG9yIHBhcnQgb2YgdGhlIHJvdXRlLiBCYXNpY2FsbHksIG9wdGlvbmFsIHBhcmFtZXRlcnMgb25seSB3b3JrIGF0IHRoZSByb3V0ZSBlbmQuXG4gICAgICAgICAgICAvLyBJIG5vdGljZWQgdGhhdCBBU1AuTkVUIHdvcmtzIHRoYXQgd2F5IGFuZCBJIGZvdW5kIGl0IGNvbmZ1c2luZyB0aGF0IG9wdGlvbmFsIHBhcmFtZXRlcnMgb25seSB3b3JrIGF0IHRoZSBlbmQuXG4gICAgICAgICAgICAvLyBKdXN0IGNyZWF0ZSBhIG5ldyByb3V0ZSB3aXRoIHRoZSBvcHRpb25hbCBwYXJhbSBsZWZ0IG91dC5cbiAgICAgICAgICAgIGlmIChyb3V0ZVNlZ21lbnQuc3RhcnRzV2l0aCgnOicpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSByb3V0ZVNlZ21lbnQuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgJHtyb3V0ZVN0cmluZ30gY29udGFpbnMgZHVwbGljYXRlcyBvZiB0aGUgc2FtZSBwYXJhbWV0ZXIuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNldChuYW1lLCB1cmxTZWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgbWFwcGVkIHN0YXRpYyBwYXJhbSBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBuYW1lLnNwbGl0KCc9JylbMV07XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCc9JylbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVybFNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSb3V0ZSAke3JvdXRlU3RyaW5nfSBjb250YWlucyBkdXBsaWNhdGVzIG9mIHRoZSBzYW1lIHBhcmFtZXRlci5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuc2V0KG5hbWUsIHVybFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlU2VnbWVudCAhPT0gdXJsU2VnbWVudC50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHN0YXRpYyBfcmVuZGVyUm91dGUocm91dGUsIHByZXZpb3VzKSB7XG4gICAgICAgIC8vIENhbGxpbmcgUGFnZVJvdXRlci5yb3V0ZSgndGhlIHNhbWUgdXJsJykgd2lsbCByZWxvYWQgdGhlIGNvbnRlbnRzIGZyb20gc2NyYXRjaC5cbiAgICAgICAgLy8gQWRqdXN0aW5nIHdpbmRvdy5sb2NhdGlvbiB3aWxsIGRvIG5vdGhpbmcgaWYgdGhlIHJvdXRlIGlzIHRoZSBzYW1lLlxuICAgICAgICAvLyBJIHRoaW5rIHRoaXMgaXMgZmluZSwgYWZ0ZXIgc3RydWdnbGluZyBpbiBhbmd1bGFyIHRvIHJlbG9hZCB0aGUgcGFnZSBhbmQgZmluZGluZ1xuICAgICAgICAvLyBpdCBtdWNoIGhhcmRlci5cbiAgICAgICAgLy8gTm90ZSBpZiB5b3UgY2hhbmdlIHRoZSBsb2NhdGlvbiBiYXIsIENocm9tZSBmb3JjZXMgYSByZWxvYWQgb2YgUHJvZ3JhbS50cywgbm90aGluZyB5b3UgY2FuIGRvXG4gICAgICAgIC8vIGFib3V0IGl0IGJlY2F1c2UgQ2hyb21lIGlzIHRoZSBvbmUgdGhhdCBkaXNjYXJkZWQgeW91ciBzdGF0ZS5cbiAgICAgICAgbGV0IGNvbnRhaW5lciA9IHRoaXMucm91dGVDb250YWluZXI7XG4gICAgICAgIGNvbnN0IGtlZXBMYXlvdXQgPSByb3V0ZS5sYXlvdXQgJiYgcHJldmlvdXMgJiYgcm91dGUuc3RhdGljTGF5b3V0ICYmIHJvdXRlLmxheW91dCA9PT0gcHJldmlvdXMubGF5b3V0O1xuICAgICAgICBpZiAoIWtlZXBMYXlvdXQpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjb250ZW50cyBvZiBwYWdlLXJvdXRlclxuICAgICAgICAgICAgRGVsZXRlTm9kZUNvbnRlbnRfMS5kZWxldGVOb2RlQ29udGVudChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZWVwTGF5b3V0KSB7XG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdsYXlvdXQtYm9keScpO1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxsYXlvdXQtYm9keT4gZWxlbWVudCBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZS5sYXlvdXQpIHtcbiAgICAgICAgICAgIGxldCBsYXlvdXRWaWV3O1xuICAgICAgICAgICAgaWYgKENvbnN0cnVjdGFibGVfMS5jb25zdHJ1Y3RvclR5cGVHdWFyZChyb3V0ZS5sYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0VmlldyA9IG5ldyByb3V0ZS5sYXlvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJvdXRlLnBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRWaWV3ID0gcm91dGUubGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGF5b3V0VmlldyAmJiB2aWV3VHlwZUd1YXJkKGxheW91dFZpZXcpKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxheW91dFZpZXcuY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXlvdXRWaWV3KSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxheW91dFZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbGF5b3V0LWJvZHknKTtcbiAgICAgICAgICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8bGF5b3V0LWJvZHk+IGVsZW1lbnQgbm90IGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBMYXlvdXQpIHtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjb250ZW50cyBvZiBsYXlvdXQtYm9keSAoYnV0IGtlZXAgbGF5b3V0KVxuICAgICAgICAgICAgRGVsZXRlTm9kZUNvbnRlbnRfMS5kZWxldGVOb2RlQ29udGVudChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2aWV3O1xuICAgICAgICBpZiAoQ29uc3RydWN0YWJsZV8xLmNvbnN0cnVjdG9yVHlwZUd1YXJkKHJvdXRlLnBheWxvYWQpKSB7XG4gICAgICAgICAgICB2aWV3ID0gbmV3IHJvdXRlLnBheWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygcm91dGUucGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmlldyA9IHJvdXRlLnBheWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyb3V0ZS5wYXlsb2FkKSB7XG4gICAgICAgICAgICB2aWV3ID0gcm91dGUucGF5bG9hZC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpZXcgJiYgdmlld1R5cGVHdWFyZCh2aWV3KSkge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZpZXcuY29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldykge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZpZXdUeXBlR3VhcmQodGVzdCkge1xuICAgICAgICAgICAgaWYgKFwiY29udGVudFwiIGluIHRlc3QgJiYgdGVzdC5jb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgX3JlbmRlck5vdEZvdW5kKCkge1xuICAgICAgICBEZWxldGVOb2RlQ29udGVudF8xLmRlbGV0ZU5vZGVDb250ZW50KHRoaXMucm91dGVDb250YWluZXIpO1xuICAgICAgICB0aGlzLnJvdXRlQ29udGFpbmVyLmFwcGVuZENoaWxkKENyZWF0ZUVsZW1lbnRfMS5jcmVhdGVFbGVtZW50KEVsZW1lbnRUeXBlXzEuZWxlbWVudFR5cGUuSFRNTERpdkVsZW1lbnQsIHsgaWQ6ICdub3QtZm91bmQnLCBpbm5lckhUTUw6IHRoaXMuX25vdEZvdW5kIHx8IFwiUXVvdGggdGhlIFJhdmVuLCA0MDRcIiB9KSk7XG4gICAgfVxufVxuUGFnZVJvdXRlci5yb3V0ZUNvbnRhaW5lciA9IGRvY3VtZW50LmJvZHk7XG5QYWdlUm91dGVyLl9jb25maWd1cmVkID0gZmFsc2U7XG5QYWdlUm91dGVyLl9yb3V0ZXMgPSBbXTtcblBhZ2VSb3V0ZXIuX2hpc3RvcnkgPSBbXTtcblBhZ2VSb3V0ZXIuX2hpc3RvcnlNYXhMZW5ndGggPSA1MDtcbmV4cG9ydHMuUGFnZVJvdXRlciA9IFBhZ2VSb3V0ZXI7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuLy8gQSBjbGFzcyBpcyByZXF1aXJlZCBidXQgeW91J3JlIG5vdCBhbGxvd2VkIHRvIHVzZSB0aGUgZXhpc3RpbmcgY2xhc3MgYmVjYXVzZSBpdCBjYW4ndFxuLy8gYmUgY29uc3RydWN0ZWQgKGludmFsaWQgY29uc3RydWN0b3IpLiBBbmQgeW91IGFyZSBPTkxZIGFsbG93ZWQgdG8gZXh0ZW5kIEhUTUxFbGVtZW50LlxuLy8gQU5EIHRoZXkgbXVzdCBiZSB1bmlxdWUuXG5jbGFzcyBEaXZQYWdlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmNsYXNzIERpdkxheW91dCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG5jbGFzcyBEaXZOb3RGb3VuZCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBkZWZlcnJlZCBwcm9taXNlIGlzIGEgd3JhcHBlciBhcm91bmQgYSBwcm9taXNlIHRoYXQgYWxsb3dzIGl0IHRvIGJlIHRyaWdnZXJlZCBsYXRlci4gSW4gcHVyZSBKUywgdGhpcyBpcyBoYXJkZXJcbiAqIHRoYW4gaXQgbmVlZHMgdG8gYmUsIGFuZCBpdCB0YWtlcyBhIHdlaXJkIGhhY2sgdG8gbWFrZSBpdCB3b3JrLiBUaGlzIGNsYXNzIGlzIGxpdHRsZSBtb3JlIHRoYW4gYSB3cmFwcGVyIGFyb3VuZFxuICogc2FpZCBoYWNrLlxuICpcbiAqIE90aGVyd2lzZSwgdGhpcyB1c2VzIGEgcmVhbCBwcm9taXNlIGludGVybmFsbHksIHNvIGFzaWRlIGZyb20gdGhlIHdyYXBwaW5nIG9iamVjdCwgaXQgaGFzIG5vIHNwZWNpYWwgbG9naWMuIEkgY2hvc2VcbiAqIG5vdCB0byByZS1pbXBsZW1lbnQgdGhlIFByb21pc2UgQVBJIHN5bmNocm9ub3VzbHksIHNvIGl0IHVzZXMgdGhlIHNhbWUgbWljcm90YXNrIHF1ZXVlLlxuICpcbiAqIFRoZSB3cmFwcGluZyBBUEkgaXMgdHdlYWtlZCBhIGxpdHRsZSB0byBhdm9pZCBzb21lIGNvbW1vbiBwaXRmYWxscyB0aGF0IGFyZSBjYXVzZWQgYnkgZmxhd3MgaW4gdGhlIFByb21pc2VcbiAqIGRlc2lnbi4gRm9yIGV4YW1wbGUsIGhhdmluZyBvbmZ1bGZpbGxlZCBhbmQgb25yZWplY3RlZCBpbiB0aGUgc2FtZSBzdGVwIG1lYW5zIHRoYXQgZXJyb3JzIGluIHRoZSBmdWxmaWxsZWRcbiAqIGhhbGYgd2lsbCBub3QgYmUgY2F1Z2h0IGJ5IHRoZSBlcnJvciBoYW5kbGVyLiAgUmF0aGVyIHRoYW4gc2F5IFwiZG9uJ3QgdXNlIHRoYXQgaW5wdXRcIiBsaWtlIG1vc3QgaW5zdHJ1Y3RvcnMsXG4gKiBJIGp1c3QgZ290IHJpZCBvZiBpdCAoaXQncyBzdGlsbCBhY2Nlc3NpYmxlIG9uIHRoZSBvdXRwdXQgcHJvcGVydHksIGlmIHlvdSB3YW50IHRvIHVzZSBpdCAuLi4gYnV0IGRvbid0KS5cbiAqL1xuY2xhc3MgRGVmZXJyZWRQcm9taXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvbmZ1bGZpbGxlZCwgdGhyb3dPblVuaGFuZGxlZEVycm9yID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy50aHJvd09uVW5oYW5kbGVkRXJyb3IgPSB0aHJvd09uVW5oYW5kbGVkRXJyb3I7XG4gICAgICAgIC8qKiBVc2UgdGhpcyB0byBpbnZva2UgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1lbXB0eSBUUyBkb2Vzbid0IGtub3cgdGhhdCB0aGUgcHJvcGVydGllcyBhcmUgcmVwbGFjZWQgaW4gdGhlIHByb21pc2UgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMucmVzb2x2ZSA9IGZ1bmN0aW9uIF9kdW1teSgpIHsgfTtcbiAgICAgICAgLyoqIFVzZSB0aGlzIHRvIHJlamVjdCB0aGUgcHJvbWlzZSByaWdodCBvdXQuIFdoaWNoIGlzIHByb2JhYmx5IHVzZWxlc3MgYnV0IHlvdSBuZXZlciBrbm93LiAqL1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHkgVFMgZG9lc24ndCBrbm93IHRoYXQgdGhlIHByb3BlcnRpZXMgYXJlIHJlcGxhY2VkIGluIHRoZSBwcm9taXNlIGluIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLnJlamVjdCA9IGZ1bmN0aW9uIF9kdW1teSgpIHsgfTtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgd2VpcmQgaGFjayB0aGF0IGlzIHRoZSBiYXNpcyBvZiB0aGlzIGNsYXNzLiBJdCdzIGEgY2xvc3VyZSwgYnV0IHJldmVyc2VkLCBhcyB0aGVcbiAgICAgICAgLy8gZW5jbG9zZWQgcHJvcGVydHkgaXMgYW4gaW50ZXJuYWwgcmVmZXJlbmNlIGFjY2Vzc2VkIG91dHNpZGUgcmF0aGVyIHRoYW4gYW4gb3V0c2lkZSByZWZlcmVuY2VcbiAgICAgICAgLy8gYWNjZXNzZWQgaW5zaWRlLlxuICAgICAgICB0aGlzLl9wcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSBfcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gX3JlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZXJlIGlzIGFsd2F5cyBzb21ldGhpbmcgYXQgdGhlIGZpcnN0IGxldmVsLCBldmVuIGlmIGl0J3MganVzdCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgICAgLy8gV2Ugd2FudCB0aGUgZGVmYXVsdCBiZWhhdmlvciB0byBhbGxvdyB0aGUgZm9sbG93aW5nOlxuICAgICAgICAvLyBjb25zdCB3YWl0YWJsZSA9IG5ldyBEZWZlcnJlZFByb21pc2UoKTsgZXZlbnQuc3Vic2NyaWJlKHdhaXRhYmxlLnJlc29sdmUpOyBjb25zdCByID0gYXdhaXQgd2FpdGFibGUub3V0cHV0OyBjb25zb2xlLmxvZyhyKTtcbiAgICAgICAgLy8gSWYgeW91IGxlYXZlIG91dCB0aGUgaW5pdGlhbCBjYWxsYmFjaywgeW91J2xsIGdldCB1bmRlZmluZWQgaW5zdGVhZCBvZiB3aGF0IHRoZSBldmVudCBzZW5kcy5cbiAgICAgICAgaWYgKG9uZnVsZmlsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRoZW4ob25mdWxmaWxsZWQsIHRocm93T25VbmhhbmRsZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRoZW4ocmVzID0+IHJlcywgdGhyb3dPblVuaGFuZGxlZEVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgaW4gYXN5bmMvYXdhaXQgY29kZS4gVGhlIGZvbGxvd2luZyB3aWxsIHdvcmsgaWYgYSByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICogY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVmZXJyZWQub3V0cHV0O1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICovXG4gICAgZ2V0IG91dHB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gICAgfVxuICAgIC8qKiBUaGVuKCkgb25seSBoYXMgb25lIG9wdGlvbiwgYmVjYXVzZSBpdCdzIHRvbyBlYXN5IHRvIGZvcmdldCB0aGF0IHRoZSBvbnJlamVjdGVkIGNhbGxiYWNrIGRvZXNuJ3QgaGFuZGxlIHRoZSBvbmZ1bGxlZCBjYWxsYmFjay4gKi9cbiAgICB0aGVuKG9uZnVsZmlsbGVkLCB0aHJvd09uVW5oYW5kbGVkRXJyb3IgPSB0aGlzLnRocm93T25VbmhhbmRsZWRFcnJvcikge1xuICAgICAgICBpZiAob25mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9wcm9taXNlLnRoZW4ob25mdWxmaWxsZWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgdG8ga2VlcCBhIHByb21pc2UgZnJvbSwgYnkgZGVmYXVsdCwgZWF0aW5nIHVwIGFsbCBlcnJvcnMuIEl0J3MgdWdseS5cbiAgICAgICAgLy8gSXQgbWVhbnMgYSBsb3Qgb2YgZXh0cmEgc3RlcHMuIEl0IG1ha2VzIHN1cmUgdGhhdCBieSBkZWZhdWx0LCB0aGUgbGFzdCBzdGVwIGlzIGFsd2F5cyBhIGNhdGNoLlxuICAgICAgICBpZiAodGhyb3dPblVuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fcHJvbWlzZS5jYXRjaChlcnIgPT4geyB0aHJvdyAoZXJyKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNhdGNoKG9ucmVqZWN0ZWQsIHRocm93T25VbmhhbmRsZWRFcnJvciA9IHRoaXMudGhyb3dPblVuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgIGlmIChvbnJlamVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9taXNlID0gdGhpcy5fcHJvbWlzZS5jYXRjaChvbnJlamVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZ2FpbiB0aGlzIGlzIGEgbWVzcywgYnV0IHRoZSBjYXRjaCBoYW5kbGVyIGFib3ZlIGNvdWxkIHRocm93XG4gICAgICAgIGlmICh0aHJvd09uVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Byb21pc2UgPSB0aGlzLl9wcm9taXNlLmNhdGNoKGVyciA9PiB7IHRocm93IChlcnIpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkRlZmVycmVkUHJvbWlzZSA9IERlZmVycmVkUHJvbWlzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gZGVsYXkodGltZSkge1xuICAgIHJldHVybiAocmVzdWx0KSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZShyZXN1bHQpLCB0aW1lKSk7XG59XG5leHBvcnRzLmRlbGF5ID0gZGVsYXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IERlZmVycmVkUHJvbWlzZV8xID0gcmVxdWlyZShcIi4vRGVmZXJyZWRQcm9taXNlXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVkaWNhdGVkIHdlYiB3b3JrZXIgdGhhdCBjb21tdW5pY2F0ZXMgdmlhIGRlZmVycmVkcy4gSXQgY2FuIGV4ZWN1dGUgd2hhdGV2ZXIgZnVuY3Rpb25cbiAqIHlvdSBnaXZlIGl0LiBUYXNrU3RhcnQoKSBhY3RzIGtpbmQgb2YgbGlrZSBkb2luZyBuZXcgVGhyZWFkKCkgYW5kIFRocmVhZC5TdGFydCgpIGluIG9uZSBzdGVwLlxuICogSXQgaXMgcG9zc2libGUgdG8gZG8gYWxsIHRoaXMgbWFudWFsbHksIGJ1dCB0aGlzIGhlbHBlciBjbGFzcyBtYWtlcyBpdCBhIGZhaXJseSB0cml2aWFsIG9wZXJhdGlvbi5cbiAqXG4gKiBIYWNrd29yayBpcyB1c2VkIHRvIGF2b2lkIHRoZSBuZWVkIHRvIGNyZWF0ZSBhIHNwZWNpYWxpemVkIHdlYiB3b3JrZXIganMgZmlsZS4gVGhlIHdvcmtlciBjcmVhdGVkIHRha2VzIGFcbiAqIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMsIGV4ZWN1dGVzIHRoZW0gaW4gaXRzIG93biB0aHJlYWQsIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKlxuICogRnVydGhlciBoYWNrd29yayBpcyBuZWVkZWQgYmVjYXVzZSB3ZWIgd29ya3MgaGF2ZSBubyBhY2Nlc3MgdG8gbW9kdWxlcywgbm8gYWNjZXNzIHRvIGNsb3N1cmVzLCBhbmQgY2FuIG9ubHlcbiAqIGNvbW11bmlhdGUgaW4gc3RyaW5ncy4gVGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG5lZWRzIHRvIGJlIHBhc3NlZCBhcyBhIHN0cmluZyBpbiB0aGUgbWVzc2FnZSBiZXR3ZWVuXG4gKiB0aHJlYWRzLlxuICpcbiAqIFdoaWxlIGl0IGlzIHBvc3NpYmxlIHRvIGNyZWF0ZSBhIHZlcnNpb24gdGhhdCBkb2VzIG5vdCBuZWVkIHRvIGV2YWwoKSB0aGUgZnVuY3Rpb24gc3RyaW5nIG9uIGV2ZXJ5IGV4ZWN1dGlvbixcbiAqIHRoaXMgcmVxdWlyZXMgdGhlIGNhbGxlciB0byBtYW51YWxseSBjb2RlIGV2ZXJ5dGhpbmcgdGhhdCB5b3Ugc2VlIGluIGhlcmUgdGhlIGNvbnN0cnVjdG9yLiBObyBoZWxwZXJzIGFyZSBhbGxvd2VkXG4gKiAobm8gYWNjZXNzIHRvIG90aGVyIG9iamVjdHMpLiBJZiB5b3Ugd2FudGVkIHRvIGRvIGV2ZXJ5dGhpbmcgeW91cnNlbGYsIHlvdSBjb3VsZCBqdXN0IG1ha2UgYSB3ZWIgd29ya2VyIHRoZSByaWdodFxuICogd2F5LCB3aXRob3V0IHRoZSBoZWxwZXIuXG4gKi9cbmNsYXNzIER5bmFtaWNXZWJXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlZmVycmVkSWQgPSAwO1xuICAgICAgICB0aGlzLmRlZmVycmVkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZnVuY3Rpb24gc2V0dXBGdW5jKCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gc2VsZjtcbiAgICAgICAgICAgIC8vIFNldCB1cCB3aGF0IGhhcHBlbnMgd2hlbiBhIG1lc3NhZ2UgaXMgc2VudCB0byB0aGUgd29ya2VyLlxuICAgICAgICAgICAgLy8gSWYgeW91J3JlIHdpbGxpbmcgdG8gd3JpdGUgYWxsIHRoaXMsIGJ1dCByZW1lbWJlciB0byBkZWZpbmUgeW91ciBmbiBmdW5jdGlvblxuICAgICAgICAgICAgLy8gYmVmb3JlIG9ubWVzc2FnZSwgeW91IGNhbiBza2lwIHRoZSBldmFsKCkgc3RlcC5cbiAgICAgICAgICAgIGN0eC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgZm4sIGFyZ3MgfSA9IGV2dC5kYXRhO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFjayBhbGxvd3MgYSBzaW5nbGUgZGVkaWNhdGVkIHdlYiB3b3JrZXIgdG8gaGFuZGxlIGFueSBmdW5jdGlvbi4gQmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgd29ya2VyIGhhcyBubyBhY2Nlc3MgdG8gY2xvc3VyZXMsIGl0IGhhcyBubyBhY2Nlc3MgdG8gY29tcGxleCBvYmplY3RzLiBJdFxuICAgICAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBnZXQgdGhlIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaW4gdGhlIG1lc3NhZ2UsIHdoaWNoIGNvbnRhaW5zIHNpbXBsZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHksIHN0cmluZ3MgYW5kIG51bWJlcnMuIFNvIGl0IGhhcyB0byBiZSBzZXJpYWxpemVkIGFuZCB0aGVuIGRlc2VyaWFsaXplZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIGRlc2VyaWFsaXplIGl0IGlzIHRvIGV2YWwoKSBpdC4gUHJldHR5IGhvcnJpZmZpYy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnByZWZlci1jb25zdFxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5wdXRGdW5jO1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZXZhbFxuICAgICAgICAgICAgICAgICAgICBldmFsKFwiaW5wdXRGdW5jID0gXCIgKyBmbiArIFwiO1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJnYXJyYXkgPSBKU09OLnBhcnNlKGFyZ3MpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnB1dEZ1bmMoLi4uYXJnYXJyYXkpOyAvLyBFdmFsdWF0ZSB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVzcG9uc2UgYmFjay5cbiAgICAgICAgICAgICAgICAgICAgY3R4LnBvc3RNZXNzYWdlKHsgaWQsIHJlc3VsdDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjdHgucG9zdE1lc3NhZ2UoeyBpZCwgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldFVwV29ya2VyKHNldHVwRnVuYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0aW5nIGEgdGFzayByZXR1cm5zIGEgZGVmZXJyZWQgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHdvcmtlciB0aHJlYWQgaGFzIGNvbXBsZXRlZCBpdHMgdGFzay5cbiAgICAgKlxuICAgICAqIFJlbWVtYmVyIHRoYXQgY2xvc3VyZXMgRE8gTk9UIFdPUksuIFBhc3MgeW91ciBhcmd1bWVudHMgKHdoaWNoIG11c3QgYmUgSlNPTi5zdHJpbmdpZmlhYmxlKS5cbiAgICAgKi9cbiAgICB0YXNrU3RhcnQoZm4sIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmRlZmVycmVkSWQrKztcbiAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBmbjogZm4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGFyZ3M6IEpTT04uc3RyaW5naWZ5KGFyZ3MpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkUHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLmRlZmVycmVkcy5zZXQoaWQsIGRlZmVycmVkKTtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLm91dHB1dFxuICAgICAgICAgICAgLnRoZW4ocmVzcCA9PiBKU09OLnBhcnNlKHJlc3AgfHwgJycpKVxuICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7IHRocm93IChlcnIgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpOyB9KTtcbiAgICB9XG4gICAgX3NldFVwV29ya2VyKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIEhlcmUncyB0aGUgbWFpbiBoYWNrIGFuZCBpdCdzIGEgZG9venkuXG4gICAgICAgIC8vIE5vcm1hbGx5LCB5b3UgYXJlIHJlcXVpcmVkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgd29ya2VyLmpzIGZpbGUgZm9yIHdlYiB3b3JrZXJzIGFuZCBsaW5rXG4gICAgICAgIC8vIHRvIHRoZW0gd2hlbiBsb2FkaW5nIHRoZSBwYWdlLiBPYnZpb3VzbHkgdGhhdCBtYWtlcyBpdCBpbXBvc3NpYmxlIHRvIGRlZmluZSB0aGVtIGF0IHJ1bnRpbWUuXG4gICAgICAgIC8vIFRvIGdldCBhcm91bmQgdGhlIGxpbWl0YXRpb24sIHRoaXMgZW5jb2RlcyB0aGUgd29ya2VyIGFzIGFuIG9iamVjdCBVUkwgKHdoaWNoIHJlcXVpcmVzIGNvbnZlcnNpb25cbiAgICAgICAgLy8gdG8gYSBzdHJpbmcpIGFuZCBsb2FkcyB0aGF0LlxuICAgICAgICB0aGlzLndvcmtlciA9IG5ldyBXb3JrZXIoVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJygnICsgY2FsbGJhY2sudG9TdHJpbmcoKSArICcpKCk7J10pKSk7XG4gICAgICAgIHRoaXMud29ya2VyLm9ubWVzc2FnZSA9IGV2dCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCByZXN1bHQsIGVycm9yIH0gPSBldnQuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5kZWZlcnJlZHMuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmICghZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWZlcnJlZCBwcm9taXNlIGlzIG1pc3NpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5EeW5hbWljV2ViV29ya2VyID0gRHluYW1pY1dlYldvcmtlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRGVmZXJyZWRQcm9taXNlXzEgPSByZXF1aXJlKFwiLi9EZWZlcnJlZFByb21pc2VcIik7XG4vKipcbiAqIFRoZSBwcm9taXNlIEFQSSBpcyBuaWNlLCBtb3N0bHksIGJ1dCB0aGUgbWFpbiB0aGluZyBwcmV2ZW50aW5nIHVzZSBvZiBhIHByb21pc2UgYXMgYW4gZXZlbnQgaGFuZGxlciBpcyB0aGF0XG4gKiBpdCBvbmx5IGV4ZWN1dGVzIG9uY2UuIEFmdGVyIHRoYXQgcG9pbnQsIGl0IGlzIHJlc29sdmVkLCBhbmQgdGhlcmUgaXMgbm8gd2F5IHRvIGZsaXAgaXQgYmFjay5cbiAqXG4gKiBUaGUgcmVwZWF0YWJsZSBwcm9taXNlIGtlZXBzIHRoZSBwcm9taXNlIEFQSSBhbmQgY3JlYXRlcyB0aGUgaWxsdXNpb24gdGhhdCB0aGUgcHJvbWlzZSBpcyByZXBlYXRlZCBieVxuICogcmVidWlsZGluZyB0aGUgY2hhaW4gZWFjaCB0aW1lLiBJdCdzIHJlYWxseSBhIGRlZmVycmVkIGZhY3RvcnkgYnV0IGl0IHByZXRlbmRzIHRvIGJlIGEgZGVmZXJyZWQuIEknbSBzdXJlXG4gKiB0aGlzIGhhcyBhIHBlcmZvcm1hbmNlIHBlbmFsdHkuXG4gKlxuICogWW91IHNob3VsZCBub3QgYXR0YWNoIGFjdHVhbCBwcm9taXNlcyBpbnRvIHRoZSB0aGVuKCkgY2hhaW4sIGJlY2F1c2UgdGhleSBjYW4ndCBiZSByZXBlYXRlZC4gVGhlIFByb21pc2UgdHlwZSBpc24ndFxuICogYWxsb3dlZCBidXQgdGhlcmUgYXJlIHdheXMgdG8gZ2V0IGFyb3VuZCB0aGUgVFMgY29tcGlsZXIuIFRoZSBUUyB0eXBlIGRlZmluaXRpb24gZm9yIFByb21pc2UgYW5kIFByb21pc2VMaWtlIGlzbid0XG4gKiBjb21wbGV0ZWx5IGNvcnJlY3QsIGFueXdheSwgc28gaXQncyBlYXN5IHRvIGdldCB1c2VkIHRvIHVzaW5nIHRoZSBhbnkgdHlwZSBhbmQgbWFrZSBicm9rZW4gY29kZS5cbiAqXG4gKiBZb3UgY2Fubm90IGFzeW5jL2F3YWl0IGEgcmVwZWF0YWJsZSBwcm9taXNlIGl0c2VsZiBidXQgeW91IGNhbiBhd2FpdCBhIHNpbmdsZSByZXNvbHV0aW9uLiBBc3luYy9hd2FpdCBpcyBzdWdhciB0aGF0XG4gKiBjcmVhdGVzIGEgcmVndWxhciwgbm9uLXJlcGVhdGFibGUsIHByb21pc2UuXG4gKi9cbmNsYXNzIFJlcGVhdGFibGVQcm9taXNlIHtcbiAgICBjb25zdHJ1Y3RvcihvbmZ1bGZpbGxlZCwgb25VbmhhbmRsZWRFcnJvciwgLy8gVGhpcyBhZGRzIGEgY2FsbGJhY2sgYXQgdGhlIGVuZCAob3IgMm5kIGZyb20gdGhlIGVuZCwgc2VlIG5leHQgb3B0aW9uKVxuICAgIHRocm93T25VbmhhbmRsZWRFcnJvciA9IGZhbHNlIC8vIFRoaXMga2VlcHMgYSBwcm9taXNlIGZyb20sIGJ5IGRlZmF1bHQsIGVhdGluZyB1cCBhbGwgZXJyb3JzLiBJdCBhZGRzIGEgZmluYWwgY2F0Y2ggdGhhdCB0aHJvd3MgaWYgaGl0LlxuICAgICkge1xuICAgICAgICB0aGlzLm9uVW5oYW5kbGVkRXJyb3IgPSBvblVuaGFuZGxlZEVycm9yO1xuICAgICAgICB0aGlzLnRocm93T25VbmhhbmRsZWRFcnJvciA9IHRocm93T25VbmhhbmRsZWRFcnJvcjsgLy8gVGhpcyBrZWVwcyBhIHByb21pc2UgZnJvbSwgYnkgZGVmYXVsdCwgZWF0aW5nIHVwIGFsbCBlcnJvcnMuIEl0IGFkZHMgYSBmaW5hbCBjYXRjaCB0aGF0IHRocm93cyBpZiBoaXQuXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gW107XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZXJlIGlzIGFsd2F5cyBzb21ldGhpbmcgYXQgdGhlIGZpcnN0IGxldmVsLCBldmVuIGlmIGl0J3MganVzdCByZXR1cm5pbmcgdGhlIHJlc3VsdC4gVXNlZnVsIGZvciBhc3luYy9hd2FpdCBjb2RlLlxuICAgICAgICBpZiAob25mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGhlbihvbmZ1bGZpbGxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRoZW4ocmVzID0+IHJlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgd29yazpcbiAgICAvLyBjb25zdCByZXBlYXRhYmxlID0gbmV3IFJlcGVhdGFibGVQcm9taXNlKCk7IGNvbnN0IHIgPSBhd2FpdCByZXBlYXRhYmxlLnJlc29sdmUoKTsgY29uc29sZS5sb2cocik7XG4gICAgcmVzb2x2ZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmJ1aWxkKCk7XG4gICAgICAgIHByb21pc2UucmVzb2x2ZShhcmdzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2Uub3V0cHV0O1xuICAgIH1cbiAgICByZWplY3QoYXJncykge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gdGhpcy5idWlsZCgpO1xuICAgICAgICBwcm9taXNlLnJlamVjdChhcmdzKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2Uub3V0cHV0O1xuICAgIH1cbiAgICAvLyBUaGVuKCkgb25seSBoYXMgb25lIG9wdGlvbiwgYmVjYXVzZSBpdCdzIHRvbyBlYXN5IHRvIGZvcmdldCB0aGF0IHRoZSBvbnJlamVjdGVkIGNhbGxiYWNrIGRvZXNuJ3QgaGFuZGxlIHRoZSBvbmZ1bGxlZCBjYWxsYmFjay5cbiAgICB0aGVuKG9uZnVsZmlsbGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goeyBvbmZ1bGZpbGxlZDogb25mdWxmaWxsZWQgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYXRjaChvbnJlamVjdGVkKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goeyBvbnJlamVjdGVkOiBvbnJlamVjdGVkIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIGxldCBwcm9taXNlO1xuICAgICAgICBmb3IgKGNvbnN0IGNiIG9mIHRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgdGhlIGZpcnN0IGlzIGFsd2F5cyBvbmZ1bGZpbGxlZCBhbmQgaXMgbmV2ZXIgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgaWYgKCFjYi5vbmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgaW4gUmVwZWF0YWJsZVByb21pc2UgY29uc3RydWN0b3IuIEZpcnN0IG9uZnVsZmlsbGVkIGlzIG51bGwuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9taXNlID0gbmV3IERlZmVycmVkUHJvbWlzZV8xLkRlZmVycmVkUHJvbWlzZShjYi5vbmZ1bGZpbGxlZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2Iub25mdWxmaWxsZWQpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlLnRoZW4oY2Iub25mdWxmaWxsZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2Iub25yZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goY2Iub25yZWplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCdWcgaW4gUmVwZWF0YWJsZVByb21pc2UgY29uc3RydWN0b3IuIE5vIGNhbGxiYWNrcywgbm90IGV2ZW4gdGhlIGRlZmF1bHQgZmlyc3Qgb25mdWxmaWxsZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9uVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UuY2F0Y2godGhpcy5vblVuaGFuZGxlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aHJvd09uVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UuY2F0Y2goZXJyID0+IHsgdGhyb3cgKGVycik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVwZWF0YWJsZVByb21pc2UgPSBSZXBlYXRhYmxlUHJvbWlzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSZXR1cm4gZWxlbWVudHMgb2YgYXJyYXkgYSBsaW5lZCB1cCB3aXRoIGVsZW1lbnRzIG9mIGFycmF5IGIuIEJvdGggYXJyYXlzIGRvbid0IGhhdmUgdG8gYmUgdGhlIHNhbWUgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiB6aXAoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCA+PSBiLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYS5tYXAoKGVsZW1lbnQsIGluZGV4KSA9PiBbZWxlbWVudCwgYltpbmRleF1dKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiLm1hcCgoZWxlbWVudCwgaW5kZXgpID0+IFthW2luZGV4XSwgYl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuemlwID0gemlwO1xuLyoqXG4gKiBSZXR1cm4gYSBjYXJ0ZXNpYW4gam9pbiAoY3Jvc3Mgam9pbikgYmV0d2VlbiBhcnJheXMgYSBhbmQgYi5cbiAqL1xuZnVuY3Rpb24gY2FydGVzaWFuKGEsIGIpIHtcbiAgICAvLy8gdHlwZXNjcmlwdCBwcmV2ZW50cyBhIGRpcmVjdCB1c2Ugb2YgY29uY2F0LCBzbyBkbyB0aGlzIG1hbnVhbGx5IHdpdGggYSBsb29wXG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaCguLi5iLm1hcChxID0+IFtpdGVtLCBxXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmV4cG9ydHMuY2FydGVzaWFuID0gY2FydGVzaWFuO1xuLyoqXG4gKiBHZW5lcmF0ZSBhIHJhbmdlIG9mIGludGVnZXJzLCBjb3VudGluZyB1cCBieSAxLCBmb3IgdGhlIGdpdmVuIGxlbmd0aC4gU3RvbGVuIGZyb20gUHl0aG9uLlxuICovXG5mdW5jdGlvbiByYW5nZShsZW5ndGgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh7IGxlbmd0aDogbGVuZ3RoIH0sICh2YWx1ZSwga2V5KSA9PiBrZXkpO1xufVxuZXhwb3J0cy5yYW5nZSA9IHJhbmdlO1xuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBpdGVtcyBhbmQgb3RoZXIgYXJyYXlzLCBmbGF0dGVuIHRoZW0gb3V0IGludG8gYSBzaW5nbGUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uKiB0cmF2ZXJzZShhcnIpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICB5aWVsZCBhcnI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiBhcnIpIHtcbiAgICAgICAgICAgIHlpZWxkKiB0cmF2ZXJzZShyb3cpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy50cmF2ZXJzZSA9IHRyYXZlcnNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIE1ha2UgaXQgZWFzaWVyIHRvIGNyZWF0ZSBzaW1wbGUgY29tcGFyaXNvbiBmdW5jdGlvbnMgb24gKHBvc3NpYmx5IGNvbXBsZXgpIG9iamVjdHMuIFR5cGljYWwgdXNlOiBhcnIuc29ydChvcmRlckJ5KG8gPT4gby5pZCkpXG4gKi9cbmZ1bmN0aW9uIG9yZGVyQnkocHJvcGVydHlGbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICBjb25zdCBmaXJzdFZhbHVlID0gcHJvcGVydHlGbihmaXJzdCk7XG4gICAgICAgIGNvbnN0IHNlY29uZFZhbHVlID0gcHJvcGVydHlGbihzZWNvbmQpO1xuICAgICAgICBpZiAoZmlyc3RWYWx1ZSA8IHNlY29uZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0VmFsdWUgPiBzZWNvbmRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbn1cbmV4cG9ydHMub3JkZXJCeSA9IG9yZGVyQnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEFycmF5Q2hhbmdlZEV2ZW50QXJncyB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2Ygb3BlcmF0aW9uIChtZXRob2QsIHNldCwgZGVsZXRlKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gJyc7XG4gICAgICAgIHRoaXMucHJvcGVydHlOYW1lID0gJyc7XG4gICAgICAgIHRoaXMuYXJncyA9IFtdO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGFyZ3MpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlDaGFuZ2VkRXZlbnRBcmdzID0gQXJyYXlDaGFuZ2VkRXZlbnRBcmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXBlYXRhYmxlUHJvbWlzZV8xID0gcmVxdWlyZShcIi4uL0FzeW5jL1JlcGVhdGFibGVQcm9taXNlXCIpO1xuLyoqXG4gKiBBIGRlbGVnYXRlIG9iamVjdCBpcyB1c2VkIGJ5IHRoZSBFdmVudEhhbmRsZXIuIEl0IGNvbnRhaW5zIGVub3VnaCBpbmZvcm1hdGlvbiB0byBleGVjdXRlIGEgY2FsbGJhY2sgc3luY2hyb25vdXNseSBvciBhc3luY2hyb25vdXNseVxuICogKHVzaW5nIGEgcHJvbWlzZSkuIEl0IGFsc28gYWRkcyBzb21lIHN0cmluZ3MgdG8gaGVscCBpbiB0cm91Ymxlc2hvb3RpbmcsIGJlY2F1c2Ugc2VhcmNoaW5nIGEgcmVjdXJzaXZlIGFycmF5IG9mIGNvbXBsZXggb2JqZWN0cyBjYW4gbWFrZVxuICogaXQgYSBiZWFyIHRvIGZpbmQgb3V0IHdoeSBhIGNhbGxiYWNrIGlzbid0IGJlaW5nIGV4ZWN1dGVkLlxuICovXG5jbGFzcyBEZWxlZ2F0ZSB7XG4gICAgY29uc3RydWN0b3IoY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICAgICAgLy8gSW4gbWFueSBjYXNlcyAoZm9yIGV4YW1wbGUsIHdoZW4gdXNpbmcgZmF0IGFycm93IGZ1bmN0aW9ucyksIHRoaXNBcmcgaXNcbiAgICAgICAgLy8gbm90IG5lZWRlZC4gQnV0IGluIG1vc3Qgb3RoZXJzLCBpdCBpcyBhbiBhbm5veWluZyBidWcgdGhhdCByZXF1aXJlcyB0cm91Ymxlc2hvb3RpbmdcbiAgICAgICAgLy8gdG8gZmlndXJlIG91dCB3aGF0IHRoZSBjYWxsZXIgZm9yZ290LiBJJ3ZlIHdhdmVyZWQgYmV0d2VlbiBtYWtpbmcgaXQgcmVxdWlyZWQgYW5kIG5vdC5cbiAgICAgICAgaWYgKCF0aGlzQXJnKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZWxlZ2F0ZSBjcmVhdGVkIHdpdGhvdXQgdGhpc0FyZy4gRGlkIHlvdSBtZWFuIHRvPycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhpc0FyZyA9IHRoaXNBcmc7XG4gICAgICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB0aGlzQXJnID09PSAnb2JqZWN0JyAmJiAnY29uc3RydWN0b3InIGluIHRoaXNBcmcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tPd25lck5hbWUgPSB0aGlzQXJnLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FsbGJhY2sgaXMgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHR5cGVzY3JpcHQgY29tcGlsZXIgc2hvdWxkIGhhbmRsZSB0aGlzIGNoZWNrIGJ1dCBjYW4ndCBhdCBydW50aW1lLlxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWxsYmFjayBtdXN0IGJlIGEgY2FsbGJhY2sgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmNhbGxiYWNrTmFtZSA9IGNhbGxiYWNrLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNhbGxiYWNrT3duZXJOYW1lICYmIHRoaXMuY2FsbGJhY2tOYW1lKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLmNhbGxiYWNrT3duZXJOYW1lfS4ke3RoaXMuY2FsbGJhY2tOYW1lfSgpYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNhbGxiYWNrTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jYWxsYmFja05hbWUgKyAnKCknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2FsbGJhY2tPd25lck5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY2FsbGJhY2tPd25lck5hbWUgKyAnLl9fbGFtYmRhX18oKSc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFJlcGVhdGFibGVQcm9taXNlXzEuUmVwZWF0YWJsZVByb21pc2UoY2FsbGJhY2suYmluZCh0aGlzQXJnKSk7XG4gICAgfVxufVxuZXhwb3J0cy5EZWxlZ2F0ZSA9IERlbGVnYXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcnJheVV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uL0NvbGxlY3Rpb25zL0FycmF5VXRpbGl0aWVzXCIpO1xuY29uc3QgRGVsZWdhdGVfMSA9IHJlcXVpcmUoXCIuL0RlbGVnYXRlXCIpO1xuLyoqXG4gKiBJIGNob3NlIHRvIHVzZSBDIyBzdHlsZSBldmVudHMsIG5vdCBKUy9UUywgYmVjYXVzZSB0aGUgSlMvVFMgd2F5IG9mIGRvaW5nIGRlbGVnYXRlcy9jdXN0b20gZXZlbnRzIGlzIGEgTklHSFRNQVJFLiBTdXJlLFxuICogQ3VzdG9tRXZlbnQgd29ya3MsIGJ1dCBvbiB0aGUgVFMgc2lkZSB0aGUgY29kZSByZXF1aXJlZCB0byBtYWtlIFRTQyBoYXBweSB3aXRoIHZhbGlkIGphdmFzY3JpcHQgaXMgYXdmdWwgYW5kIG5vbi1pbnR1aXRpdmUuXG4gKiBPbiB0aGUgSlMgc2lkZSwgeW91IGhhdmUgdGhlIHByb2JsZW0gdGhhdCBldmVyeSBoYW5kbGVyIHBpY2tzIGl0IHVwLCBub3QganVzdCB0aGUgb25lcyB0aGF0IGFyZSBib3VuZCB0byB0aGUgcmVsZXZhbnQgSFRNTFxuICogZWxlbWVudCwgc28gZWxlbWVudHMgbmVlZCB0byBwYXNzIHRoZSBzb3VyY2UgYXMgYW4gYXJndW1lbnQgYW5kIGNoZWNrIGl0IChsaWtlIGpxdWVyeSBhbmQgJChkb2N1bWVudCkub24oKSkuXG4gKlxuICogQWZ0ZXIgZ2V0dGluZyBpdCB3b3JraW5nLCBhbGwgSSBjb3VsZCB0aGluayBhYm91dCB3YXMgaG93IGJhZCB0aGUgY29kZSB3YXMsIHNvIEkgcmV3cm90ZSBpdCBhdm9pZGluZyB0aGUgSlMgcGF0dGVybiBlbnRpcmVseS5cbiAqXG4gKiBUaGlzIGNhbiBiZSBzeW5jaHJvbm91cyAoY2FsbGJhY2tzKSBvciBhc3luY2hyb25vdXMgKHByb21pc2VzKS4gIFdoZW4gaXQgaXMgYXN5bmMsIHRoZSBjb2RlIGV4ZWN1dGVzIGFmdGVyIHRoZSBjdXJyZW50IHN5bmNocm9ub3VzXG4gKiBldmVudHMgcnVuIHRvIGNvbXBsZXRpb24uIFRoaXMgY291bGQgY3JlYXRlIGJ1Z3MgaW4gc3luY2hyb25vdXMgY29kZSwgYnV0IGlzIGJlc3QgZm9yIGJyb3dzZXIgZXZlbnRzLiBUaGlzIGhhbmRsZXIgaXMgcHJpbWFyaWx5IHVzZWQgZm9yXG4gKiBicm93c2VyIGV2ZW50cywgc28gYXN5bmMgaXMgZGVmYXVsdC5cbiAqXG4gKiBCdXQgaWYgeW91J3JlIHRyaWdnZXJpbmcgYXN5bmMgZXZlbnRzIGluIGNvZGUgYW5kIHN0ZXBwaW5nIHRocm91Z2ggaXQgaW4gQ2hyb21lLCB3aGF0IHlvdSBzZWUgd29uJ3QgbWFrZSBzZW5zZSwgYmVjYXVzZSB0aGUgYXN5bmNcbiAqIGV2ZW50cyB3b24ndCBvY2N1ciB1bnRpbCByaWdodCBhd2F5LiBJdCBjYW4gYmUgaGFyZCB0byB0cm91Ymxlc2hvb3QuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbmNsYXNzIEV2ZW50SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoX2Rpc2FibGVBc3luYyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVBc3luYyA9IF9kaXNhYmxlQXN5bmM7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBbXTtcbiAgICB9XG4gICAgc3Vic2NyaWJlKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcmVjZWl2ZXMgYSBkZWxlZ2F0ZSAod2hpY2ggaXMgYW4gYXJyYXkgb2YgZGVsZWdhdGVzKSwgYWRkIGl0LlxuICAgICAgICAvLyBXaGVuIHRoaXMgaXMgaW52b2tlZCwgdGhhdCBkZWxlZ2F0ZSB3aWxsIGFsc28gYmUgaW52b2tlZC5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBfb3ZyMV9kZWxlZ2F0ZS5jYWxsKHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHb3QgYSBzaW5nbGUgY2FsbGJhY2tcbiAgICAgICAgLy8gT25seSBhbGxvdyBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgc2FtZSBjYWxsYmFjay5cbiAgICAgICAgaWYgKHRoaXMuZmluZCh7IGNhbGxiYWNrLCB0aGlzQXJnLCBmaXJzdE1hdGNoOiB0cnVlIH0pLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0RlbGUgPSBuZXcgRGVsZWdhdGVfMS5EZWxlZ2F0ZShjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucHVzaChuZXdEZWxlKTtcbiAgICAgICAgLy8gSUYgdGhpcyBpcyBhc3luY2hyb25vdXMsIHJldHVybiB0aGUgcHJvbWlzZSBzbyBpdCBjYW4gYmUgY2hhaW5lZC5cbiAgICAgICAgLy8gQ2hhaW5pbmcgd29uJ3Qgd29yayBvbiBzeW5jIGNvZGUsIHNvIGRvIG5vdCBpbiB0aGF0IGNhc2UuXG4gICAgICAgIGlmICghdGhpcy5fZGlzYWJsZUFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3RGVsZS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIF9vdnIxX2RlbGVnYXRlKGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFsbG93IGEgc2luZ2xlIGluc3RhbmNlIG9mIHRoZSBzYW1lIGRlbGVnYXRlLlxuICAgICAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuZmluZChxID0+IHEgPT09IGRlbGVnYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUucHVzaChkZWxlZ2F0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmVDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICAvLyBPbmx5IHNlYXJjaGVzIG5vbi1kZWxlZ2F0ZXNcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMuZGVsZWdhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy5kZWxlZ2F0ZVtpXTtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShxKSAmJiBxLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlTGlzdGVuZXIoc2VuZGVyKSB7XG4gICAgICAgIC8vIEZpcnN0IHRyeSB0byB1bnN1YnNjcmliZSB0aGUgZGVmYXVsdCBkZWxlZ2F0ZS4gQ2FuJ3QgZG8gYW55dGhpbmcgaWYgaXQgaGFzIGEgZGlmZmVyZW50IG5hbWUsIHRob3VnaC5cbiAgICAgICAgaWYgKFwiZGVsZWdhdGVcIiBpbiBzZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVEZWxlZ2F0ZShzZW5kZXIuZGVsZWdhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgc2VhcmNoZXMgbm9uLWRlbGVnYXRlc1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5kZWxlZ2F0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSB0aGlzLmRlbGVnYXRlW2ldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHEpICYmIHEudGhpc0FyZyA9PT0gc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5zdWJzY3JpYmVEZWxlZ2F0ZShkZWxlZ2F0ZSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5kZWxlZ2F0ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHEgPSB0aGlzLmRlbGVnYXRlW2ldO1xuICAgICAgICAgICAgaWYgKHEgPT09IGRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlKGFyZ3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBBcnJheVV0aWxpdGllc18xLnRyYXZlcnNlKHRoaXMuZGVsZWdhdGUpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Rpc2FibGVBc3luYykge1xuICAgICAgICAgICAgICAgIC8vIEFzeW5jIHZlcnNpb24uIERvZXMgbm90IHdvcmsgd2VsbCB3aXRoIHRoZSBjaHJvbWUgZGVidWdnZXIuXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIucHJvbWlzZS5yZXNvbHZlKGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbGJhY2suY2FsbChsaXN0ZW5lci50aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kKHsgY2FsbGJhY2ssIHRoaXNBcmcsIGZpcnN0TWF0Y2ggfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBBcnJheVV0aWxpdGllc18xLnRyYXZlcnNlKHRoaXMuZGVsZWdhdGUpKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2gobGlzdGVuZXIpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2sgJiYgbGlzdGVuZXIudGhpc0FyZyA9PT0gdGhpc0FyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci5jYWxsYmFjayA9PT0gY2FsbGJhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lci50aGlzQXJnID09PSB0aGlzQXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpOyAvLyBDbGVhcnMgdGhlIGRlbGVnYXRlXG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSB1bmRlZmluZWQ7IC8vIE1ha2VzIHN1cmUgdGhpcyBjYW4ndCBiZSB1c2VkIGFnYWluXG4gICAgfVxufVxuZXhwb3J0cy5FdmVudEhhbmRsZXIgPSBFdmVudEhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRXZlbnQgYXJndW1lbnRzIGV4cGVjdGVkIG9uIGFueSBDaGFuZ2UgZXZlbnQuXG4gKi9cbmNsYXNzIFByb3BlcnR5Q2hhbmdlZEV2ZW50QXJncyB7XG4gICAgY29uc3RydWN0b3IoYXJncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgY2hhbmdlIG9wZXJhdGlvbiAoc2V0LCBkZWxldGUpIChwb3RlbnRpYWxseSBtZXRob2QpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLlByb3BlcnR5Q2hhbmdlZEV2ZW50QXJncyA9IFByb3BlcnR5Q2hhbmdlZEV2ZW50QXJncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgY29uc3RydWN0b3IgdGhhdCBpcyBuZXdhYmxlLlxuICogVEhJUyBDQU5OT1QgREVURUNUIEFOT05ZTU9VUyBDTEFTU0VTLiBTb3JyeSwgYnV0IEpTIGRvZXNuJ3QgaGF2ZSBhIG5vbi1kZXN0cnVjdGl2ZSB3YXlcbiAqIHRvIGNoZWNrIGlmIGFueSBmdW5jdGlvbiBpcyBhIGNvbnN0cnVjdG9yIG90aGVyIHRoYW4gdG8gdHJ5IHRvIG5ldygpIGl0IGFuZCBibG93IHVwL25vdCBibG93IHVwLlxuICogVGhpcyBmdW5jdGlvbiBkZXBlbmRzIG9uIHRoZXJlIGJlaW5nIGEgcHJvdG90eXBlIHdpdGggYSBuYW1lZCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0b3JUeXBlR3VhcmQob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBvYmoucHJvdG90eXBlICYmIG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcbn1cbmV4cG9ydHMuY29uc3RydWN0b3JUeXBlR3VhcmQgPSBjb25zdHJ1Y3RvclR5cGVHdWFyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgSXNJbnRlZ2VyXzEgPSByZXF1aXJlKFwiLi4vVXRpbGl0eS9Jc0ludGVnZXJcIik7XG4vKipcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGtleXdvcmQgYXJndW1lbnRzLCBhcyBzZWVuIGluIFB5dGhvbiBhbmQgQyMuIEl0IG1ha2VzIGNvbmZpZ3VyYWJsZVxuICogZnVuY3Rpb25zIHNvIG11Y2ggcXVpY2tlciBhbmQgZWFzaWVyIHRoYW4gZmxhdCBhcmd1bWVudHMgKGZvcmNpbmcgeW91IHRvIHB1dCB1bmRlZmluZWQgbWFudWFsbHkgaW4gZGlmZmVyZW50XG4gKiBzbG90cykgb3Igb3B0aW9ucyBvYmplY3RzICh0YWtlcyBtb3JlIHRpbWUgdG8gcHJvZHVjZSwgZXNwZWNpYWxseSBpZiB5b3UgbmVlZCB0byBuZXcgaXQgdXApLlxuICpcbiAqIENhbGwgZnVuY3Rpb25zIGhhdmluZyBrZXl3b3JkIGFyZ3VtZW50cyB1c2luZyB0aGlzIHN5bnRheDpcbiAqIGNhbGxtZShhcmcxLCBhcmcyLCBrdygnc29tZXRoaW5nJywga3cxKSwga3coJ3NvbWV0aGluZ0Vsc2UnLCBrdzIpKVxuICpcbiAqIFRvIG1ha2UgdGhlbSB3b3JrLCBpbiB0aGUgZnVuY3Rpb24gaXRzZWxmLCB5b3UgbmVlZCB0byBjb3B5IGFuZCBwYXN0ZS4gRm9yIGV4YW1wbGU6XG4gKiAoeyBhcmcxLCBhcmcyLCBzb21ldGhpbmcsIHNvbWV0aGluZ0Vsc2UgfSA9IEt3YXJnLnBhcnNlKHsgYXJnMSwgYXJnMiwgc29tZXRoaW5nLCBzb21ldGhpbmdFbHNlIH0pKTtcbiAqL1xuY2xhc3MgS3dhcmcge1xuICAgIGNvbnN0cnVjdG9yKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG51bGwgZXhjZXB0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gYTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbWVtYmVyIHRoaXMgdGVtcGxhdGU6XG4gICAgICogKHsgfSA9IEt3YXJnLnBhcnNlQXJncyh7IH0pKTtcbiAgICAgKiBJbmNsdWRlIGRlZmF1bHQgdmFsdWVzIGluIHRoZSBmaXJzdCBvYmplY3QsIG5vdCB0aGUgc2Vjb25kLlxuICAgICAqXG4gICAgICogSWYgeW91IHdhbnQgdG8gY2FwdHVyZSByZXN0IHBhcmFtZXRlcnMsIHVzZSB0aGlzOlxuICAgICAqICh7ICRyZXN0JCB9ID0gS3dhcmcucGFyc2VBcmdzKHsgLCAuLi5yZXN0IH0pKTtcbiAgICAgKlxuICAgICAqIElmIHlvdSB3YW50IGFsbG93VW5rbm93bktleXdvcmQgdG8gYmUgdHJ1ZSwgdXNlIHRoaXM6XG4gICAgICogKHsgJCRrdyQkIH0gPSBLd2FyZy5wYXJzZUFyZ3MoeyB9LCB0cnVlKSk7XG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQXJncyhhcmdzLCBhbGxvd1Vua25vd25LZXl3b3JkID0gZmFsc2UpIHtcbiAgICAgICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGlzIGNvdWxkIHRha2UgdGhlIGFyZ3VtZW50cyBvYmplY3QsIGJ1dCBzYWRseSBhcmd1bWVudHMgc3RvcmVzIG9ubHkgYW4gYXJyYXkgb2YgdmFsdWVzLFxuICAgICAgICAvLyBubyBrZXlzLiBJZiBKUyB3ZXJlIHNhbmUsIGl0IHdvdWxkIGJlIGEgTWFwLCBub3QgYW4gYXJyYXkuIFR3byBzdGVwcyBmb3J3YXJkLCBvbmUgc3RlcCBiYWNrLlxuICAgICAgICAvLyBQYXJzaW5nIHRoZSBzdHJpbmcgZGVmaW5pdGlvbiBmb3IgdGhlIGZ1bmN0aW9uIGlzIG5vdCBteSBjdXAgb2YgdGVhLCBzbyBqdXN0IG5vLlxuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgY29uc3QgbmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmdzKTtcbiAgICAgICAgLy8gR2V0IGRhdGEgYnkgYXJndW1lbnQgb3JkZXJcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgIGlmIChhcmdzW2FyZ10gaW5zdGFuY2VvZiBLd2FyZykge1xuICAgICAgICAgICAgICAgIG9ialthcmddID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW2FyZ10gPSBhcmdzW2FyZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga3d2YXIgPSB7fTtcbiAgICAgICAgb2JqWyckJGt3JCQnXSA9IGt3dmFyO1xuICAgICAgICAvLyBDaGVjayBmb3IgcmVzdCBwYXJhbWV0ZXJzLlxuICAgICAgICAvLyBJIHdhcyBnb2luZyB0byBoYXZlIHRoaXMgb24vb2ZmIGNvbmZpZ3VyYWJsZSwgYnV0IGl0IHNob3VsZG4ndCBodXJ0IHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgb2JqWyckcmVzdCQnXSA9IGFycjtcbiAgICAgICAgLy8gUmVzdCBwYXJhbWV0ZXJzIGFyZSBzdG9yZWQgYXMgYXJyYXkga2V5cywgeyAnMCc6IGEsICcxJzogYiwgJ25vblJlc3QnOiAnc29tZXRoaW5nIGVsc2UnfVxuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmdzKS5maWx0ZXIoZiA9PiBJc0ludGVnZXJfMS5pc1Bvc2l0aXZlSW50ZWdlclN0cmluZyhmKSkpIHtcbiAgICAgICAgICAgIGlmICghKGFyZ3NbYXJnXSBpbnN0YW5jZW9mIEt3YXJnKSkge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGFyZ3NbYXJnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5d29yZHNVc2VkID0ge307XG4gICAgICAgIC8vIEdldCBkYXRhIGJ5IGtleXdvcmQgbmFtZVxuICAgICAgICAvLyBIYXZlIHRvIGl0ZXJhdGUgdGhlIGxpc3QgdHdpY2UsIHRvIGF2b2lkIHdpcGluZyBvdXQgZGF0YSBpZiB0aGUgb3JkZXIgaXMgc3dhcHBlZFxuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBuYW1lcykge1xuICAgICAgICAgICAgaWYgKGFyZ3NbYXJnXSBpbnN0YW5jZW9mIEt3YXJnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wID0gYXJnc1thcmddO1xuICAgICAgICAgICAgICAgIGlmICh0bXAubmFtZSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW3RtcC5uYW1lXSA9IHRtcC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd1Vua25vd25LZXl3b3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrd3Zhclt0bXAubmFtZV0gPSB0bXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCBhbiB1bmV4cGVjdGVkIGtleXdvcmQgYXJndW1lbnQgJyR7dG1wLm5hbWV9J2ApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0bXAubmFtZSBpbiBrZXl3b3Jkc1VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgbXVsdGlwbGUgdmFsdWVzIGZvciBrZXl3b3JkIGFyZ3VtZW50ICsgJyR7dG1wLm5hbWV9J2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXl3b3Jkc1VzZWRbdG1wLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvLyBUdXJuIGFuIG9iamVjdCBpbnRvIGFuIGFycmF5IG9mIGtleXdvcmQgYXJndW1lbnRzLlxuICAgIC8vIE5lZWRzIHRvIHJldHVybiBhbnlbXSBiZWNhdXNlIGl0J3MgZ29pbmcgdG8gYmUgc2hvdmVkIGludG8gYXJiaXRyYXJ5IGFyZ3VtZW50IGxpc3RzXG4gICAgc3RhdGljIHVucGFjayhhcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBhcmcgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJncykpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChrdyhhcmcsIGFyZ3NbYXJnXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBpc01hdGNoKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBrZXk7XG4gICAgfVxufVxuZXhwb3J0cy5Ld2FyZyA9IEt3YXJnO1xuZnVuY3Rpb24ga3coYSwgYikge1xuICAgIGlmICghYSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG51bGwgZXhjZXB0aW9uJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gT3ZlcmxvYWQgMVxuICAgICAgICByZXR1cm4gbmV3IEt3YXJnKGEsIGIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIC8vIE92ZXJsb2FkIDJcbiAgICAgICAgcmV0dXJuIG5ldyBLd2FyZyhhWzBdLCBhWzFdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE92ZXJsb2FkIDNcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYW4gb2JqZWN0IHdpdGggb25seSBvbmUga2V5L3ZhbHVlIHBhaXIuXG4gICAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSk7XG4gICAgICAgIGlmICghcHJvcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IG51bGwgZXhjZXB0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXAgb2JqZWN0OiBtdWx0aXBsZSBrZXlzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBLd2FyZyhwcm9wc1swXSwgYVtwcm9wc1swXV0pO1xuICAgIH1cbn1cbmV4cG9ydHMua3cgPSBrdztcbmZ1bmN0aW9uIGt3YXJnc1RvT2JqZWN0KGFycikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGFyZyBvZiBhcnIpIHtcbiAgICAgICAgb3B0aW9uc1thcmcubmFtZV0gPSBvcHRpb25zW2FyZy52YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5rd2FyZ3NUb09iamVjdCA9IGt3YXJnc1RvT2JqZWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBpc05vbmUodGVzdCkge1xuICAgIHJldHVybiAodGVzdCA9PSBudWxsIHx8IHRlc3QgPT09IHVuZGVmaW5lZCk7XG59XG5leHBvcnRzLmlzTm9uZSA9IGlzTm9uZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBEZWFkIHNpbXBsZSBhc3NlcnRpb24gdGhhdCdsbCB3b3JrIGFueXdoZXJlLiBUaGlzIGlzIE5PVCB0aGUgZGlmZmljdWx0IHBhcnQgb2YgdW5pdCB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBhc3NlcnQodGVzdCwgbWVzc2FnZSkge1xuICAgIGlmICghdGVzdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkJyk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGNsb25lRGVlcChvYmosIGhhc2ggPSBuZXcgV2Vha01hcCgpKSB7XG4gICAgaWYgKE9iamVjdChvYmopICE9PSBvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iajsgLy8gcHJpbWl0aXZlIHR5cGVzXG4gICAgfVxuICAgIGlmIChoYXNoLmhhcyhvYmopKSB7XG4gICAgICAgIHJldHVybiBoYXNoLmdldChvYmopOyAvLyByZWZlcmVuY2UgdG8gb2JqZWN0IHByZXZpb3VzbHkgc2VlblxuICAgIH1cbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmVzdWx0ID0gbmV3IFNldCgpO1xuICAgICAgICBBcnJheS5mcm9tKG9iaiwgdmFsID0+IHJlc3VsdC5hZGQoY2xvbmVEZWVwKHZhbCwgaGFzaCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgICAgICAgQXJyYXkuZnJvbShvYmosIChba2V5LCB2YWxdKSA9PiByZXN1bHQuYWRkKGNsb25lRGVlcChrZXksIGhhc2gpLCBjbG9uZURlZXAodmFsLCBoYXNoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkuZnJvbShvYmopO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJlc3VsdCA9IG5ldyBEYXRlKG9iaik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKG9iai5zb3VyY2UsIG9iai5mbGFncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhd2Z1bCBjb2RlLCBidXQgaXQncyB0aGUgb25seSB3YXkgdG8gY2xvbmUgYSBzdGFuZGFsb25lIGZ1bmN0aW9uICh2cyBhIG1ldGhvZCB3aGljaCBoYXMgYSBkZXNjcmlwdG9yKS5cbiAgICAgICAgLy8gSW4gZ2VuZXJhbCwgeW91IHByb2JhYmx5IGRvbid0IHdhbnQgdG8gdXNlIGNsb25lRGVlcCBvbiBmdW5jdGlvbnMuIFlvdSdsbCBzZWUgaXQncyBOT1QgdXNlZCBvbiBpbnRlcm5hbCBtZXRob2RzLlxuICAgICAgICByZXN1bHQgPSBuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgb2JqLnRvU3RyaW5nKCkpKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSB7XG4gICAgICAgIHJlc3VsdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgaGFzaC5zZXQob2JqLCByZXN1bHQpOyAvLyBLZWVwIHRyYWNrIG9mIG9iamVjdHMgcHJldmlvdXNseSBjbG9uZWRcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicgJiYgIShrZXkgaW4gcmVzdWx0KSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1ldGhvZHMgdGhhdCBhcmVuJ3QgaW4gdGhlIHByb3RvdHlwZS5cbiAgICAgICAgICAgIC8vIFRoaXMgZG9lc24ndCByZWN1cnNpdmVseSBmb2xsb3cgYmVjYXVzZSB0aGVyZSdzIG5vdGhpbmcgcmVjdXJzaXZlIHRvIGRvLlxuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgICAgIGhhc2guc2V0KG9ialtrZXldLCByZXN1bHRba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gTk9URSB0aGF0IGNsb25lRGVlcCBpcyBOT1QgY2FsbGVkIHJlY3Vyc2l2ZWx5IGhlcmUuIEl0IGFsbCBlbmRzIGF0IHRoZSBtZXRob2QuXG4gICAgICAgICAgICAgICAgLy8gSWYgZXh0cmEga2V5cyBhcmUgdGhyb3duIG9udG8gYSBmdW5jdGlvbiwgdGhleSBwcm9iYWJseSB3aWxsIG5vdCBiZSBjbG9uZWQuXG4gICAgICAgICAgICAgICAgLy8gSW4gbXkgZXhwZXJpZW5jZSwgZXh0cmEga2V5cyBvbiBmdW5jdGlvbnMgZGlkbid0IHdvcmsgcmlnaHQsIHNvIG5vIGJpZyBsb3NzLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlc2NyaXB0b3IgJiYgKGRlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3Iuc2V0KSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGN1c3RvbSBnZXR0ZXJzL3NldHRlcnMuIFRoZXNlIGFyZSBsb2NhbCBhbmQgaG9wZWZ1bGx5IHdvcmsganVzdCBsaWtlIG1ldGhvZHMuXG4gICAgICAgICAgICAvLyBJbiBtYW55IGNhc2VzLCB0aGlzIGlzIHJlZHVuZGFudCB3aXRoIE9iamVjdC5jcmVhdGUoKSwgYnV0IGlzIG5lY2Vzc2FyeSB0byBhbGxvdyBvYmplY3RzIHdpdGggbWFudWFsbHktYWRkZWQgY3VzdG9tIGdldHRlcnMuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgLy8gTk9URSB0aGF0IGNsb25lRGVlcCBpcyBOT1QgY2FsbGVkIHJlY3Vyc2l2ZWx5IGhlcmUuIEl0IGFsbCBlbmRzIGF0IHRoZSBnZXR0ZXIvc2V0dGVyLlxuICAgICAgICAgICAgLy8gQUxTTyBoYXNoIG5vdCB1cGRhdGVkOyB0aGlzIGlzIG5vdCBwb3NzaWJsZSwgYmVjYXVzZSBpdCB3aWxsIG1hcCB0aGUgdmFsdWUgaXQgZ2V0cywgbm90IHRoZSBnZXR0ZXIuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lRGVlcChvYmpba2V5XSwgaGFzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBJIGRvbid0IGtub3cgZm9yIHN1cmUgaWYgdGhpcyB3aWxsIHdvcmsgaW4gYWxsIGNhc2VzLlxuLy8gSXQgZ2V0cyBkZWVwZXIgaW50byB0aGUgZ3V0cyBvZiBKUyBvYmplY3QgdGhhbiBJIGhhdmUgZXhwZXJpZW5jZSB3aXRoLlxuZnVuY3Rpb24gY2xvbmVPYmplY3Qob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuY2xvbmVPYmplY3QgPSBjbG9uZU9iamVjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTm9uZVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9UeXBlcy9Ob25lVHlwZVwiKTtcbi8qKlxuICogUmVjZW50IFR5cGVzY3JpcHQgaGFzIGFkZGVkIGEgbnVsbCBjb2FsZXNjaW5nIG9wZXJhdG9yICg/LiwgYWthIHRoZSBFbHZpcyBvcGVyYXRvcikgYnV0IE5QTSBpc3N1ZXNcbiAqIHByZXZlbnQgbWUgZnJvbSB1cGdyYWRpbmcuICBCdXQgdGhpcyByZXR1cm5zIHVuZGVmaW5lZCBpZiB5b3UgYWNjZXNzIGFueXRoaW5nIHRoYXQgZG9lc24ndCBleGlzdC5cbiAqXG4gKiBOYXR1cmFsbHkgdGhpcyBicmVha3MgVlNDb2RlIGludGVsbGlzZW5zZSwgYmVjYXVzZSBpdCByZXR1cm5zIGFueS4gT25seSBNUyBjYW4gZG8ga2VlcCB0aGUgcmlnaHQgdHlwZS5cbiAqXG4gKiBJZiB5b3UgZG8gcmV0dXJuIGEgcGFydGlhbCB2ZXJzaW9uIG9mIHRoZSB0eXBlLCBUUyB0aHJvd3MgYW4gZXJyb3IgYmVjYXVzZSBpdCBjb3VsZCBiZSBtaXNzaW5nICh1bW0uLi4gdGhhdCdzIHdoYXQgUGFydGlhbCBtZWFucy4uLikuXG4gKlxuICogQSB0cnVlIGVsdmlzIG9wZXJhdG9yIHdvdWxkIGFsc28gd29yayBvbiBzdHJpbmdzL251bWJlcnMvZXRjLiBUaGlzIGNhbm5vdCBkbyB0aGF0LCBiZWNhdXNlIEpTIGNhbid0IHRlbGwgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBhXG4gKiBudWxsIHN0cmluZyBhbmQgYSBudWxsIG9iamVjdC4gTnVsbCBpcyBudWxsLlxuICovXG5mdW5jdGlvbiBlXyhpdGVtKSB7XG4gICAgaWYgKE5vbmVUeXBlXzEuaXNOb25lKGl0ZW0pKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5leHBvcnRzLmVfID0gZV87XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFycmF5VXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vQ29sbGVjdGlvbnMvQXJyYXlVdGlsaXRpZXNcIik7XG4vKipcbiAqIEEgcHNldWRvLXJhbmRvbSBwcmVmaXggcGx1cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgc2luY2UgdGhlIHVuaXggZXBvY2guIFRoZSByYW5kb20gcGFydCBzaG91bGQgYmUgcmFuZG9tIGVub3VnaCB0byBjb3ZlclxuICogbXVsdGlwbGUgaWRzIGNyZWF0ZWQgaW4gYSBtaWxsaXNlY29uZC5cbiAqL1xuZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7XG4gICAgY29uc3QgY2hhcnMgPSAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVotXyc7XG4gICAgbGV0IHJlc3VsdCA9ICd1JyArIFN0cmluZyhuZXcgRGF0ZSgpLmdldFRpbWUoKSkgKyAnLSc7XG4gICAgZm9yIChjb25zdCBfIG9mIEFycmF5VXRpbGl0aWVzXzEucmFuZ2UoOCkpIHtcbiAgICAgICAgcmVzdWx0ICs9IGNoYXJzLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0VW5pcXVlSWQgPSBnZXRVbmlxdWVJZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUZWxsIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIGEgcG9zaXRpdmUgaW50ZWdlci5cbiAqIFVzZSBmb3IgZGV0ZWN0aW5nIGFycmF5IGtleXMuXG4gKi9cbmZ1bmN0aW9uIGlzUG9zaXRpdmVJbnRlZ2VyU3RyaW5nKHN0cikge1xuICAgIGlmICghc3RyIHx8IHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHN0ciA9PT0gJzAnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gL15bMS05XVxcZCokLy50ZXN0KHN0cik7XG59XG5leHBvcnRzLmlzUG9zaXRpdmVJbnRlZ2VyU3RyaW5nID0gaXNQb3NpdGl2ZUludGVnZXJTdHJpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogSSBkb24ndCBrbm93IGhvdyBhY2N1cmF0ZSB0aGlzIGlzIGJ1dCBpdCBzZWVtcyBwcmV0dHkgZ29vZFxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0KG9iaikgIT09IG9iajtcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ2xvbmVPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0Nsb25lT2JqZWN0XCIpO1xuY29uc3QgTm9uZVR5cGVfMSA9IHJlcXVpcmUoXCIuLi9UeXBlcy9Ob25lVHlwZVwiKTtcbi8qKlxuICogT2JqZWN0LmFzc2lnbigpIGNhbiBiZSB1c2VkIGZvciBzaW1wbGUgY29waWVzIG9mIHByb3BlcnRpZXMsIGJ1dCBpdCBtaXNzZXMgZ2V0dGVycyxcbiAqIHNldHRlcnMsIGFuZCBpbmhlcml0ZWQgcHJvcGVydGllcy4gSXQgb25seSBnZXRzIHRoZSBsb2NhbCB2YWx1ZXMuXG4gKlxuICogVGhpcyBzaG91bGQgaG9wZWZ1bGx5IHJlc29sdmUgdGhhdCwgYnV0IEkgZG9uJ3Qga25vdyBmb3Igc3VyZS4gVGhpcyBpcyB2ZXJ5IHNrZXRjaHkuXG4gKiBUaGUgcmVzdWx0cyBhcmUgY29tcGxldGVseSBmbGF0LCBiZWNhdXNlIHlvdSBjYW4ndCBoYXZlIG11bHRpcGxlIGluaGVyaXRhbmNlIGhpZXJhcmNoeVxuICogaW4gYSBsYW5ndWFnZSB3aXRob3V0IG11bHRpcGxlIGluaGVyaXRhbmNlLiBCZWNhdXNlIHRoaXMgZmxhdHRlbnMgb2JqZWN0cywgaXQgaXMgZ3VhcmFudGVlZFxuICogdG8gYnJlYWsgYW55dGhpbmcgdGhhdCBtYWtlcyBzdXBlciBjYWxscy5cbiAqXG4gKiBJZiByZXR1cm5DbG9uZSBpcyB0cnVlLCBhIGNsb25lIG9mIHRoZSB0YXJnZXQgb2JqZWN0IHdpbGwgYmUgbW9kaWZpZWQgYW5kIHJldHVybmVkLCBsZWF2aW5nXG4gKiB0aGUgb3JpZ2luYWwgdW50b3VjaGVkLlxuICovXG5mdW5jdGlvbiBvYmplY3RGdWxsQXNzaWduKHRhcmdldCwgc291cmNlLCByZXR1cm5DbG9uZSA9IGZhbHNlKSB7XG4gICAgaWYgKE5vbmVUeXBlXzEuaXNOb25lKHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgfVxuICAgIGlmICghc291cmNlIHx8IHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnIHx8IHR5cGVvZiB0YXJnZXQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGlmIChyZXR1cm5DbG9uZSkge1xuICAgICAgICB0YXJnZXQgPSBDbG9uZU9iamVjdF8xLmNsb25lT2JqZWN0KHRhcmdldCk7XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gQXJyYXkuZnJvbShuZXcgU2V0KGZpbmRUaGVQcm9wZXJ0eU5hbWVzKHNvdXJjZSkpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBuYW1lcykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gZmluZFRoZVByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gICAgZnVuY3Rpb24gZmluZFRoZVByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICByZXN1bHQucHVzaCguLi5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmZpbHRlcihmID0+IGYgIT09ICdjb25zdHJ1Y3RvcicpKTtcbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvICYmIHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCguLi5maW5kVGhlUHJvcGVydHlOYW1lcyhwcm90bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRUaGVQcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKTtcbiAgICAgICAgaWYgKHByb3RvICYmIHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZFRoZVByb3BlcnR5RGVzY3JpcHRvcihwcm90bywga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMub2JqZWN0RnVsbEFzc2lnbiA9IG9iamVjdEZ1bGxBc3NpZ247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jb25zdCBUZXN0YmVuY2hWaWV3XzEgPSByZXF1aXJlKFwiLi4vdGVzdHMvVGVzdGJlbmNoVmlld1wiKTtcbmNvbnN0IFRlc3QwMDBfMSA9IHJlcXVpcmUoXCIuL1Rlc3QwMDBcIik7XG5jb25zdCBUZXN0MDAxXzEgPSByZXF1aXJlKFwiLi9UZXN0MDAxXCIpO1xuY29uc3QgVGVzdDAwMl8xID0gcmVxdWlyZShcIi4vVGVzdDAwMlwiKTtcbmNvbnN0IFRlc3QwMDNfMSA9IHJlcXVpcmUoXCIuL1Rlc3QwMDNcIik7XG5jb25zdCBUZXN0MDA0XzEgPSByZXF1aXJlKFwiLi9UZXN0MDA0XCIpO1xuY29uc3QgVGVzdDAwNV8xID0gcmVxdWlyZShcIi4vVGVzdDAwNVwiKTtcbmNvbnN0IFRlc3QwMDZfMSA9IHJlcXVpcmUoXCIuL1Rlc3QwMDZcIik7XG5jb25zdCBUZXN0MDA3XzEgPSByZXF1aXJlKFwiLi9UZXN0MDA3XCIpO1xuY29uc3QgVGVzdDAwOF8xID0gcmVxdWlyZShcIi4vVGVzdDAwOFwiKTtcbmNvbnN0IFRlc3QwMDlfMSA9IHJlcXVpcmUoXCIuL1Rlc3QwMDlcIik7XG5jb25zdCBUZXN0MDEwXzEgPSByZXF1aXJlKFwiLi9UZXN0MDEwXCIpO1xuY29uc3QgVGVzdDAxMV8xID0gcmVxdWlyZShcIi4vVGVzdDAxMVwiKTtcbmNvbnN0IFRlc3QwMTJfMSA9IHJlcXVpcmUoXCIuL1Rlc3QwMTJcIik7XG5jb25zdCBUZXN0MDEzXzEgPSByZXF1aXJlKFwiLi9UZXN0MDEzXCIpO1xuY29uc3QgVGVzdDAxNF8xID0gcmVxdWlyZShcIi4vVGVzdDAxNFwiKTtcbi8qKlxuICogVGhpcyBpcyBhIHZlcnkgYmFzaWMgcGFnZSB0aGF0IEkgdXNlIHRvIHNlZSBpZiBldmVyeXRoaW5nIGlzIHdvcmtpbmcuIEl0J3Mgd2hhdCBwYXNzZXMgZm9yIHVuaXQgdGVzdHMgd2l0aG91dFxuICogYW4gaW5zdGFsbGFibGUgdW5pdCB0ZXN0aW5nIGZyYW1ld29yay5cbiAqL1xuZnVuY3Rpb24gbWFpbigpIHtcbiAgICBBcGlfMS5QYWdlUm91dGVyLmNvbmZpZ3VyZShbXG4gICAgICAgIHsgcm91dGU6ICd0ZXN0LzppZD0wJywgcGF5bG9hZDogVGVzdDAwMF8xLlRlc3QwMDAgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTEnLCBwYXlsb2FkOiBUZXN0MDAxXzEuVGVzdDAwMSB9LFxuICAgICAgICB7IHJvdXRlOiAndGVzdC86aWQ9MicsIHBheWxvYWQ6IFRlc3QwMDJfMS5UZXN0MDAyIH0sXG4gICAgICAgIHsgcm91dGU6ICd0ZXN0LzppZD0zJywgcGF5bG9hZDogVGVzdDAwM18xLlRlc3QwMDMgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTQnLCBwYXlsb2FkOiBUZXN0MDA0XzEuVGVzdDAwNCB9LFxuICAgICAgICB7IHJvdXRlOiAndGVzdC86aWQ9NScsIHBheWxvYWQ6IFRlc3QwMDVfMS5UZXN0MDA1IH0sXG4gICAgICAgIHsgcm91dGU6ICd0ZXN0LzppZD02JywgcGF5bG9hZDogVGVzdDAwNl8xLlRlc3QwMDYgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTcnLCBwYXlsb2FkOiBUZXN0MDA3XzEuVGVzdDAwNyB9LFxuICAgICAgICB7IHJvdXRlOiAndGVzdC86aWQ9OCcsIHBheWxvYWQ6IFRlc3QwMDhfMS5UZXN0MDA4IH0sXG4gICAgICAgIHsgcm91dGU6ICd0ZXN0LzppZD05JywgcGF5bG9hZDogVGVzdDAwOV8xLlRlc3QwMDkgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTEwJywgcGF5bG9hZDogVGVzdDAxMF8xLlRlc3QwMTAgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTExJywgcGF5bG9hZDogVGVzdDAxMV8xLlRlc3QwMTEgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTEyJywgcGF5bG9hZDogVGVzdDAxMl8xLlRlc3QwMTIgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTEzJywgcGF5bG9hZDogVGVzdDAxM18xLlRlc3QwMTMgfSxcbiAgICAgICAgeyByb3V0ZTogJ3Rlc3QvOmlkPTE0JywgcGF5bG9hZDogVGVzdDAxNF8xLlRlc3QwMTQgfSxcbiAgICBdLCBUZXN0YmVuY2hWaWV3XzEuVGVzdGJlbmNoVmlldywgdHJ1ZSwgJzxkaXY+VGhlcmUgaXMgbm8gcGFnZSBoZXJlLjwvZGl2PicsICd0ZXN0LzAnKTtcbiAgICAvLyBUT0RPOiBIb3cgY2FuIEkgdW5pdCB0ZXN0IHRoZSByb3V0ZXIgaXRzZWxmPyBDYW4ndCB1c2UgdGhpcyB0ZXN0IGhhcm5lc3MsIG9idmlvdXNseS5cbn1cbm1haW4oKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ1Rlc3QgdGhlIFRlc3RDYXNlIGJhc2UgY2xhc3NlcycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGA8cD5UaGlzIHRlc3QgY2FzZSBiYXNlIGNsYXNzIHJ1bnMgdGVzdHMgYW5kIG91dHB1dHMgc3R1ZmYgdG8gdGhlIGNvbnNvbGUsIHdoaWNoIGNhbiBiZVxuICAgICAgICAgICAgaW5jbHVkZWQgaW4gdGhlIGFjdHVhbCBwYWdlIChzbyBpdCdzIG5vdCBuZWNlc3NhcnkgdG8gb3BlbiB0aGUgZGV2IHRvb2xzIGNvbnNvbGUsIHRob3VnaFxuICAgICAgICAgICAgdGhhdCdzIHN0aWxsIHByZXR0eSB1c2VmdWwuKTwvcD5cbiAgICAgICAgICAgIDxwPklmIHlvdSBkb24ndCBzZWUgXCJUZXN0IHN1Y2Nlc3NmdWwsXCIgdGhlbiBpdCBmYWlsZWQsIHdpdGggYW4gZXJyb3IgaW4gdGhlIGxvZy4gSGFyZCB0b1xuICAgICAgICAgICAgc2hvdyB0aGUgbG9nIGluIHRoZSBwYWdlIGlmIHRoZSBwYWdlIGlzIGJyb2tlbiwgc28gaGF2ZSB0byBjaGVjayB0aGUgbG9nIGFmdGVyIGFsbC48L3A+YFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDAwIGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGxvZ0VsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uc29sZUxvZycpO1xuICAgICAgICAgICAgaWYgKGxvZ0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW5kZXJpbmcgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29uc29sZS5sb2coXCJIZWxsbyB3b3JsZC5cIik7XG4gICAgICAgICAgICAvLyBDb21wb25lbnQgcmVuZGVyaW5nIGlzIGFzeW5jaHJvbm91cyAob24gdGhlIG1pY3JvdGFzayBxdWV1ZSksIHNvIHRoZSBhc3NlcnQgaGFzIHRvIGJlIGxhdGVyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnNvbGVMb2cnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvZ0VsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbmRlcmluZyBmYWlsZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChsb2dFbGVtZW50LmlubmVySFRNTC5pbmNsdWRlcyhcIkhlbGxvIHdvcmxkLlwiKSwgXCJMb2cgc2hvdWxkIHVwZGF0ZSB0aGUgcGFnZS5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRVJST1I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDAwID0gVGVzdDAwMDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ0Fzc29ydGVkIEhUTUwgaGVscGVycycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGA8cD5DcmVhdGUgdmFyaW91cyBlbGVtZW50cyB1c2luZyBjcmVhdGVFbGVtZW50IGFuZCBpdHMgcmVsYXRlZCBmdW5jdGlvbnMgZGl2KCksIHNwYW4oKSwgZXRjLlxuICAgICAgICAgICAgICAgIFlvdSBjYW4gZWFzaWx5IGNyZWF0ZSBhbnkgZWxlbWVudCB1c2luZyBjcmVhdGVFbGVtZW50KCkgYW5kIHRoZW4gYWRkIGl0IHVzaW5nIHRoZSB2YW5pbGxhIEpTIGFwcGVuZENoaWxkKCkuPC9wPlxuXG4gICAgICAgICAgICAgICAgPHA+QSBmZXcgb3RoZXIgYXNzb3J0ZWQgSFRNTCBoZWxwZXJzIGFyZSBoZXJlLiBTb21lIG9mIHRoZXNlIGFyZSByZWR1bmRhbnQgYmVjYXVzZSBwaWVjZXMgb2YgdGhlIHRlc3QgYmVuY2hcbiAgICAgICAgICAgIGRlcGVuZCBvbiB0aGVtLiBCdXQgd2hhdCB0aGUgaGV5LjwvcD5gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRlc3QwMDEgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdfMS5UZXN0Q2FzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihuZXcgVGVzdFZpZXdNb2RlbCgpKTtcbiAgICB9XG4gICAgdGVzdENhc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgdXNpbmcgdGhlIGNyZWF0ZUVsZW1lbnQgaGVscGVyXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBpZDogJ2RpdjEnLCBpbm5lckhUTUw6ICdESVYnIH0pKTtcbiAgICAgICAgICAgIHRlc3QoJ2RpdjEnLCAnRElWJywgJ2NyZWF0ZUVsZW1lbnQgc2hvdWxkIGNyZWF0ZSBkaXYuJyk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgaWQ6ICdzcGFuMScsIGlubmVySFRNTDogJ1NQQU4nIH0pKTtcbiAgICAgICAgICAgIHRlc3QoJ3NwYW4xJywgJ1NQQU4nLCAnY3JlYXRlRWxlbWVudCBzaG91bGQgY3JlYXRlIHNwYW4uJyk7XG4gICAgICAgICAgICAvLyBBZGQgZWxlbWVudHMgdXNpbmcgZnJlcXVlbnRseSB1c2VkIGVsZW1lbnQgY3JlYXRpb24gaGVscGVycy4gRElWIGFuZCBTUEFOIGNhbiB0YWtlIGlubmVyIGh0bWwgb3IgYW4gZWxlbWVudFxuICAgICAgICAgICAgY29uc3QgbmVzdGVkUGFyYWdyYXBoID0gQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MUGFyYWdyYXBoRWxlbWVudCwgeyBpZDogXCJkaXZDaGlsZFwiLCBpbm5lckhUTUw6IFwiTmVzdGVkIHBhcmFncmFwaFwiIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5kaXYobmVzdGVkUGFyYWdyYXBoLCB7IGlkOiAnZGl2UGFyZW50JyB9KSk7XG4gICAgICAgICAgICB0ZXN0KCdkaXZQYXJlbnQnLCAnRElWJywgJ2RpdigpIGhlbHBlciBzaG91bGQgY3JlYXRlIGEgZGl2Jyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoISFuZXN0ZWRQYXJhZ3JhcGgsICdEaXYgc2hvdWxkIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHdpdGggYXBwZW5kQ2hpbGQuJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQobmVzdGVkUGFyYWdyYXBoLnBhcmVudEVsZW1lbnQgPT09IHRoaXMudGVzdEFyZWEucXVlcnlTZWxlY3RvcignI2RpdlBhcmVudCcpLCAnUGFyZW50IG9mIGNoaWxkIHNob3VsZCBiZSB0aGUgdGFyZ2V0IG9mIGFwcGVuZENoaWxkJyk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnNwYW4oJ1NwYW4gaGVscGVyJywgeyBpZDogJ3NwYW5IZWxwZXInIH0pKTtcbiAgICAgICAgICAgIHRlc3QoJ3NwYW5IZWxwZXInLCAnU1BBTicsICdzcGFuKCkgaGVscGVyIHNob3VsZCBjcmVhdGUgYSBzcGFuJyk7XG4gICAgICAgICAgICAvLyBPdGhlciBoZWxwZXJzIGp1c3QgdGFrZSBpbm5lciBodG1sXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaCgnUGFyYWdyYXBoIGhlbHBlcicsIHsgaWQ6ICdwYXJhZ3JhcGhIZWxwZXInIH0pKTtcbiAgICAgICAgICAgIHRlc3QoJ3BhcmFncmFwaEhlbHBlcicsICdQJywgJ3BhcmFncmFwaCgpIGhlbHBlciBzaG91bGQgY3JlYXRlIGEgcCcpO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5hbmNob3IoJ2dpdGh1YicsICdodHRwczovL2dpdGh1Yi5jb20vJywgeyBpZDogJ2FuY2hvckhlbHBlcicgfSkpO1xuICAgICAgICAgICAgdGVzdCgnYW5jaG9ySGVscGVyJywgJ0EnLCAnYW5jaG9yKCkgaGVscGVyIHNob3VsZCBjcmVhdGUgYW4gYScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKHRoaXMudGVzdEFyZWEucXVlcnlTZWxlY3RvcignI2FuY2hvckhlbHBlcicpKS5ocmVmID09PSAnaHR0cHM6Ly9naXRodWIuY29tLycsICdBbmNob3IgaHJlZiBzaG91bGQgdGFrZSB0aGUgc2Vjb25kIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmJ1dHRvbignQ2xpY2sgbWUgYW5kIG5vdGhpbmcgd2lsbCBoYXBwZW4nLCB7IGlkOiAnYnV0dG9uSGVscGVyJywgc3R5bGU6ICdkaXNwbGF5OiBibG9jazsnIH0sIHsgcmVhZG9ubHk6IHRydWUgfSkpO1xuICAgICAgICAgICAgdGVzdCgnYnV0dG9uSGVscGVyJywgJ0JVVFRPTicsICdidXR0b24oKSBoZWxwZXIgc2hvdWxkIGNyZWF0ZSBhIGJ1dHRvbicpO1xuICAgICAgICAgICAgY29uc3QgYnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbkhlbHBlcicpO1xuICAgICAgICAgICAgaWYgKCFidG4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZXJlIGRpZCB0aGUgYnV0dG9uIGdvPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGJ0bi5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snLCAnU3R5bGUgcHJvcGVydHkgc2hvdWxkIHNldCBzdHlsZScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGJ0bi5nZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgPT09ICd0cnVlJywgJ0F0dHJpYnV0ZXMgaW5wdXQgc2hvdWxkIHNldCBhdHRyaWJ1dGVzJyk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgSFRNTCBieSBwcm92aWRpbmcgYSByYXcgSFRNTCBzdHJpbmdcbiAgICAgICAgICAgIGNvbnN0IGZvbyA9IDEyMzQ1O1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVIdG1sKGA8cCBpZD1cInJhd3dyXCI+RWxlbWVudCAke2Zvb30gY3JlYXRlZCB0aHJvdWdoIHJhdyBIVE1MLjwvcD5gKSk7XG4gICAgICAgICAgICB0ZXN0KCdyYXd3cicsICdQJywgJ1JhdyBlbGVtZW50IHNob3VsZCBjcmVhdGUgdGhlIGh0bWwgZWxlbWVudCBwcm92aWRlZCcpO1xuICAgICAgICAgICAgLy8gRXNjYXBlIHNvbWUgSFRNTFxuICAgICAgICAgICAgdGhpcy52aWV3TW9kZWwuc3RyID0gQXBpXzEuZXNjYXBlSHRtbCgnPGJyPicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHRoaXMudmlld01vZGVsLnN0ciA9PT0gJyZsdDticiZndDsnLCAnZXNjYXBlSHRtbCgpIHNob3VsZCBlc2NhcGUgdGhlIEhUTUwnKTtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgY29udGVudCBhbmQgcHV0IGl0IGVsc2V3aGVyZVxuICAgICAgICAgICAgY29uc3QgZnJvbUVsZSA9IEFwaV8xLmNyZWF0ZUh0bWwoJzxkaXY+PHAgaWQ9XCJlMVwiPkkgYW0gc29tZSBjb250ZW50PC9wPjwvZGl2PicpO1xuICAgICAgICAgICAgY29uc3QgdG9FbGUgPSBBcGlfMS5kaXYoeyBpZDogJ2UyJyB9KTtcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoZnJvbUVsZSk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKHRvRWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IEFwaV8xLmV4dHJhY3ROb2RlQ29udGVudChmcm9tRWxlKTtcbiAgICAgICAgICAgIHRvRWxlLmFwcGVuZENoaWxkKGV4dHJhY3RlZCk7XG4gICAgICAgICAgICBjb25zdCB0Z3QxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2UyJyk7XG4gICAgICAgICAgICBpZiAoIXRndDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRndDIgPSB0Z3QxLnF1ZXJ5U2VsZWN0b3IoJyNlMScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGd0MiwgJ2V4dHJhY3ROb2RlQ29udGVudCgpIHNob3VsZCByZW1vdmUgdGhlIGh0bWwgZnJvbSB0aGUgc291cmNlIGxvY2F0aW9uLCBhbmQgYXBwZW5kQ2hpbGQgc2hvdWxkIGFkZCB0aGVtIGludG8gdGhlIG5ldyBsb2NhdGlvbi4nKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyh0Z3QyKS5pbm5lckhUTUwgPT09ICdJIGFtIHNvbWUgY29udGVudCcsICdUaGUgY29udGVudCBtb3ZlZCB0byB0aGUgbmV3IGxvY2F0aW9uIHNob3VsZCBtYXRjaCB0aGUgb3JpZ2luYWwgY29udGVudC4nKTtcbiAgICAgICAgICAgIC8vIERlbGV0ZSBjb250ZW50XG4gICAgICAgICAgICBjb25zdCBkZWxFbGUgPSBBcGlfMS5jcmVhdGVIdG1sKCc8ZGl2PjxwIGlkPVwiZTNcIj5Tb21ldGhpbmcgdGhhdCBzaG91bGQgYmUgZGVsZXRlZDwvcD48L2Rpdj4nKTtcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoZGVsRWxlKTtcbiAgICAgICAgICAgIEFwaV8xLmRlbGV0ZU5vZGVDb250ZW50KGRlbEVsZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlMycpLCBcImRlbGV0ZU5vZGVDb250ZW50KCkgc2hvdWxkIHJlbW92ZSB0aGUgaHRtbCBmcm9tIHRoZSBzb3VyY2UgbG9jYXRpb24uXCIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcmF3IGRvY3VtZW50IGZyYWdtZW50IGFuZCBhZGQgaXRcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gQXBpXzEuY3JlYXRlRnJhZ21lbnQoYDxwIGlkPVwicmF3d3JcIj5GcmFnbWVudCBjcmVhdGVkIHRocm91Z2ggcmF3IEhUTUwuPC9wPmApO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuZV8odGhpcy50ZXN0QXJlYS5xdWVyeVNlbGVjdG9yKCcjcmF3d3InKSkudGFnTmFtZSA9PT0gJ1AnLCAnUmF3IGZyYWdtZW50IHNob3VsZCBjcmVhdGUgdGhlIGh0bWwgZWxlbWVudCBwcm92aWRlZCcpO1xuICAgICAgICAgICAgdGhpcy5sb2coYFRFU1QgJHt0aGlzLnZpZXdNb2RlbC50ZXN0TnVtYmVyfTogVGVzdCBzdWNjZXNzZnVsYCk7XG4gICAgICAgICAgICBmdW5jdGlvbiB0ZXN0KGlkLCB0YWcsIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0QXJlYScpLnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQpKS50YWdOYW1lID09PSB0YWcsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRlc3QwMDEgPSBUZXN0MDAxO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgVGVzdENhc2VWaWV3XzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdNb2RlbF8xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3TW9kZWxcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuY2xhc3MgVGVzdFZpZXdNb2RlbCBleHRlbmRzIFRlc3RDYXNlVmlld01vZGVsXzEuVGVzdENhc2VWaWV3TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnTWlzY2VsbGFuZW91cyBIZWxwZXJzJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSHRtbDogYDxwPlZhcmlvdXMgbWlzYyBoZWxwZXIgZnVuY3Rpb25zLCBzdWNoIGFzIHJhbmdlKCksIHppcCgpLCBjYXJ0ZXNpYW4oKSxcbiAgICAgICAgICAgIGlzTm9uZSgpLCBhbmQgZ2V0VW5pcXVlSWQuIFRoZSBiaWdnZXN0IHRoaW5nIG9uIHRoaXMgcGFnZSBpcyB0aGUgYmVzdCBwb3NzaWJsZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgb2Yga2V5d29yZCBhcmd1bWVudHMsIHdoaWNoIGlzbid0IHF1aXRlIGF3ZnVsLiBLZXl3b3JkIGFyZ3VtZW50cyBhcmUgYSBnb29kIGNvbXByb21pc2UgYmV0d2VlblxuICAgICAgICAgICAgcXVpY2sgZW50cnkgYW5kIGNvbmZpZ3VyYWJpbGl0eSwgd2hpbGUgSlMncyB0d28gb3B0aW9ucyBhcmUgb25seSBvbmUgb3IgdGhlIG90aGVyLjwvcD5gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRlc3QwMDIgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdfMS5UZXN0Q2FzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihuZXcgVGVzdFZpZXdNb2RlbCgpKTtcbiAgICB9XG4gICAgdGVzdENhc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuaXNOb25lKG51bGwpLCBcImlzTm9uZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgbnVsbC5cIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuaXNOb25lKHVuZGVmaW5lZCksIFwiaXNOb25lKCkgc2hvdWxkIHJldHVybiBmb3IgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCghQXBpXzEuaXNOb25lKFwiYWJjXCIpLCBcImlzTm9uZSgpIHNob3VsZCByZXR1cm4gZmFsc2UgZm9yIHRydXRoeSB2YWx1ZXMuXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCFBcGlfMS5pc05vbmUoXCJcIiksIFwiaXNOb25lKCkgc2hvdWxkIHJldHVybiBmYWxzZSBmb3IgYW4gZW1wdHkgc3RyaW5nIChhIGZhbHN5IHZhbHVlKS5cIik7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGUgZWx2aXMgaGVscGVyIGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gVFMgKHlvdSBjYW4gdXNlID8uKS4gRXhjZXB0IEkgY2FuJ3QgZ2V0IHR5cGVzY3JpcHQgdXBkYXRlZC5cbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhudWxsKS5zb21ldGhpbmcgPT09IHVuZGVmaW5lZCwgXCJudWxsIHJlZmVyZW5jZSBzaG91bGQgbm90IHRocm93XCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKHVuZGVmaW5lZCkuc29tZXRoaW5nID09PSB1bmRlZmluZWQsIFwidW5kZWZpbmVkIHJlZmVyZW5jZSBzaG91bGQgbm90IHRocm93XCIpO1xuICAgICAgICAgICAgY29uc3QgeiA9IEFwaV8xLnppcChbJ2EnLCAnYicsICdjJ10sIFsnZCcsICdlJ10pO1xuICAgICAgICAgICAgdGhpcy5sb2coeik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoelswXVswXSA9PT0gJ2EnLCAnemlwKCkgc2hvdWxkIGNvbWJpbmUgZWxlbWVudCAwIGZyb20gYm90aCBhcnJheXMnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh6WzBdWzFdID09PSAnZCcsICd6aXAoKSBzaG91bGQgY29tYmluZSBlbGVtZW50IDAgZnJvbSBib3RoIGFycmF5cycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHpbMl1bMF0gPT09ICdjJywgJ3ppcCgpIHNob3VsZCBjb21iaW5lIGVsZW1lbnQgMSBmcm9tIGJvdGggYXJyYXlzJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoelsyXVsxXSA9PT0gdW5kZWZpbmVkLCBcIklmIGFuIGFycmF5IGlzbid0IGxvbmcgZW5vdWdoLCB1bmRlZmluZWQgc2hvdWxkIGJlIHVzZWQuXCIpO1xuICAgICAgICAgICAgY29uc3QgYyA9IEFwaV8xLmNhcnRlc2lhbihbJ2EnLCAnYicsICdjJ10sIFsnZCcsICdlJ10pO1xuICAgICAgICAgICAgdGhpcy5sb2coYyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY1swXVswXSA9PT0gJ2EnLCAnY2FydGVzaWFuKCkgc2hvdWxkIGNvbWJpbmUgZWxlbWVudCAwIGZyb20gYm90aCBhcnJheXMnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjWzBdWzFdID09PSAnZCcsICdjYXJ0ZXNpYW4oKSBzaG91bGQgY29tYmluZSBlbGVtZW50IDAgZnJvbSBib3RoIGFycmF5cycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNbMV1bMF0gPT09ICdhJywgJ2NhcnRlc2lhbigpIHNob3VsZCBjb21iaW5lIGVsZW1lbnQgMCBmcm9tIGFycmF5IDEgYW5kIGVsZW1lbnQgMSBmcm9tIGFycmF5IDInKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjWzFdWzFdID09PSAnZScsICdjYXJ0ZXNpYW4oKSBzaG91bGQgY29tYmluZSBlbGVtZW50IDAgZnJvbSBhcnJheSAxIGFuZCBlbGVtZW50IDEgZnJvbSBhcnJheSAyJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY1syXVswXSA9PT0gJ2InLCAnY2FydGVzaWFuKCkgc2hvdWxkIGNvbWJpbmUgZWxlbWVudCAxIGZyb20gYXJyYXkgMSBhbmQgZWxlbWVudCAwIGZyb20gYXJyYXkgMicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNbMl1bMV0gPT09ICdkJywgJ2NhcnRlc2lhbigpIHNob3VsZCBjb21iaW5lIGVsZW1lbnQgMSBmcm9tIGFycmF5IDEgYW5kIGVsZW1lbnQgMCBmcm9tIGFycmF5IDInKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjWzNdWzBdID09PSAnYicsICdjYXJ0ZXNpYW4oKSBzaG91bGQgY29tYmluZSBlbGVtZW50IDEgZnJvbSBib3RoIGFycmF5cycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNbM11bMV0gPT09ICdlJywgJ2NhcnRlc2lhbigpIHNob3VsZCBjb21iaW5lIGVsZW1lbnQgMSBmcm9tIGJvdGggYXJyYXlzJyk7XG4gICAgICAgICAgICBjb25zdCByID0gQXBpXzEucmFuZ2UoMTApO1xuICAgICAgICAgICAgdGhpcy5sb2cocik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoci5sZW5ndGggPT09IDEwLCAncmFuZ2UoKSBzaG91bGQgY3JlYXRlIGEgcmFuZ2Ugd2l0aCB0aGUgbGVuZ3RoIGdpdmVuJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoclswXSA9PT0gMCwgJ3JhbmdlKCkgc2hvdWxkIHN0YXJ0IGF0IDAnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChyWzldID09PSA5LCAncmFuZ2UoKSBzaG91bGQgZW5kIGF0IGxlbmd0aCAtIDEnKTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBBcnJheS5mcm9tKFsuLi5BcGlfMS50cmF2ZXJzZShbMCwgMSwgMiwgWzMsIDRdLCBbNSwgWzYsIDcsIFs4XV1dLCA5XSldKTtcbiAgICAgICAgICAgIHRoaXMubG9nKHQpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHRbMF0gPT09IDAsICd0cmF2ZXJzZSgpIHNob3VsZCBzdGFydCBhdCB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbmVzdGVkIGFycmF5Jyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodFs5XSA9PT0gOSwgJ3RyYXZlcnNlKCkgc2hvdWxkIGVuZCBhdCB0aGUgbGFzdCBpdGVtIGluIHRoZSBuZXN0ZWQgYXJyYXkgKG5vdCB0aGUgZGVlcGVzdCknKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbm90IGFuIGV4aGF1c3RpdmUgdGVzdCwgYnV0IHRoYXQgd291bGQgYmUgaW1wb3NzaWJsZS5cbiAgICAgICAgICAgIGNvbnN0IGlkMSA9IEFwaV8xLmdldFVuaXF1ZUlkKCk7XG4gICAgICAgICAgICBjb25zdCBpZDIgPSBBcGlfMS5nZXRVbmlxdWVJZCgpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGlkMSAhPT0gaWQyLCBcImdldFVuaXF1ZUlkKCkgc2hvdWxkIG5vdCBwcm9kdWNlIHRoZSBzYW1lIGlkIHR3aWNlXCIpO1xuICAgICAgICAgICAgY29uc3Qgc29ydE1lID0gWydhJywgJ1onLCAnQicsICd4JywgJ2MnLCAnWSddO1xuICAgICAgICAgICAgc29ydE1lLnNvcnQoQXBpXzEub3JkZXJCeShhID0+IGEudG9VcHBlckNhc2UoKSkpO1xuICAgICAgICAgICAgdGhpcy5sb2coc29ydE1lKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChKU09OLnN0cmluZ2lmeShzb3J0TWUpID09PSAnW1wiYVwiLFwiQlwiLFwiY1wiLFwieFwiLFwiWVwiLFwiWlwiXScsIFwib3JkZXJCeSBjYW4gYmUgdXNlZCB0byBzb3J0IGFuIGFycmF5XCIpO1xuICAgICAgICAgICAgLy8gQXNzZXJ0aW9uIGhlbHBlciBmb3IgdGhlIG5leHQgdGVzdFxuICAgICAgICAgICAgbGV0IGFzc2VydFlvdXJzZWxmID0gXCJcIjtcbiAgICAgICAgICAgIGNvbnN0IGxvZyA9IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGFyZyk7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5zcGFuKGFyZykpO1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0WW91cnNlbGYgKz0gYXJnO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIEFuZCBub3csIHRoZSBtYWluIGV2ZW50Li4uLlxuICAgICAgICAgICAgLy8gS2V5d29yZCBhcmd1bWVudHMgaW4gSlMuXG4gICAgICAgICAgICAvLyBJdCBpc24ndCBhcyBjbGVhbiBpbiBUUyBidXQgY2FuIGJlIG1hZGUgdG8gd29yay5cbiAgICAgICAgICAgIC8vIEZ1bmN0aW9ucyBjYW4gYmUgY2FsbGVkIHVzaW5nIGtleXdvcmQgYXJndW1lbnRzIHVzaW5nIHRoZSBrdygpIGZ1bmN0aW9uLiBGb3IgaW5zdGFuY2UsIGNvbnNpZGVyIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb246XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJyb3Qodm9sdGFnZSwgc3RhdGUgPSAnYSBzdGlmZicsIGFjdGlvbiA9ICd2b29tJywgdHlwZSA9ICdOb3J3ZWdpYW4gQmx1ZScpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJlZSByZWR1bmRhbnQgaXRlbXMgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlZHVuZGFudGx5IGhhcyB0byBsaXN0IHRoZSBwYXJhbWV0ZXJzIChpbiBKUywgYSBzaW1wbGUgY29weS9wYXN0ZSBmcm9tIGFib3ZlKSBhdCB0aGUgc3RhcnQuXG4gICAgICAgICAgICAgICAgLy8gSXQgdGhlbiBoYXMgdG8gbGlzdCB0aGUgcGFyYW1ldGVycyBhZ2Fpbiwgb24gdGhlIHJpZ2h0LlxuICAgICAgICAgICAgICAgIC8vIE9uIHRoZSBsZWZ0LCB0aGUgZGVmYXVsdCB2YWx1ZXMgbmVlZCB0byBiZSByZXBlYXRlZC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHN1Y2tzIGJ1dCBpdCdzIHRoZSBjbGVhbmVzdCBJIGNhbiBnZXQgaW4gSlMuIElmIHRoZSByZWZsZWN0aW9uIHdlcmUgYSBsaXR0bGUgYmV0dGVyLCBJIGNvdWxkIGRvIG1vcmUuXG4gICAgICAgICAgICAgICAgKHsgdm9sdGFnZSwgc3RhdGUgPSAnYSBzdGlmZicsIGFjdGlvbiA9ICd2b29tJywgdHlwZSA9ICdOb3J3ZWdpYW4gQmx1ZScgfSA9IEFwaV8xLkt3YXJnLnBhcnNlQXJncyh7IHZvbHRhZ2UsIHN0YXRlLCBhY3Rpb24sIHR5cGUgfSkpO1xuICAgICAgICAgICAgICAgIGFzc2VydFlvdXJzZWxmID0gXCJcIjsgLy8gQ2xlYXIgdGhlIHRlc3QgYXNzZXJ0aW9uLlxuICAgICAgICAgICAgICAgIGxvZyhcIi0tIFRoaXMgcGFycm90IHdvdWxkbid0IFwiICsgYWN0aW9uICsgXCIgXCIpO1xuICAgICAgICAgICAgICAgIGxvZyhcImlmIHlvdSBwdXQgXCIgKyB2b2x0YWdlICsgXCIgdm9sdHMgdGhyb3VnaCBpdC5cIik7XG4gICAgICAgICAgICAgICAgbG9nKFwiLS0gTG92ZWx5IHBsdW1hZ2UsIHRoZSBcIiArIHR5cGUpO1xuICAgICAgICAgICAgICAgIGxvZyhcIi0tIEl0J3MgXCIgKyBzdGF0ZSArIFwiIVwiKTtcbiAgICAgICAgICAgICAgICBsb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFycm90KCkgY291bGQgYmUgY2FsbGVkIGluIGFueSBvZiB0aGUgZm9sbG93aW5nIHdheXM6XG4gICAgICAgICAgICAvLyAoVGhlIGZ1bmN0aW9uIGt3KCkgdGFrZXMgYW4gb25lLWtleSBvYmplY3QsIGEgMiBlbGVtZW50IGFycmF5LCBvciBhIHN0cmluZyBhbmQgYSB2YWx1ZS4pXG4gICAgICAgICAgICBwYXJyb3QoMTAwMCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYXNzZXJ0WW91cnNlbGYuaW5jbHVkZXMoJ3B1dCAxMDAwIHZvbHRzJyksIFwiTm9ybWFsIEpTIHBvc2l0aW9uYWwgYXJndW1lbnRzIHdvcmsgYXMgdXN1YWxcIik7XG4gICAgICAgICAgICBwYXJyb3QoQXBpXzEua3coeyBhY3Rpb246ICdWT09PT09NJyB9KSwgQXBpXzEua3coJ3ZvbHRhZ2UnLCAxMDAwMDAwKSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYXNzZXJ0WW91cnNlbGYuaW5jbHVkZXMoXCJ3b3VsZG4ndCBWT09PT09NXCIpICYmIGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwicHV0IDEwMDAwMDAgdm9sdHNcIiksIFwiS2V5d29yZCBhcmd1bWVudHMgY2FuIGJlIHVzZWQgYW5kIGNhbiBiZSBzcGVjaWZpZWQgYXMgb25lLWtleSBvYmplY3RzIG9yIGFzIHR3byBhcmd1bWVudHNcIik7XG4gICAgICAgICAgICBwYXJyb3QoJ2EgdGhvdXNhbmQnLCBBcGlfMS5rdyhbJ3N0YXRlJywgJ3B1c2hpbmcgdXAgdGhlIGRhaXNpZXMnXSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwiSXQncyBwdXNoaW5nIHVwIHRoZSBkYWlzaWVzIVwiKSAmJiBhc3NlcnRZb3Vyc2VsZi5pbmNsdWRlcyhcInB1dCBhIHRob3VzYW5kIHZvbHRzXCIpLCBcIktleXdvcmQgYXJndW1lbnRzIGNhbiBiZSBjb21iaW5lZCB3aXRoIHBvc2l0aW9uYWwgYXJndW1lbnRzIGFuZCB0dXBsZSBrZXl3b3JkIGFyZ3VtZW50cyBjYW4gYmUgdXNlZFwiKTtcbiAgICAgICAgICAgIHBhcnJvdCgnYSBtaWxsaW9uJywgJ2JlcmVmdCBvZiBsaWZlJywgJ2p1bXAnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChhc3NlcnRZb3Vyc2VsZi5pbmNsdWRlcyhcIkl0J3MgYmVyZWZ0IG9mIGxpZmUhXCIpICYmIGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwicHV0IGEgbWlsbGlvbiB2b2x0c1wiKSAmJiBhc3NlcnRZb3Vyc2VsZi5pbmNsdWRlcyhcInBhcnJvdCB3b3VsZG4ndCBqdW1wXCIpLCBcIk11bHRpcGxlIHBvc2l0aW9uYWwgYXJndW1lbnRzIGNhbiBiZSBmaWxsZWRcIik7XG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIDMgY2FzZXMgd291bGQgYmUgaW52YWxpZDpcbiAgICAgICAgICAgIC8vIHBhcnJvdCgpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGFyZ3VtZW50IG1pc3NpbmcgY2F1Z2h0IGluIFR5cGVzY3JpcHRcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTIGlzIGZpbmUgd2l0aCBhbiB1bmRlZmluZWQgYXJndW1lbnQgc28gZG9uJ3QgYXNrIGl0IGZvciBoZWxwLlxuICAgICAgICAgICAgLy8gcGFycm90KGt3KHsgdm9sdGFnZTogMTEwIH0pLCBrdyh7IHZvbHRhZ2U6IDIyMCB9KSk7ICAgICAgLy8gZHVwbGljYXRlIGtleXdvcmRcbiAgICAgICAgICAgIC8vIHBhcnJvdChrdyh7IGFjdG9yOiAnSm9obiBDbGVlc2UnIH0pKTsgICAgICAgICAgICAgICAgICAgIC8vIHVua25vd24ga2V5d29yZCAoY29udHJvbCB3aXRoIGFsbG93VW5rbm93bktleXdvcmQpXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZSB2YWxpZCBidXQgeW91IHJlYWxseSBzaG91bGRuJ3QgZG8gdGhlbSwgYXMgdGhleSBhcmUgYmFkIHByYWN0aWNlLlxuICAgICAgICAgICAgLy8gSXQncyBub3QgcG9zc2libGUgdG8gY2F0Y2ggdGhlbSBhcyBlcnJvcnMsIHRob3VnaC4gSXQncyBiYXNlZCBvbiBpbmZvIHVua25vd24gdG8gSmF2YVNjcmlwdCAoc3BlY2lmaWNhbGx5LCBhcmd1bWVudCBkZXRhaWxzKS5cbiAgICAgICAgICAgIHBhcnJvdChBcGlfMS5rdyh7IHZvbHRhZ2U6IDUuMCB9KSwgJ2RlYWQnKTsgLy8gbm9uLWtleXdvcmQgYXJndW1lbnQgZm9sbG93aW5nIGtleXdvcmRcbiAgICAgICAgICAgIC8vIFRoaXMgd29ya3MgYXMgd3JpdHRlbiwgYnV0IGl0J3MgdWdseS4gQ29kZSBoYXMgbm8gaWRlYSBhYm91dCBvcmRlciBvZiBhcmd1bWVudHMgc28gY2Fubm90IHRyYXAgaXQuXG4gICAgICAgICAgICBwYXJyb3QoQXBpXzEua3coeyB0eXBlOiAnRmlubmlzaCBQaW5rJyB9KSwgJ2RlYWQnKTsgLy8gbm9uLWtleXdvcmQgYXJndW1lbnQgZm9sbG93aW5nIGtleXdvcmRcbiAgICAgICAgICAgIC8vIFRoaXMgcGFzc2VzIHVuZGVmaW5lZCBmb3Igdm9sdGFnZSwgYmVjYXVzZSB0aGF0IHNsb3QgaGFzIGEga2V5d29yZCBpbiBpdC5cbiAgICAgICAgICAgIC8vIENvZGUgaGFzIG5vIGlkZWEgYWJvdXQgb3JkZXIgb2YgYXJndW1lbnRzIHNvIGNhbm5vdCB0cmFwIGl0LlxuICAgICAgICAgICAgcGFycm90KDExMCwgQXBpXzEua3coeyB2b2x0YWdlOiAyMjAgfSkpOyAvLyBkdXBsaWNhdGUgdmFsdWUgZm9yIGFyZ3VtZW50XG4gICAgICAgICAgICAvLyBUaGUgbGF0ZXIga2V5d29yZCBvdmVycmlkZXMgdGhlIG5vbi1rZXl3b3JkIGFyZ3VtZW50LlxuICAgICAgICAgICAgLy8gSWYgdGhlIGZ1bmN0aW9uIGhhcyBkZWZhdWx0cyBpbiB0aGUgaGVhZGVyLCB0aHJvd2luZyB3b3VsZCBjYXVzZSB1bmV4cGVjdGVkIGV4Y2VwdGlvbnMgb24gdmFsaWQgY29kZS5cbiAgICAgICAgICAgIC8vIENvZGUgY2Fubm90IHRlbGwgaWYgYW4gYXJndW1lbnQncyB2YWx1ZSBpcyBhIGRlZmF1bHQgc2V0IGJ5IEpTIChmaW5lKSBvciBhIHVzZXIgdmFsdWUgKGJhZCksIHNvIGNhbid0IHRyYXAgdGhlIGJhZCBjYXNlLlxuICAgICAgICAgICAgLy8gV2hlbiBLd2FyZ3MucGFyc2VBcmdzKCkgaXMgY2FsbGVkLCBhIHByb3BlcnR5IG5hbWVkICQka3ckJCByZWNlaXZlcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwga2V5d29yZCBhcmd1bWVudHMgZXhjZXB0IGZvclxuICAgICAgICAgICAgLy8gdGhvc2UgY29ycmVzcG9uZGluZyB0byBhIGZvcm1hbCBwYXJhbWV0ZXIuIEJ1dCBpZiBhbGxvd1Vua25vd25LZXl3b3JkIGlzIGZhbHNlLCBhbiBlcnJvciBpcyB0aHJvd24gaW5zdGVhZC5cbiAgICAgICAgICAgIC8vIFdoZW4gS3dhcmdzLnBhcnNlQXJncygpIGlzIGNhbGxlZCB3aXRoIHJlc3QgcGFyYW1ldGVycyBpbmNsdWRlZCBpbiB0aGUgYXJndW1lbnQgbGlzdCwgYSBwcm9wZXJ0eSBuYW1lZCAkcmVzdCQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAvLyBub24ta2V5d29yZCByZXN0IGFyZ3VtZW50cy4gTm90ZSB0aGF0IHRoZXJlIGlzIG5vIHdheSB0byBpbmRpY2F0ZSBpbiB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIHRoYXQga2V5d29yZFxuICAgICAgICAgICAgLy8gYXJndW1lbnRzIGFyZSBhbGxvd2VkIHRvIGJlIGluY2x1ZGVkIGluIHRoZSByZXN0IHBhcmFtZXRlLCBzbyB0aGV5IGFyZXIuXG4gICAgICAgICAgICAvLyBJbiBKUywgcmVzdCBwYXJhbWV0ZXJzIG11c3QgYXBwZWFyIGxhc3QuXG4gICAgICAgICAgICBmdW5jdGlvbiBjaGVlc2VzaG9wKGtpbmQsIC4uLnJlc3QpIHtcbiAgICAgICAgICAgICAgICBsZXQgJHJlc3QkO1xuICAgICAgICAgICAgICAgIGxldCAkJGt3JCQ7XG4gICAgICAgICAgICAgICAgKHsga2luZCwgJHJlc3QkLCAkJGt3JCQgfSA9IEFwaV8xLkt3YXJnLnBhcnNlQXJncyhPYmplY3QuYXNzaWduKHsga2luZCB9LCByZXN0KSwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGxvZygnLS0gRG8geW91IGhhdmUgYW55ICcgKyBraW5kICsgJz8nKTtcbiAgICAgICAgICAgICAgICBsb2coXCItLSBJJ20gc29ycnksIHdlJ3JlIGFsbCBvdXQgb2YgXCIgKyBraW5kKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiAkcmVzdCQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZygnLS0tLS0tJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrd3ZhciBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygkJGt3JCQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhrd3ZhciArICcgOiAnICsgJCRrdyQkW2t3dmFyXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZygnLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJdCBjb3VsZCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxuICAgICAgICAgICAgY2hlZXNlc2hvcChcIkxpbWJ1cmdlclwiLCBcIkl0J3MgdmVyeSBydW5ueSwgc2lyLlwiLCBcIkl0J3MgcmVhbGx5IHZlcnksIFZFUlkgcnVubnksIHNpci5cIiwgQXBpXzEua3coeyBzaG9wa2VlcGVyOiBcIk1pY2hhZWwgUGFsaW5cIiB9KSwgQXBpXzEua3coeyBjbGllbnQ6IFwiSm9obiBDbGVlc2VcIiB9KSwgQXBpXzEua3coeyBza2V0Y2g6IFwiQ2hlZXNlIFNob3AgU2tldGNoXCIgfSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwiRG8geW91IGhhdmUgYW55IExpbWJ1cmdlcj9cIikgJiYgYXNzZXJ0WW91cnNlbGYuaW5jbHVkZXMoXCJJdCdzIHZlcnkgcnVubnksIHNpci5cIikgJiYgYXNzZXJ0WW91cnNlbGYuaW5jbHVkZXMoXCJJdCdzIHJlYWxseSB2ZXJ5LCBWRVJZIHJ1bm55LCBzaXIuXCIpICYmIGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwic2tldGNoIDogQ2hlZXNlIFNob3AgU2tldGNoXCIpLCBcIlJlc3QgYXJndW1lbnRzICgkcmVzdCQsIGFjdHMgbGlrZSAqYXJncykgYW5kIHJlc3Qga2V5d29yZCBhcmd1bWVudHMgKCQka3ckJCwgYWN0cyBsaWtlICoqa3cpIGNhbiBiZSB1c2VkXCIpO1xuICAgICAgICAgICAgLy8gQXJiaXRyYXJ5IGFyZ3VtZW50IGxpc3RzIGFyZSBzdXBwb3J0ZWQgaW4gSmF2YVNjcmlwdCBieSAuLi5yZXN0IHBhcmFtZXRlcnMsIHNvIGRvIG5vdCBuZWVkIHNwZWNpYWwgaGFuZGxpbmcuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgcmVzdCBwYXJhbWV0ZXJzIE1VU1QgYmUgdGhlIGZpbmFsIGFyZ3VtZW50LCBzbyB3aGlsZSBpdCBpcyBoYXZlIGtleXdvcmQgYXJndW1lbnRzLCBpdCBpc24ndCBwb3NzaWJsZVxuICAgICAgICAgICAgLy8gdG8gaW5kaWNhdGUgaW4gdGhlIGZ1bmN0aW9uIGRlZmluaXRpb24gdGhhdCBhcmJpdHJhcnkga2V5d29yZCBhcmd1bWVudHMgYXJlIGFsbG93ZWQuXG4gICAgICAgICAgICAvLyBUaGVzZSBsaXN0cyBjYW4gYmUgdW5wYWNrZWQgYnkgdGhlIC4uLnNwcmVhZCBvcGVyYXRvciwgc28gYWdhaW4sIGRvZXMgbm90IG5lZWQgc3BlY2lhbCBoYW5kbGluZy5cbiAgICAgICAgICAgIC8vIEluIHRoZSBzYW1lIGZhc2hpb24sIG9iamVjdHMgY2FuIGRlbGl2ZXIga2V5d29yZCBhcmd1bWVudHMgd2l0aCB0aGUgLi4uc3ByZWFkIG9wZXJhdG9yIGFuZCB0aGUgS3dhcmcudW5wYWNrKCkgZnVuY3Rpb246XG4gICAgICAgICAgICBjb25zdCBkaWN0ID0geyBhY3Rpb246IFwiVk9PTVwiLCB2b2x0YWdlOiBcImZvdXIgbWlsbGlvblwiLCBzdGF0ZTogXCJibGVlZGluJyBkZW1pc2VkXCIgfTtcbiAgICAgICAgICAgIC8vIFRoaXMga2luZCBvZiBUeXBlU2NyaXB0IGNvZXJjaW9uIGlzIG5lZWRlZCB3aGVuIHRoZXJlIGlzIG9uZSBvciBtb3JlIHJlcXVpcmVkIHBhcmFtZXRlcnMuIEl0IGlzIE5PVCBwcmV0dHkuXG4gICAgICAgICAgICAvLyBPbiBzdGFjayBvdmVyZmxvdywgdGhlcmUgYXJlIHNldmVyYWwgd2F5cyBnaXZlbiB0byBpbmRpY2F0ZSBtaW4tbGVuZ3RoIGFycmF5cy4gTk9ORSBhcmUgdmFsaWQgVFMuXG4gICAgICAgICAgICAvLyBJbiBwdXJlIEpTLCB0aGVzZSB0d28gbGluZXMgYXJlIGp1c3QgcGFycm90KC4uLkt3YXJnLnVucGFjayhkaWN0KSk7XG4gICAgICAgICAgICBjb25zdCB1bnBhY2tlZCA9IEFwaV8xLkt3YXJnLnVucGFjayhkaWN0KTtcbiAgICAgICAgICAgIHBhcnJvdCh1bnBhY2tlZFswXSwgLi4udW5wYWNrZWQuc2xpY2UoMSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGFzc2VydFlvdXJzZWxmLmluY2x1ZGVzKFwiVGhpcyBwYXJyb3Qgd291bGRuJ3QgVk9PTVwiKSAmJiBhc3NlcnRZb3Vyc2VsZi5pbmNsdWRlcyhcInB1dCBmb3VyIG1pbGxpb24gdm9sdHNcIikgJiYgYXNzZXJ0WW91cnNlbGYuaW5jbHVkZXMoXCJJdCdzIGJsZWVkaW4nIGRlbWlzZWQhXCIpLCBcIk9iamVjdHMgY2FuIGJlIHVucGFja2VkIGludG8gc2VwYXJhdGUga2V5d29yZCBhcmd1bWVudHMgdXNpbmcgS3dhcmcudW5wYWNrXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2coYFRFU1QgJHt0aGlzLnZpZXdNb2RlbC50ZXN0TnVtYmVyfTogVGVzdCBzdWNjZXNzZnVsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDAyID0gVGVzdDAwMjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgVGVzdENhc2VWaWV3XzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdNb2RlbF8xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3TW9kZWxcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuY2xhc3MgVGVzdFZpZXdNb2RlbCBleHRlbmRzIFRlc3RDYXNlVmlld01vZGVsXzEuVGVzdENhc2VWaWV3TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnRGVmZXJyZWQgUHJvbWlzZXMnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb25IdG1sOiBgXG4gICAgICAgICAgICA8aDI+SW50cm88L2gyPlxuICAgICAgICAgICAgPHA+VGhlIGRlZmVycmVkIHByb21pc2UgaXMgbGlrZSBhIHJlZ3VsYXIgamF2YXNjcmlwdCBwcm9taXNlLCBleGNlcHQgdGhhdCB0aGUgZGVmZXJyZWQgcHJvbWlzZSBjYW4gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5IGF0IGFueSBwb2ludCBhZnRlciBpdCdzIGNyZWF0aW9uLiBSZWd1bGFyIHByb21pc2VzIHN0YXJ0IGltbWVkaWF0ZWx5IGFuZCBqdXN0IGhvbGQgdGhlaXIgcmVzcG9uc2UuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIGRlZmVycmVkIHByb21pc2UgaXMgaW1wbGVtZW50ZWQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhIHJlZ3VsYXIgcHJvbWlzZSwgc28gaXQgdXNlcyB0aGUgc2FtZSBtaWNyb3Rhc2sgcXVldWUuPC9wPlxuICAgICAgICAgICAgPHA+VGhlIEFQSSBpcyBzaW1pbGFyIHRvIHRoZSBQcm9taXNlKCkgQVBJLCBidXQgaXMgdHdlYWtlZCBhIGxpdHRsZSBiaXQgZm9yIHVzYWJpbGl0eS4gRm9yIGV4YW1wbGUsIGhhdmluZyBvbmZ1bGZpbGxlZCgpIGFuZCBvbnJlamVjdGVkKCkgaW4gdGhlbigpIG1lYW5zIHRoYXQgZXJyb3JzIGluIG9uZnVsZmlsbGVkKCkgYXJlIG5vdCBjYXVnaHQuIEV4cGVyaWVuY2VkIEpTIHByb2dyYW1tZXJzIHJlY29tbWVuZCBub3QgdXNpbmcgb25yZWplY3RlZCgpLiBJIGxlZnQgaXQgb3V0IC4uLiB3aHkgaW52aXRlIGRpc2FzdGVyIHdoZW4gY2F0Y2goKSBleGlzdHM/PC9wPlxuXG4gICAgICAgICAgICA8aDI+VXNhZ2U8L2gyPlxuICAgICAgICAgICAgPHA+Q3JlYXRlIGEgbmV3IGRlZmVycmVkIHdpdGggXCJuZXcgRGVmZXJyZWRQcm9taXNlKCkuXCIgVGhlIEFQSSBpcyBhcyBmb2xsb3dzOjwvcD4gXG5cbiAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICBjbGFzcyBEZWZlcnJlZFByb21pc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBvbmZ1bGZpbGxlZD86ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dPblVuaGFuZGxlZEVycm9yOiBib29sZWFuXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmZ1bGZpbGxlZD86ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93T25VbmhhbmRsZWRFcnJvcjogYm9vbGVhblxuICAgICAgICAgICAgICAgICAgICApOiB0aGlzO1xuICAgICAgICAgICAgICAgIGNhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgb25yZWplY3RlZD86IChyZWFzb246IGFueSkgPT4gUHJvbWlzZUxpa2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd09uVW5oYW5kbGVkRXJyb3I6IGJvb2xlYW5cbiAgICAgICAgICAgICAgICApOiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzPzogYW55KTogdm9pZDtcbiAgICAgICAgICAgICAgICByZWplY3QoYXJncz86IGFueSk6IHZvaWQ7XG5cbiAgICAgICAgICAgICAgICBnZXQgb3V0cHV0KCk6IFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3ByZT5cblxuICAgICAgICAgICAgPHA+VGhlIHVzZSBvZiB0aGVuKCkgYW5kIGNhdGNoKCkgc2hvdWxkIGxvb2sgdmVyeSBmYW1pbGlhciB0byB5b3UgaWYgeW91J3ZlIHVzZWQgcHJvbWlzZXMgYmVmb3JlLiBJZiBpdCBkb2Vzbid0LCBnb29nbGUgaXQuPC9wPlxuXG4gICAgICAgICAgICA8cD5UbyBpbnZva2UgdGhlIHByb21pc2UsIGNhbGwgcmVzb2x2ZSgpIG9uIHRoZSBkZWZlcnJlZCBwcm9taXNlIHdpdGggd2hhdGV2ZXIgYXJncyB5b3Ugd2FudCB0byBwYXNzIGl0LjwvcD5cbiAgICAgICAgICAgIDxwPlByb21pc2UucmVzb2x2ZSgnU29tZXRoaW5nJykudGhlbihzID0+IHNvbWVGdW5jdGlvbihzKSk8YnIgLz5cbiAgICAgICAgICAgIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyA8YnIgLz5cbiAgICAgICAgICAgIG5ldyBEZWZlcnJlZFByb21pc2UoKS50aGVuKHMgPT4gc29tZUZ1bmN0aW9uKHMpKSw8YnIgLz5cbiAgICAgICAgICAgIGV4Y2VwdCB0aGF0IHRoZSBsYXR0ZXIgaXMgbm90IGV4ZWN1dGVkIHVudGlsIHlvdSBjYWxsIHByb21pc2UucmVzb2x2ZSgpLiBBY3R1YWxseSwgSSBsaWUuIEluIHRoYXQgZXhhbXBsZSwgcmVzb2x2ZSgpIGlzIGNhbGxlZCBzb21ld2hlcmUgaW4gYm90aCBjYXNlcy4gSXQncyBhIGdhcmJhZ2UgZXhhbXBsZS4gVGhlIHBvaW50IGlzLCBpbiBhIGRlZmVycmVkIHNvbWVGdW5jdGlvbigpIGlzIGV4ZWN1dGVkIGxhdGVyLjwvcD5cblxuICAgICAgICAgICAgPGgzPkNvbnN0cnVjdGlvbjwvaDM+XG5cbiAgICAgICAgICAgIDxwPlVubGlrZSB3aXRoIGFuIHVud3JhcHBlZCBQcm9taXNlLCB5b3UgY2FuIGFjdHVhbGx5IGNyZWF0ZSBhIERlZmVycmVkUHJvbWlzZSBieSB1c2luZyBuZXcgRGVmZXJyZWRQcm9taXNlKCkuIFRoaXMgcmVzb2x2ZXMgb25lIG9mIHRoZSBpbmNvbnNpc3RlbmNpZXMgaW4gdGhlIFByb21pc2UgQVBJLiBPbmUgb2YgdGhlIHRoaW5ncyBJIGxpa2UgYWJvdXQgd2hlcmUgSlMgaXMgZ29pbmcgaXMgdGhhdCBjbGFzc2VzIGFyZSBnZW5lcmFsbHkgbmV3YWJsZS48L3A+XG5cbiAgICAgICAgICAgIDxwPlRoZSBkZWZlcnJlZCBwcm9taXNlIHRha2VzIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGFzIGFuIGlucHV0LCBzbyB0aGF0IG5ldyBEZWZlcnJlZFByb21pc2UoKCkgPT4gY29uc29sZS5sb2coJ0dvdCBpdCcpKSBpcyB0aGUgc2FtZSBhcyBcIm5ldyBEZWZlcnJlZFByb21pc2UoKS50aGVuKCgpID0+IGNvbnNvbGUubG9nKCdHb3QgaXQnKSkuXCI8L3A+XG5cbiAgICAgICAgICAgIDxwPlByb21pc2VzLCBleGNlcHQgd2hlbiB1c2VkIGluIGFuIGFzeW5jL2F3YWl0IGNvbnRleHQsIGhhdmUgYW4gaXNzdWUgd2l0aCB1bmhhbmRsZWQgZXhjZXB0aW9ucy4gSW4gbm9ybWFsIGNvZGUsIGFuIHVuaGFuZGxlZCBleGNlcHRpb24gdGhyb3dzIGluIHRoZSBicm93c2VyIGNvbnNvbGUuIEluIHByb21pc2VzLCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIGlzIHNpbGVudGx5IHN3YWxsb3dlZC4gVGhlIG9ubHkgd2F5IG9mIGhhbmRsaW5nIHRoaXMgaXMgdG8gaW5jbHVkZSBhIGNhdGNoKCkgc3RlcCwgd2hpY2ggd2lsbCBmb3JjZSBlcnJvcnMgdG8gZHJvcCB0byB0aGUgY2F0Y2gsIGFuZCBhbGwgaXMgZ29vZCAuLi4gdW5sZXNzIGFuIGVycm9yIGlzIHRocm93biBpbiB0aGUgY2F0Y2guIE9vcHMuIEhhdmluZyB0aGUgb3Bwb3NpdGUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IgaXMgYSBmbGF3IGluIHRoZSBwcm9taXNlIEFQSSwgc28gYnkgZGVmYXVsdCwgdGhyb3dPblVuaGFuZGxlZEVycm9yIGFkZHMgYW4gZXh0cmEgY2F0Y2ggb250byBldmVyeSBzdGVwIHRvIHRocm93IGFuIGVycm9yIGluIHRoZSBicm93c2VyIGNvbnNvbGUuPC9wPlxuXG4gICAgICAgICAgICA8c21hbGw+SSB3b3VsZCBoYXZlIHByZWZlcnJlZCB0byBhZGQgdGhpcyBvbmx5IGF0IHRoZSBlbmQgb2YgdGhlIGNoYWluLCBidXQgdGhlIERlZmVycmVkUHJvbWlzZSBkb2Vzbid0IGtub3cgd2hlcmUgdGhlIGVuZCBvZiB0aGUgY2hhaW4gaXMsIG9ubHkgdGhlIGJlZ2lubmluZy48L3NtYWxsPlxuXG4gICAgICAgICAgICA8c21hbGw+VGhpcyBpcyBtZXNzeSBidXQgaXQgbWVhbnMgeW91IGRvbid0IG5lZWQgdG8gd29ycnkgdGhhdCBleGNlcHRpb25zIHdpbGwgYmUgc3dhbGxvd2VkLiBJdCBicmVha3MgdGhlIHRoZW4oKS50aGVuKCkuY2F0Y2goKSBwYXR0ZXJuIHNvIGl0J3Mgbm90IGVuYWJsZWQgYnkgZGVmYXVsdC48L3NtYWxsPlxuXG4gICAgICAgICAgICA8cD5JdCBpcyBwb3NzaWJsZSB0byBzZXQgdGhyb3dPblVuaGFuZGxlZEVycm9yIG9uIGEgc3RlcC1ieS1zdGVwIGJhc2lzLCBidXQgaXQncyBwcm9iYWJseSBub3QgZXh0cmVtZWx5IHVzZWZ1bC48L3A+XG5cbiAgICAgICAgICAgIDxoMz5Bc3luYy9hd2FpdDwvaDM+XG4gICAgICAgICAgICA8cD5Bc3luYy9hd2FpdCBpbiBKUyBpcyBzeW50YWN0aWMgc3VnYXIgYXJvdW5kIHByb21pc2VzLCBzbyB0byBtYWtlIHRoaXMgd29yaywgeW91IG5lZWQgYWNjZXNzIHRvIHRoZSBhY3R1YWwgaW5uZXIgcHJvbWlzZSB0aGF0IGlzIGJlaW5nIHdyYXBwZWQgaW4gdGhlIERlZmVycmVkUHJvbWlzZSgpLiBUaGlzIGlzIG1hZGUgYWNjZXNzaWJsZSB0aHJvdWdoIHRoZSBcIm91dHB1dFwiIGFjY2Vzc29yLiBZb3UgY2FuIHVzZSBpdCBsaWtlIHRoaXM6PC9wPlxuXG4gICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWRQcm9taXNlKCkudGhlbigoKSA9PiBmZXRjaFNvbWV0aGluZygpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmRlZmVycmVkLm91dHB1dDtcbiAgICAgICAgICAgICAgICBzZXRTb21ldGhpbmdFcXVhbFRvKHJlc3VsdCk7XG4gICAgICAgICAgICA8L3ByZT5cblxuICAgICAgICAgICAgPHA+VGhlbiB3aGVuIHNvbWV0aGluZyBlbHNlLCBzdWNoIGFzIGEgbW91c2UtY2xpY2sgb3IgdGhlIHJlc3VsdCBvZiBzb21lIG90aGVyIGFzeW5jIG9wZXJhdGlvbiB0cmlnZ2VycyB0aGlzLmRlZmVycmVkLnJlc29sdmUoKSwgdGhlIGNvZGUgcGlja3MgdXAgYWdhaW4gYXQgdGhlIGF3YWl0LjwvcD5cblxuICAgICAgICAgICAgPGgyPldhcm5pbmc8L2gyPlxuICAgICAgICAgICAgPHA+VGVzdHMgYXJlIGFzeW5jIGFuZCB3aWxsIGtlZXAgcnVubmluZy4gV2FpdCBmb3IgdGVzdHMgdG8gY29tcGxldGUgYmVmb3JlIGxlYXZpbmcgcGFnZS48L3A+XG4gICAgICAgICAgICBgXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRlc3QwMDMgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdfMS5UZXN0Q2FzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihuZXcgVGVzdFZpZXdNb2RlbCgpKTtcbiAgICB9XG4gICAgdGVzdENhc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiV2FpdGFibGUgdGVzdCAxXCIsIHsgaWQ6ICd3YWl0VGVzdDEnIH0pKSkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbmV3IEFwaV8xLkRlZmVycmVkUHJvbWlzZSgpLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJXYWl0YWJsZSB0ZXN0IDJcIiwgeyBpZDogJ3dhaXRUZXN0MicgfSkpKS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBjb25zdCB3YWl0RGVmZXIgPSBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKCkudGhlbigoKSA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIldhaXRhYmxlIHRlc3QgM1wiLCB7IGlkOiAnd2FpdFRlc3QzJyB9KSkpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB3YWl0RGVmZXIucmVzb2x2ZSgpLCA1MDApO1xuICAgICAgICAgICAgLy8gVGVzdGluZyBlcnJvcnMgaXMgaGFyZCBpbiBhIHBhdHRlcm4gd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VlIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IG5vbmUgPSBudWxsO1xuICAgICAgICAgICAgbmV3IEFwaV8xLkRlZmVycmVkUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9uZS5udWxsUmVmZXJlbmNlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiRk9SQ0VEIEVSUk9SIEZBSUxFRFwiLCB7IGlkOiAnY2F0Y2hUZXN0MScgfSkpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIkNBVUdIVCBFUlJPUlwiLCB7IGlkOiAnY2F0Y2hUZXN0MScgfSkpKVxuICAgICAgICAgICAgICAgIC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdjYXRjaFRlc3QyJyB9KSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHMgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoJ0F1dG9tYXRpYyBtZXNzYWdlOiAnICsgcy5tZXNzYWdlLCB7IGlkOiAnY2F0Y2hUZXN0MicgfSkpKVxuICAgICAgICAgICAgICAgIC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdjYXRjaFRlc3QzJyB9KSksIHRydWUpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHMgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoJ0F1dG9tYXRpYyBtZXNzYWdlOiAnICsgcy5tZXNzYWdlLCB7IGlkOiAnY2F0Y2hUZXN0MycgfSkpKVxuICAgICAgICAgICAgICAgIC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdjYXRjaFRlc3Q0JyB9KSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IG5vbmUubnVsbFJlZmVyZW5jZUV4Y2VwdGlvbigpKSAvLyBlcnJvciB0aHJvd24gaW4gY2F0Y2hcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJDQVVHSFQgRVJST1IgSU4gQ0FUQ0hcIiwgeyBpZDogJ2NhdGNoVGVzdDQnIH0pKSlcbiAgICAgICAgICAgICAgICAucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbmV3IEFwaV8xLkRlZmVycmVkUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9uZS5udWxsUmVmZXJlbmNlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiRk9SQ0VEIEVSUk9SIEZBSUxFRFwiLCB7IGlkOiAnY2F0Y2hUZXN0NScgfSkpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKSwgdHJ1ZSkgLy8gZXJyb3IgdGhyb3duIGluIGNhdGNoXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiQ0FVR0hUIEVSUk9SIElOIENBVENIXCIsIHsgaWQ6ICdjYXRjaFRlc3Q1JyB9KSkpXG4gICAgICAgICAgICAgICAgLnJlc29sdmUoKTtcbiAgICAgICAgICAgIG5ldyBBcGlfMS5EZWZlcnJlZFByb21pc2UoKCkgPT4gdGhpcy5sb2coXCJUaGlzIHNob3VsZCBuZXZlciBiZSBjYWxsZWRcIikpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdyZWplY3RUZXN0MScgfSkpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiQ0FVR0hUIEVSUk9SOiBcIiArIHMsIHsgaWQ6ICdyZWplY3RUZXN0MScgfSkpKVxuICAgICAgICAgICAgICAgIC5yZWplY3QoJ1JFSkVDVEVEIE1BTlVBTExZJyk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzbid0IGEgcGVyZmVjdCB0ZXN0IGJlY2F1c2UgdGhpcyBwcm9qZWN0IGlzIGN1cnJlbnRseSBnZW5lcmF0aW5nIEVTMjAxNSwgYW5kIFRTQyB0dXJucyBhc3luYy9hd2FpdCBpbnRvIGEgZ2VuZXJhdG9yLlxuICAgICAgICAgICAgY29uc3Qgd2FpdEFzeW5jID0gbmV3IEFwaV8xLkRlZmVycmVkUHJvbWlzZSgoKSA9PiBcIkFXQUlURURcIik7XG4gICAgICAgICAgICAvLyBBc3luYy9hd2FpdCB0ZXN0XG4gICAgICAgICAgICBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF3YWl0ZWQgPSB5aWVsZCB3YWl0QXN5bmMub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdEFyZWEnKS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJBU1lOQy9BV0FJVDogXCIgKyBhd2FpdGVkLCB7IGlkOiAnYXdhaXRUZXN0MScgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0ZXN0KCksIDApO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB3YWl0QXN5bmMucmVzb2x2ZSgpLCAxMCk7XG4gICAgICAgICAgICB0aGlzLmxvZygnQXN5bmMgdGVzdCBpbml0aWF0ZWQgKDIgdGVzdCBzZXRzKS4nKTtcbiAgICAgICAgICAgIC8vIFRlc3RpbmcgYXN5bmMgc3R1ZmYsIGlja1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gMTAwbXMgYWZ0ZXIgY3JlYXRpb24sIHdhaXREZWZlciBzaG91bGQgbm90IGhhdmUgYmVlbiBpbnZva2VkLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YWl0VGVzdDMnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCF3YWl0MSwgXCJXYWl0YWJsZSBzaG91bGQgd2FpdCBiZWZvcmUgcmVzb2x1dGlvbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc2V0IDEgc3VjY2Vzc2Z1bC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3YWl0MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3YWl0VGVzdDEnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhd2FpdDEsIFwiV2FpdGFibGUgY29uc3RydWN0b3Igc2hvdWxkIGFjdGl2YXRlIHdoZW4gcmVzb2x2ZSgpIGNhbGxlZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXQyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRUZXN0MicpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF3YWl0MiwgXCJXYWl0YWJsZSB0aGVuKCkgc2hvdWxkIGFjdGl2YXRlIHdoZW4gcmVzb2x2ZSBjYWxsZWQoKS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXQzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRUZXN0MycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF3YWl0MywgXCJEZWZlcnJlZCBzaG91bGQgbm90IG5lZWQgdG8gYmUgcmVzb2x2ZWQgaW1tZWRpYXRlbHkuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2F0Y2hUZXN0MScpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuZV8oZXJyb3IxKS5pbm5lckhUTUwgPT09IFwiQ0FVR0hUIEVSUk9SXCIsIFwiQ2F0Y2goKSBzaG91bGQgYmUgZXhlY3V0ZWQgb24gYW4gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yMiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRjaFRlc3QyJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhlcnJvcjIpLmlubmVySFRNTC5pbmNsdWRlcygnbnVsbFJlZmVyZW5jZUV4Y2VwdGlvbicpLCBcIkF1dG9tYXRpYyB0aHJvd09uVW5oYW5kbGVkRXJyb3Igc2hvdWxkIGJlIHRocm93biB3aXRoIHRoZSBkZWZhdWx0IGVycm9yIG1lc3NhZ2UgdGV4dFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhdGNoVGVzdDMnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKGVycm9yMykuaW5uZXJIVE1MLmluY2x1ZGVzKCdudWxsUmVmZXJlbmNlRXhjZXB0aW9uJyksIFwiSW5zdGFuY2UtbGV2ZWwgYXV0b21hdGljIHRocm93T25VbmhhbmRsZWRFcnJvciBzaG91bGQgYmUgZXhlY3V0ZWQgb24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yNCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRjaFRlc3Q0Jyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhlcnJvcjQpLmlubmVySFRNTCA9PT0gXCJDQVVHSFQgRVJST1IgSU4gQ0FUQ0hcIiwgXCJ0aHJvd09uVW5oYW5kbGVkRXJyb3Igc2hvdWxkIGNhdGNoIGVycm9ycyB0aHJvd24gaW4gYSBjYXRjaCgpIHN0YXRlbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3I1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhdGNoVGVzdDUnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKGVycm9yNSkuaW5uZXJIVE1MID09PSBcIkNBVUdIVCBFUlJPUiBJTiBDQVRDSFwiLCBcIkVycm9yIGluIGNhdGNoKCkgc2hvdWxkIGJlIGNhdWdodCB3aXRoIGluc3RhbmNlLWxldmVsIHRocm93T25VbmhhbmRsZWRFcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3I2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlamVjdFRlc3QxJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhlcnJvcjYpLmlubmVySFRNTCA9PT0gXCJDQVVHSFQgRVJST1I6IFJFSkVDVEVEIE1BTlVBTExZXCIsIFwiUmVqZWN0KCkgc2hvdWxkIGZvcmNlIGV4ZWN1dGlvbiBvZiBjYXRjaCgpIGJsb2NrXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc3luY2F3YWl0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2F3YWl0VGVzdDEnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKGFzeW5jYXdhaXQpLmlubmVySFRNTCA9PT0gXCJBU1lOQy9BV0FJVDogQVdBSVRFRFwiLCBcIkFzeW5jL2F3YWl0KCkgc2hvdWxkIGFjdCBhcyBleHBlY3RlZCAobm90ZTogaW1wbGVtZW50YXRpb24gdmFyaWVzIGJ5IFR5cGVTY3JpcHQgRVMgdmVyc2lvbilcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc2V0IDIgc3VjY2Vzc2Z1bC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRlc3QwMDMgPSBUZXN0MDAzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld1wiKTtcbmNvbnN0IFRlc3RDYXNlVmlld01vZGVsXzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdNb2RlbFwiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZXN0Vmlld01vZGVsIGV4dGVuZHMgVGVzdENhc2VWaWV3TW9kZWxfMS5UZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdSZXBlYXRhYmxlIFByb21pc2VzJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSHRtbDogYFxuICAgICAgICAgICAgPGgyPkludHJvPC9oMj5cbiAgICAgICAgICAgIDxwPlRoZSBwcm9taXNlIGlzIGFsbW9zdCBsaWtlIGFuIGV2ZW50IGVtaXR0ZXIsIGFuZCB3aXRoIHRoZSBpbnRyb2R1Y3Rpb24gb2YgdGhlIERlZmVycmVkUHJvbWlzZSBjbGFzcyxcbiAgICAgICAgICAgIHdoaWNoIGFsbG93cyBpbnZvY2F0aW9uIGF0IGEgbGF0ZXIgcG9pbnQgaW4gdGltZSwgdGhpcyBpcyBtb3JlIHRydWUuIEJ1dCB0aGVyZSBpcyBvbmUgdGhpbmcgdGhhdCBtYWtlc1xuICAgICAgICAgICAgcHJvbWlzZXMgaW5hZGVxdWF0ZSBhcyBldmVudCBlbWl0dGVyczogcHJvbWlzZXMgY2FuIG9ubHkgYmUgcmVzb2x2ZWQgb25jZS4gVGhlIHJlc29sdmUgb25jZSBiZWhhdmlvciBpc1xuICAgICAgICAgICAgZnVuZGFtZW50YWwgdG8gdGhlIGVudGlyZSBjb25jZXB0IG9mIHRoZSBwcm9taXNlLjwvcD5cblxuICAgICAgICAgICAgPHA+QnV0IHRoZXkncmUgc28gbmljZSwgb3RoZXJ3aXNlLiBUaGUgcHJvbWlzZSBBUEkgaXMgc28gdXNlZnVsIGZvciBjaGFpbmluZyBhc3luY2hyb25vdXMgZXZlbnQgaGFuZGxlcnMsXG4gICAgICAgICAgICBhbmQgaXQgbWFrZXMgdGhlIGFzeW5jL2F3YWl0IHN5bnRheCBwb3NzaWJsZSwgYW5kIGFzIG11Y2ggYXMgSSBsaWtlIHRoZSBwcm9taXNlIEFQSSwgdGhlIGFzeW5jL2F3YWl0IEFQSVxuICAgICAgICAgICAgaXMgZmFyIGJldHRlci4gWW91IGNhbid0IGhhdmUgaXQgd2l0aG91dCBwcm9taXNlcywgdGhvdWdoLjwvcD5cblxuICAgICAgICAgICAgPHA+QW5kIHNvIHRoZSBSZXBlYXRhYmxlUHJvbWlzZSB3YXMgYm9ybi4gVGhlIHJlcGVhdGFibGUgcHJvbWlzZSBpcyBhIGZpY3Rpb24gdGhhdCBwcmV0ZW5kcyB0byBiZSBhIHByb21pc2VcbiAgICAgICAgICAgIGJ5IHNob3dpbmcgYSBzaW1pbGFyIEFQSS4gSW4gZmFjdCwgaXQgaXMgYSBmYWN0b3J5IGNsYXNzLiBXd2hhdCBpdCBkb2VzIGlzIGJ1aWxkIGEgbmV3IHByb21pc2UgZXZlcnkgdGltZSB5b3VcbiAgICAgICAgICAgIGNhbGwgaXQsIHdoaWNoIGludm9sdmVzIGEgcGVyZm9ybWFuY2UgaGl0IGJ1dCBpcyBiZXR0ZXIgdGhhbiBub3RoaW5nIGl0IGFsbC4gU3VyZSwgbm90aGluZyBhdCBhbGwgaXMgcmVhbGx5IGRhcm5cbiAgICAgICAgICAgIGZhc3QsIGJ1dCBpdCBoYXMgYSB0ZW5kZW5jeSB0byBiZSB1c2VsZXNzLjwvcD5cblxuICAgICAgICAgICAgPGgyPlVzYWdlPC9oMj5cbiAgICAgICAgICAgIDxwPkNyZWF0ZSBhIG5ldyByZXBlYXRhYmxlIHdpdGggXCJuZXcgUmVwZWF0YWJsZVByb21pc2UoKS5cIiBUaGUgQVBJIGlzIGFzIGZvbGxvd3M6PC9wPlxuXG4gICAgICAgICAgICA8cHJlPlxuICAgICAgICAgICAgY2xhc3MgUmVwZWF0YWJsZVByb21pc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgICAgICBvbmZ1bGZpbGxlZD86ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgb25VbmhhbmRsZWRFcnJvcj86ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlTGlrZSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dPblVuaGFuZGxlZEVycm9yOiBib29sZWFuXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHRoZW4oXG4gICAgICAgICAgICAgICAgICAgICAgICBvbmZ1bGZpbGxlZD86ICh2YWx1ZTogYW55KSA9PiBQcm9taXNlTGlrZVxuICAgICAgICAgICAgICAgICAgICApOiB0aGlzO1xuICAgICAgICAgICAgICAgIGNhdGNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgb25yZWplY3RlZD86IChyZWFzb246IGFueSkgPT4gUHJvbWlzZUxpa2VcbiAgICAgICAgICAgICAgICApOiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmdzPzogYW55KTogUHJvbWlzZTtcbiAgICAgICAgICAgICAgICByZWplY3QoYXJncz86IGFueSk6IFByb21pc2U7XG5cbiAgICAgICAgICAgICAgICBidWlsZCgpOiBEZWZlcnJlZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3ByZT5cblxuICAgICAgICAgICAgPHA+VGhlIHVzZSBvZiB0aGVuKCkgYW5kIGNhdGNoKCkgc2hvdWxkIGxvb2sgdmVyeSBmYW1pbGlhciB0byB5b3UgaWYgeW91J3ZlIHVzZWQgcHJvbWlzZXMgYmVmb3JlLiBJZiBpdCBkb2Vzbid0LCBnb29nbGUgaXQuPC9wPlxuXG4gICAgICAgICAgICA8cD5UbyBpbnZva2UgdGhlIHByb21pc2UsIGNhbGwgcmVzb2x2ZSgpIG9uIHRoZSByZXBlYXRhYmxlIHByb21pc2Ugd2l0aCB3aGF0ZXZlciBhcmdzIHlvdSB3YW50IHRvIHBhc3MgaXQuIFlvdSBjYW4gZG8gdGhpcyBhcyBtYW55IHRpbWVzIGFzIHlvdSBuZWVkIHRvLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhlIGJ1aWxkKCkgbWV0aG9kIGdpdmVzIGEgaGludCBhYm91dCBob3cgdGhlIFJlcGVhdGFibGVQcm9taXNlIGNsYXNzIHdvcmtzLCBhcyBpdCBpcyBhIERlZmVycmVkUHJvbWlzZSBmYWN0b3J5LiBUaGUgYnVpbGQoKSBtZXRob2QgaXMgcHVibGljIHNvIHRoYXQgaWYgeW91IHdhbnQgdG8gdXNlIGl0IGFzIGEgcHJvbWlzZSBidWlsZGVyLCB5b3UgY2FuIGdvIHJpZ2h0IG9uIGFuZCBkbyBpdC48L3A+XG5cbiAgICAgICAgICAgIDxoMz5Db25zdHJ1Y3Rpb248L2gzPlxuXG4gICAgICAgICAgICA8cD5UaGUgcmVwZWF0YWJsZSBwcm9taXNlIHRha2VzIGFuIG9wdGlvbmFsIGNhbGxiYWNrIGFzIGFuIGlucHV0LCBzbyB0aGF0IG5ldyBSZXBlYXRhYmxlUHJvbWlzZSgoKSA9PiBjb25zb2xlLmxvZygnR290IGl0JykpIGlzIHRoZSBzYW1lIGFzIFwibmV3IFJlcGVhdGFibGVQcm9taXNlKCkudGhlbigoKSA9PiBjb25zb2xlLmxvZygnR290IGl0JykpLlwiPC9wPlxuXG4gICAgICAgICAgICA8cD5Qcm9taXNlcywgZXhjZXB0IHdoZW4gdXNlZCBpbiBhbiBhc3luYy9hd2FpdCBjb250ZXh0LCBoYXZlIGFuIGlzc3VlIHdpdGggdW5oYW5kbGVkIGV4Y2VwdGlvbnMuIEluIG5vcm1hbCBjb2RlLCBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uIHRocm93cyBpbiB0aGUgYnJvd3NlciBjb25zb2xlLiBJbiBwcm9taXNlcywgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbiBpcyBzaWxlbnRseSBzd2FsbG93ZWQuIFRoZSBvbmx5IHdheSBvZiBoYW5kbGluZyB0aGlzIGlzIHRvIGluY2x1ZGUgYSBjYXRjaCgpIHN0ZXAsIHdoaWNoIHdpbGwgZm9yY2UgZXJyb3JzIHRvIGRyb3AgdG8gdGhlIGNhdGNoLCBhbmQgYWxsIGlzIGdvb2QgLi4uIHVubGVzcyBhbiBlcnJvciBpcyB0aHJvd24gaW4gdGhlIGNhdGNoLiBPb3BzLiBIYXZpbmcgdGhlIG9wcG9zaXRlIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yIGlzIGEgZmxhdyBpbiB0aGUgcHJvbWlzZSBBUEksIHNvIGJ5IGRlZmF1bHQsIHRocm93T25VbmhhbmRsZWRFcnJvciBhZGRzIGFuIGV4dHJhIGNhdGNoIG9udG8gdGhlIHZlcnkgZW5kIHRoYXQgdGhyb3dzIGlmIHRoZSBlcnJvciBpcyB1bmhhbmRsZWQuPC9wPlxuXG4gICAgICAgICAgICA8cD5JZiB5b3Ugd2FudCB0byBkZWNsYXJlLCBkdXJpbmcgY29uc3RydWN0aW9uLCBhIGNhdGNoIGJsb2NrIHRvIGJlIGNhbGxlZCBvbiBhbnkgdW5oYW5kbGVkIGVycm9yLCB5b3UgY2FuIHNwZWRpZnkgdGhlIG9uVW5oYW5kbGVkRXJyb3IgaW5wdXQuIFRoaXMgaXMgc3VnYXIgZm9yIHByb21pc2UudGhlbigpLnRoZW4oKS5jYXRjaChteUNhbGxiYWNrKSAodGhpcyB3b3VsZCBoYXZlIGJlZW4gZG9uZSBpbiB0aGUgRGVmZXJyZWRQcm9taXNlIGlmIGl0IHdlcmUgcG9zc2libGUpLjwvcD5cblxuICAgICAgICAgICAgPGgzPkFzeW5jL2F3YWl0PC9oMz5cbiAgICAgICAgICAgIDxwPkFzeW5jL2F3YWl0IGluIGphdmFzY3JpcHQgaXMgc3ludGFjdGljIHN1Z2FyIGFyb3VuZCBwcm9taXNlcywgc28gdG8gbWFrZSB0aGlzIHdvcmssIHlvdSBuZWVkIGFjY2VzcyB0byB0aGUgYWN0dWFsIGlubmVyIHByb21pc2UgdGhhdCBpcyBiZWluZyB3cmFwcGVkIGluIHRoZSBSZXBlYXRhYmxlUHJvbWlzZS4gIFRoaXMgaXMgcmV0dXJuZWQgZnJvbSB0aGUgcmVzb2x2ZSBtZXRob2QuIFlvdSBjYW4gdXNlIGl0IGxpa2UgdGhpczo8L3A+XG5cbiAgICAgICAgICAgIDxwcmU+XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRhYmxlID0gbmV3IFJlcGVhdGFibGVQcm9taXNlKCkudGhlbigoKSA9PiBmZXRjaFNvbWV0aGluZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvbWVNZXRob2QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yZXBlYXRhYmxlLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U29tZXRoaW5nRXF1YWxUbyhyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvcHJlPlxuXG4gICAgICAgICAgICA8cD5UaGVuIHdoZW4gc29tZXRoaW5nIGVsc2UsIHN1Y2ggYXMgYSBtb3VzZS1jbGljayBvciB0aGUgcmVzdWx0IG9mIHNvbWUgb3RoZXIgYXN5bmMgb3BlcmF0aW9uIGNhbGxzIHNvbWVNZXRob2QoKSwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgYW5kIGFjdGVkIHVwb24uPC9wPlxuXG4gICAgICAgICAgICA8cD5BZ2FpbiwgdGVzdHMgYXJlIGFzeW5jIGFuZCB3aWxsIGtlZXAgcnVubmluZy4gV2FpdCBmb3IgdGVzdHMgdG8gY29tcGxldGUgYmVmb3JlIGxlYXZpbmcgcGFnZS4gRnJvbSB0aGlzIHBvaW50IG9uLCBtb3N0IG9mXG4gICAgICAgICAgICB0aGUgdGVzdCBjYXNlcyBhcmUgYXN5bmMuPC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDA0IGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVGhlIHRlc3RzIGZvciBkZWZlcnJlZCBtdXN0IGFsc28gd29yayBmb3IgcmVwZWFibGUuXG4gICAgICAgICAgICBuZXcgQXBpXzEuUmVwZWF0YWJsZVByb21pc2UoKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJXYWl0YWJsZSB0ZXN0IDFcIiwgeyBpZDogJ3dhaXRUZXN0MScgfSkpKS5yZXNvbHZlKCk7XG4gICAgICAgICAgICBuZXcgQXBpXzEuUmVwZWF0YWJsZVByb21pc2UoKS50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiV2FpdGFibGUgdGVzdCAyXCIsIHsgaWQ6ICd3YWl0VGVzdDInIH0pKSkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgY29uc3Qgd2FpdERlZmVyID0gbmV3IEFwaV8xLlJlcGVhdGFibGVQcm9taXNlKCkudGhlbigoKSA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIldhaXRhYmxlIHRlc3QgM1wiLCB7IGlkOiAnd2FpdFRlc3QzJyB9KSkpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB3YWl0RGVmZXIucmVzb2x2ZSgpLCA1MDApO1xuICAgICAgICAgICAgLy8gVGVzdGluZyBlcnJvcnMgaXMgaGFyZCBpbiBhIHBhdHRlcm4gd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VlIGV4Y2VwdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IG5vbmUgPSBudWxsO1xuICAgICAgICAgICAgbmV3IEFwaV8xLlJlcGVhdGFibGVQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdjYXRjaFRlc3QxJyB9KSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiQ0FVR0hUIEVSUk9SXCIsIHsgaWQ6ICdjYXRjaFRlc3QxJyB9KSkpXG4gICAgICAgICAgICAgICAgLnJlc29sdmUoKTtcbiAgICAgICAgICAgIG5ldyBBcGlfMS5SZXBlYXRhYmxlUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9uZS5udWxsUmVmZXJlbmNlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9LCBudWxsLCB0cnVlKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiRk9SQ0VEIEVSUk9SIEZBSUxFRFwiLCB7IGlkOiAnY2F0Y2hUZXN0MicgfSkpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKCdBdXRvbWF0aWMgbWVzc2FnZTogJyArIHMubWVzc2FnZSwgeyBpZDogJ2NhdGNoVGVzdDInIH0pKSlcbiAgICAgICAgICAgICAgICAucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbmV3IEFwaV8xLlJlcGVhdGFibGVQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub25lLm51bGxSZWZlcmVuY2VFeGNlcHRpb24oKTtcbiAgICAgICAgICAgIH0sIG51bGwsIHRydWUpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJGT1JDRUQgRVJST1IgRkFJTEVEXCIsIHsgaWQ6ICdjYXRjaFRlc3Q0JyB9KSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IG5vbmUubnVsbFJlZmVyZW5jZUV4Y2VwdGlvbigpKSAvLyBlcnJvciB0aHJvd24gaW4gY2F0Y2hcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJDQVVHSFQgRVJST1IgSU4gQ0FUQ0hcIiwgeyBpZDogJ2NhdGNoVGVzdDQnIH0pKSlcbiAgICAgICAgICAgICAgICAucmVzb2x2ZSgpO1xuICAgICAgICAgICAgbmV3IEFwaV8xLlJlcGVhdGFibGVQcm9taXNlKCgpID0+IHRoaXMubG9nKFwiVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkXCIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiRk9SQ0VEIEVSUk9SIEZBSUxFRFwiLCB7IGlkOiAncmVqZWN0VGVzdDEnIH0pKSlcbiAgICAgICAgICAgICAgICAuY2F0Y2gocyA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIkNBVUdIVCBFUlJPUjogXCIgKyBzLCB7IGlkOiAncmVqZWN0VGVzdDEnIH0pKSlcbiAgICAgICAgICAgICAgICAucmVqZWN0KCdSRUpFQ1RFRCBNQU5VQUxMWScpO1xuICAgICAgICAgICAgLy8gVGhpcyBpc24ndCBhIHBlcmZlY3QgdGVzdCBiZWNhdXNlIHRoaXMgcHJvamVjdCBpcyBjdXJyZW50bHkgZ2VuZXJhdGluZyBFUzIwMTUsIGFuZCBUU0MgdHVybnMgYXN5bmMvYXdhaXQgaW50byBhIGdlbmVyYXRvci5cbiAgICAgICAgICAgIGNvbnN0IHdhaXRBc3luYyA9IG5ldyBBcGlfMS5SZXBlYXRhYmxlUHJvbWlzZSgoKSA9PiBcIkFXQUlURURcIik7XG4gICAgICAgICAgICAvLyBBc3luYy9hd2FpdCB0ZXN0XG4gICAgICAgICAgICBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF3YWl0ZWQgPSB5aWVsZCB3YWl0QXN5bmMucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdEFyZWEnKS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoXCJBU1lOQy9BV0FJVDogXCIgKyBhd2FpdGVkLCB7IGlkOiAnYXdhaXRUZXN0MScgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0ZXN0KCksIDApO1xuICAgICAgICAgICAgLy8gVGVzdHMgZm9yIHJlcGVhdGFibGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgY29uc3QgcmVwZWF0ZXIxID0gbmV3IEFwaV8xLlJlcGVhdGFibGVQcm9taXNlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIlJlcGVhdGVkOiBcIiArIGksIHsgaWQ6IFwicmVwZWF0VGVzdFwiICsgaSB9KSk7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXBlYXRlcjEucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmVwZWF0ZXIxLnJlc29sdmUoKTtcbiAgICAgICAgICAgIG5ldyBBcGlfMS5SZXBlYXRhYmxlUHJvbWlzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9uZS5udWxsUmVmZXJlbmNlRXhjZXB0aW9uKCk7XG4gICAgICAgICAgICB9LCAoKSA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChcIkNBVUdIVCBFUlJPUlwiLCB7IGlkOiAnY2F0Y2hUZXN0NycgfSkpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiRk9SQ0VEIEVSUk9SIEZBSUxFRFwiLCB7IGlkOiAnY2F0Y2hUZXN0NycgfSkpKVxuICAgICAgICAgICAgICAgIC5yZXNvbHZlKCk7XG4gICAgICAgICAgICBjb25zdCByZXBlYXRlcjMgPSBuZXcgQXBpXzEuUmVwZWF0YWJsZVByb21pc2UoKS50aGVuKCgpID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKFwiQnVpbGQgdGVzdFwiLCB7IGlkOiAncmVwZWF0VGVzdDMnIH0pKSk7XG4gICAgICAgICAgICBjb25zdCB3YWl0NCA9IHJlcGVhdGVyMy5idWlsZCgpO1xuICAgICAgICAgICAgd2FpdDQucmVzb2x2ZSgpO1xuICAgICAgICAgICAgdGhpcy5sb2coJ0FzeW5jIHRlc3QgaW5pdGlhdGVkICgyIHRlc3Qgc2V0cykuJyk7XG4gICAgICAgICAgICAvLyBUZXN0aW5nIGFzeW5jIHN0dWZmIGlzIHN1cGVyIGFubm95aW5nXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyAxMDBtcyBhZnRlciBjcmVhdGlvbiwgd2FpdERlZmVyIHNob3VsZCBub3QgaGF2ZSBiZWVuIGludm9rZWQuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRUZXN0MycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoIXdhaXQxLCBcIldhaXRhYmxlIHNob3VsZCB3YWl0IGJlZm9yZSByZXNvbHV0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coYFRFU1QgJHt0aGlzLnZpZXdNb2RlbC50ZXN0TnVtYmVyfTogVGVzdCBzZXQgMSBzdWNjZXNzZnVsLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiRVJST1I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dhaXRUZXN0MScpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF3YWl0MSwgXCJXYWl0YWJsZSBjb25zdHJ1Y3RvciBzaG91bGQgYWN0aXZhdGUgd2hlbiByZXNvbHZlKCkgY2FsbGVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FpdDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2FpdFRlc3QyJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXdhaXQyLCBcIldhaXRhYmxlIHRoZW4oKSBzaG91bGQgYWN0aXZhdGUgd2hlbiByZXNvbHZlIGNhbGxlZCgpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FpdDMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2FpdFRlc3QzJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXdhaXQzLCBcIkRlZmVycmVkIHNob3VsZCBub3QgbmVlZCB0byBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS5cIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yMSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRjaFRlc3QxJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhlcnJvcjEpLmlubmVySFRNTCA9PT0gXCJDQVVHSFQgRVJST1JcIiwgXCJDYXRjaCgpIHNob3VsZCBiZSBleGVjdXRlZCBvbiBhbiBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhdGNoVGVzdDInKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFwaV8xLmVfKGVycm9yMikuaW5uZXJIVE1MLmluY2x1ZGVzKCdudWxsUmVmZXJlbmNlRXhjZXB0aW9uJyksIFwiQXV0b21hdGljIHRocm93T25VbmhhbmRsZWRFcnJvciBzaG91bGQgYmUgdGhyb3duIHdpdGggdGhlIGRlZmF1bHQgZXJyb3IgbWVzc2FnZSB0ZXh0XCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvcjQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2F0Y2hUZXN0NCcpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuZV8oZXJyb3I0KS5pbm5lckhUTUwgPT09IFwiQ0FVR0hUIEVSUk9SIElOIENBVENIXCIsIFwidGhyb3dPblVuaGFuZGxlZEVycm9yIHNob3VsZCBjYXRjaCBlcnJvcnMgdGhyb3duIGluIGEgY2F0Y2goKSBzdGF0ZW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yNiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZWplY3RUZXN0MScpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuZV8oZXJyb3I2KS5pbm5lckhUTUwgPT09IFwiQ0FVR0hUIEVSUk9SOiBSRUpFQ1RFRCBNQU5VQUxMWVwiLCBcIlJlamVjdCgpIHNob3VsZCBmb3JjZSBleGVjdXRpb24gb2YgY2F0Y2goKSBibG9ja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXN5bmNhd2FpdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhd2FpdFRlc3QxJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhhc3luY2F3YWl0KS5pbm5lckhUTUwgPT09IFwiQVNZTkMvQVdBSVQ6IEFXQUlURURcIiwgXCJBc3luYy9hd2FpdCgpIHNob3VsZCBhY3QgYXMgZXhwZWN0ZWQgKG5vdGU6IGltcGxlbWVudGF0aW9uIHZhcmllcyBieSBUeXBlU2NyaXB0IEVTIHZlcnNpb24pXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXBlYXQxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JlcGVhdFRlc3QxJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXJlcGVhdDEsICdSZXBlYXRlZCBzaG91bGQgZXhlY3V0ZSB3aGVuIHJlc29sdmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGVhdDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVwZWF0VGVzdDInKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhcmVwZWF0MiwgJ1JlcGVhdGVkIHNob3VsZCBleGVjdXRlIGFnYWluIHdoZW4gcmVzb2x2ZWQgYWdhaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVwZWF0MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXBlYXRUZXN0MycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISFyZXBlYXQzLCAnUmVwZWF0ZWQgYnVpbGQoKSBzaG91bGQgcmV0dXJuIGEgZGVmZXJyZWQsIHdoaWNoIHNob3VsZCBiZSBleGVjdXRhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yNyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXRjaFRlc3Q3Jyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhlcnJvcjcpLmlubmVySFRNTCA9PT0gXCJDQVVHSFQgRVJST1JcIiwgXCJDYXRjaCgpIDcgc2hvdWxkIGJlIGNhdWdodCBieSB0aGUgZ2VuZXJhbCBleGNlcHRpb24gaGFuZGxlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc2V0IDIgc3VjY2Vzc2Z1bC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlRlc3QwMDQgPSBUZXN0MDA0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgVGVzdENhc2VWaWV3XzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdNb2RlbF8xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3TW9kZWxcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuY2xhc3MgVGVzdFZpZXdNb2RlbCBleHRlbmRzIFRlc3RDYXNlVmlld01vZGVsXzEuVGVzdENhc2VWaWV3TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnRXZlbnQgSGFuZGxlcicsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGBcbiAgICAgICAgICAgIDxoMj5JbnRybzwvaDI+XG4gICAgICAgICAgICA8cD5BbiBldmVudCBoYW5kbGVyIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGEgc3Vic2NyaWJlKCkgbWV0aG9kIGFuZCBhbiBpbnZva2UoKSBtZXRob2QuXG4gICAgICAgICAgICBXaGVuIHRoZSBpbnZva2UoKSBtZXRob2QgaXMgY2FsbGVkLCBhbnkgZGVsZWdhdGVzIHRoYXQgYXJlIHN1YnNjcmliZWQgYXJlIGV4ZWN1dGVkLiBBdCBpdCdzIGhlYXJ0LCB0aGF0J3NcbiAgICAgICAgICAgIGFsbCBpdCBpcy4gVGhlIGJhc2ljIGRlc2lnbiBjb21lcyBmcm9tIEMjIGV2ZW50IGhhbmRsZXJzLCBhcyBkb2VzIHRoZSBuYW1lIChwZXJzb25hbGx5LCBJIHdvdWxkIHByZWZlciBcImV2ZW50XG4gICAgICAgICAgICBlbWl0dGVyXCIsIGJlY2F1c2UgdG8gbWUgdGhlIHN1YnNjcmliaW5nIGRlbGVnYXRlIGxpc3RlbmVycyBhcmUgXCJoYW5kbGluZ1wiIHRoZSBldmVudCwgYnV0IHdobyBhbSBJIHRvIGFyZ3VlXG4gICAgICAgICAgICB3aXRoIE1pY3Jvc29mdCkuPC9wPlxuXG4gICAgICAgICAgICA8aDI+VXNhZ2U8L2gyPlxuICAgICAgICAgICAgPHA+VGhlIEFQSSBpcyBhcyBmb2xsb3dzOjwvcD5cblxuICAgICAgICAgICAgPHByZT5cbiAgICAgICAgICAgIHR5cGUgRGVsZWdhdGVUeXBlID0geyBjYWxsYmFjazogSUFjdGlvbjE8YW55PiwgdGhpc0FyZzogYW55LCBwcm9taXNlOiBSZXBlYXRhYmxlUHJvbWlzZSB9O1xuICAgICAgICAgICAgdHlwZSBSZXBlYXRhYmxlUHJvbWlzZSA9IFJlY3Vyc2l2ZUFycmF5PERlbGVnYXRlVHlwZT47XG5cbiAgICAgICAgICAgIGNsYXNzIEV2ZW50SGFuZGxlcjxUQXJncz4ge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlOiBSZWN1cnNpdmVEZWxlZ2F0ZTtcblxuICAgICAgICAgICAgICAgIHN1YnNjcmliZShkZWxlZ2F0ZTogUmVjdXJzaXZlRGVsZWdhdGUpOiB2b2lkO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZShjYWxsYmFjazogSUFjdGlvbjE8VEFyZ3M+KTogdm9pZDtcblxuICAgICAgICAgICAgICAgIGludm9rZShhcmdzPzogVEFyZ3MpOiB2b2lkO1xuXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVDYWxsYmFjayhjYWxsYmFjazogSUFjdGlvbjE8VEFyZ3M+KTogdm9pZDtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZURlbGVnYXRlKGRlbGVnYXRlOiBSZWN1cnNpdmVEZWxlZ2F0ZSk6IHZvaWQ7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVMaXN0ZW5lcihsaXN0ZW5lcjogYW55KTogdm9pZDtcbiAgICAgICAgICAgICAgICBjbGVhcigpOiB2b2lkO1xuXG4gICAgICAgICAgICAgICAgZGlzcG9zZSgpOiB2b2lkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9wcmU+XG5cbiAgICAgICAgICAgIDxwPllvdSBjYW4gc3Vic2NyaWJlIG9uZSBvciBtb3JlIGNhbGxiYWNrcywgZWl0aGVyIGluZGl2aWR1YWxseSBvciBhbGwgYXQgdGhlIHNhbWUgdGltZS4gWW91IGNhbiBhbHNvIHN1YnNjcmliZSBvdGhlciBkZWxlZ2F0ZXMsIHdoaWNoIHRoZW1zZWx2ZXMgY2FuIGJlIG1hZGUgb2YgbXVsdGlwbGUgY2FsbGJhY2tzLiBUaGlzIGlzIHVzZWZ1bCB0byBoYXZlIG9uZSBkZWxlZ2F0ZSBpbnZvY2F0aW9uIHRyaWdnZXIgbXVsdGlwbGUgZXZlbnQgaGFuZGxlcnMuICBZb3UgY2FuIGtlZXAgZ29pbmcgYWQtaW5maW5pdHVtLiBZb3UgY2FuIHN1YnNjcmliZSBhIGRlbGVnYXRlIHRvIGl0c2VsZiwgaWYgeW91IHdhbnQgdG8gY3Jhc2ggdGhlIGJyb3dzZXIuPC9wPlxuXG4gICAgICAgICAgICA8cD5UaGUgUmVjdXJzaXZlRGVsZWdhdGUgaXMgYW4gYXJyYXkgb2YgRGVsZWdhdGVUeXBlLCBvciBhbiBhcnJheSBvZiBhcnJheXMgb2YgRGVsZWdhdGVUeXBlLCBvciBhbiBhcnJheSBvZiBhcnJheSBvZiBhcnJheXMgb2YgRGVsZWdhdGVUeXBlLCBldGMuPC9wPlxuXG4gICAgICAgICAgICA8cD5Zb3Ugc2hvdWxkcyBpbmNsdWRlIHRoaXNBcmcgZm9yIHRoZSBsaXN0ZW5lciB0aGF0IHNob3VsZCBleGVjdXRlIHRoZSBjYWxsYmFjay4gVGhpcyBpcyBub3QgYWJzb2x1dGVseSByZXF1aXJlZCBmb3IgZXh0cmVtZWx5IHNpbXBsZSBjYWxsYmFja3MsIGJ1dCB0aGUgbWFqb3JpdHkgb2YgY2FsbGJhY2tzIGRvIHJlcXVpcmUgdGhlIHRoaXNBcmcgdG8gZnVuY3Rpb24sIGFuZCBpdCdzIHJlYWxseSBlYXN5IHRvIGxlYXZlIG91dCwgbWFraW5nIGZvciBjb25mdXNpbmcgZXJyb3JzLiBJZiB0aGlzIHdlcmUgQyMsIEkgbWlnaHQgaGF2ZSBtYXJrZWQgdGhhdCBvdmVycmlkZSBhcyBvYnNvbGV0ZSBzbyB5b3UnZCBnZXQgYSB3YXJuaW5nLjwvcD5cblxuICAgICAgICAgICAgPHA+QnkgZGVmYXVsdCwgdGhlIEV2ZW50SGFuZGxlciBpcyBhc3luY2hyb25vdXMsIHVzaW5nIHByb21pc2VzIHRvIGV4ZWN1dGUgdGhlIGRlbGVnYXRlLiBUbyBjcmVhdGUgYSBzeW5jaHJvbm91cyBldmVudCBoYW5kbGVyLCBzZW5kIGZhbHNlIGludG8gdGhlIGNvbnN0cnVjdG9yLCBuZXcgRXZlbnRIYW5kbGVyKGZhbHNlKS48L3A+XG5cbiAgICAgICAgICAgIDxoMj5XYXJuaW5nPC9oMj5cbiAgICAgICAgICAgIDxwPlRlc3RzIGFyZSBhc3luYyBhbmQgd2lsbCBrZWVwIHJ1bm5pbmcuIFdhaXQgZm9yIHRlc3RzIHRvIGNvbXBsZXRlIGJlZm9yZSBsZWF2aW5nIHBhZ2UuPC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDA1IGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlcjEgPSBuZXcgQXBpXzEuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgICAgICBoYW5kbGVyMS5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoJ3AnLCBhcmdzKSksIHRoaXMpO1xuICAgICAgICAgICAgaGFuZGxlcjEuaW52b2tlKHsgaWQ6ICdoYW5kbGVyMScsIGlubmVySFRNTDogJ1RFU1QgMScgfSk7XG4gICAgICAgICAgICBoYW5kbGVyMS5pbnZva2UoeyBpZDogJ2hhbmRsZXIyJywgaW5uZXJIVE1MOiAnVEVTVCAyJyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIyID0gbmV3IEFwaV8xLkV2ZW50SGFuZGxlcih0cnVlKTtcbiAgICAgICAgICAgIGhhbmRsZXIyLnN1YnNjcmliZShhcmdzID0+IHtcbiAgICAgICAgICAgICAgICBhcmdzLmlkID0gYXJncy5pZCArICdzJztcbiAgICAgICAgICAgICAgICBhcmdzLmlubmVySFRNTCA9IGFyZ3MuaW5uZXJIVE1MICsgJzogU1lOQyc7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVFbGVtZW50KCdwJywgYXJncykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVyMi5pbnZva2UoeyBpZDogJ2hhbmRsZXIzJywgaW5uZXJIVE1MOiAnVEVTVCAzJyB9KTtcbiAgICAgICAgICAgIC8vIFlvdSBjYW4gc3Vic2NyaWJlIGRlbGVnYXRlcyB0byBvdGhlciBkZWxlZ2F0ZXMsIHRoZSBzYW1lIGFzIGNhbGxiYWNrcy5cbiAgICAgICAgICAgIGhhbmRsZXIxLnN1YnNjcmliZShoYW5kbGVyMi5kZWxlZ2F0ZSk7XG4gICAgICAgICAgICBoYW5kbGVyMS5pbnZva2UoeyBpZDogJ2hhbmRsZXI0JywgaW5uZXJIVE1MOiAnVEVTVCA0JyB9KTtcbiAgICAgICAgICAgIGhhbmRsZXIxLnVuc3Vic2NyaWJlRGVsZWdhdGUoaGFuZGxlcjIuZGVsZWdhdGUpO1xuICAgICAgICAgICAgaGFuZGxlcjEuaW52b2tlKHsgaWQ6ICdoYW5kbGVyNScsIGlubmVySFRNTDogJ1RFU1QgNScgfSk7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcjEgPSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuaWQgPSBhcmdzLmlkICsgJ2MnO1xuICAgICAgICAgICAgICAgICAgICBhcmdzLmlubmVySFRNTCA9IGFyZ3MuaW5uZXJIVE1MICsgJzogQ0FMTEJBQ0snO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdEFyZWEnKS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVFbGVtZW50KCdwJywgYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBoYW5kbGVyMS5jbGVhcigpO1xuICAgICAgICAgICAgaGFuZGxlcjEuc3Vic2NyaWJlKGxpc3RlbmVyMS5jYWxsYmFjaywgbGlzdGVuZXIxKTtcbiAgICAgICAgICAgIGhhbmRsZXIxLmludm9rZSh7IGlkOiAnaGFuZGxlcjYnLCBpbm5lckhUTUw6ICdURVNUIDYnIH0pO1xuICAgICAgICAgICAgaGFuZGxlcjEudW5zdWJzY3JpYmVMaXN0ZW5lcihsaXN0ZW5lcjEpO1xuICAgICAgICAgICAgaGFuZGxlcjEuaW52b2tlKHsgaWQ6ICdoYW5kbGVyNycsIGlubmVySFRNTDogJ1RFU1QgNycgfSk7XG4gICAgICAgICAgICBoYW5kbGVyMS5zdWJzY3JpYmUobGlzdGVuZXIxLmNhbGxiYWNrLCBsaXN0ZW5lcjEpO1xuICAgICAgICAgICAgaGFuZGxlcjEudW5zdWJzY3JpYmVDYWxsYmFjayhsaXN0ZW5lcjEuY2FsbGJhY2spO1xuICAgICAgICAgICAgaGFuZGxlcjEuaW52b2tlKHsgaWQ6ICdoYW5kbGVyOCcsIGlubmVySFRNTDogJ1RFU1QgOCcgfSk7XG4gICAgICAgICAgICAvLyBIYW5kbGVyIDIgc2hvdWxkIGNhbGwgaGFuZGxlciAxIHdoaWNoIGNhbGxzIHRoZSBjYWxsYmFjayBvbiBoYW5kbGVyIDEuXG4gICAgICAgICAgICBoYW5kbGVyMS5zdWJzY3JpYmUobGlzdGVuZXIxLmNhbGxiYWNrLCBsaXN0ZW5lcjEpO1xuICAgICAgICAgICAgaGFuZGxlcjIuc3Vic2NyaWJlKGhhbmRsZXIxLmRlbGVnYXRlKTtcbiAgICAgICAgICAgIGhhbmRsZXIyLmludm9rZSh7IGlkOiAnaGFuZGxlcjknLCBpbm5lckhUTUw6ICdURVNUIDknIH0pO1xuICAgICAgICAgICAgLy8gVGhlIGRlbGVnYXRlIGlzIGEgcmVhbCByZWZlcmVuY2UsIG5vdCBhIGNvcHksIHNvIGlmIHlvdSB1bnN1YiB0aGUgY2FsbGJhY2ssIGl0IHNob3VsZCBhbHNvIHVuc3ViIGZyb20gaGFuZGxlcjIuXG4gICAgICAgICAgICBoYW5kbGVyMS51bnN1YnNjcmliZUNhbGxiYWNrKGxpc3RlbmVyMS5jYWxsYmFjayk7XG4gICAgICAgICAgICBoYW5kbGVyMi5pbnZva2UoeyBpZDogJ2hhbmRsZXIxMCcsIGlubmVySFRNTDogJ1RFU1QgMTAnIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2coJ0FzeW5jIHRlc3QgaW5pdGlhdGVkICgxIHRlc3Qgc2V0KS4nKTtcbiAgICAgICAgICAgIC8vIFRlc3RpbmcgYXN5bmMgc3R1ZmYgaXMgc3VwZXIgYW5ub3lpbmdcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXIxJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXRlc3QxLCAnaW52b2tlKCkgc2hvdWxkIGV4ZWN1dGUgdGhlIGNhbGxiYWNrIHdpdGggdGhlIGFyZ3VtZW50cyBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGFuZGxlcjInKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGVzdDIsICdpbnZva2UoKSBzaG91bGQgYmUgcmVwZWF0YWJsZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdDMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGFuZGxlcjNzJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXRlc3QzLCAnU3luY2hyb25vdXMgaW52b2tlKCkgc2hvdWxkIGV4ZWN1dGUgdGhlIGxpc3RlbmVyLicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0NGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGFuZGxlcjQnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGVzdDRhLCAnaW52b2tlKCkgd2hlbiBjaGFpbmVkIHNob3VsZCBzdGlsbCBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdDRiID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXI0cycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF0ZXN0NGIsICdpbnZva2UoKSB3aGVuIGNoYWluZWQgc2hvdWxkIGV4ZWN1dGUgdGhlIHNlY29uZGFyeSBvYnNlcnZhYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3Q1ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXI1cycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoIXRlc3Q1LCAnVW5zdWJzY3JpYmVkIGRlbGVnYXRlcyBzaG91bGQgbm90IGJlIHRyaWdnZXJlZCBieSBpbnZva2UuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3Q2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXI2YycpO1xuICAgICAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF0ZXN0NiwgJ0R1bWIgY2FsbGJhY2tzIHNob3VsZCBiZSBjaGFpbmFibGUganVzdCBsaWtlIG9ic2VydmFibGVzLicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0NmIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGFuZGxlcjYnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCF0ZXN0NmIsICdDbGVhcigpIHNob3VsZCB1bnN1YnNjcmliZSBhbGwgbGlzdGVuZXJzLicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0NyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoYW5kbGVyN2MnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCF0ZXN0NywgJ1Nob3VsZCBiZSBhYmxlIHRvIHVuc3Vic2NyaWJlIGNhbGxiYWNrcyBieSBsaXN0ZW5lci4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdDggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaGFuZGxlcjhjJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghdGVzdDgsICdTaG91bGQgYmUgYWJsZSB0byB1bnN1YnNjcmliZSBzcGVjaWZpYyBjYWxsYmFja3MuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlc3Q5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXI5c2MnKTtcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGVzdDksICdXaGVuIHVuc3Vic2NyaWJpbmcgYSBjYWxsYmFjayBmcm9tIGEgc2Vjb25kYXJ5IGxpc3RlbmVyLCBpdCBzaG91bGQgYWxzbyBiZSB1bnN1YnNjcmliZWQgZnJvbSB0aGUgcHJpbWFyeS4nKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdDEwID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbmRsZXIxMHNjJyk7XG4gICAgICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydCghdGVzdDEwLCAnV2hlbiB1bnN1YnNjcmliaW5nIGEgZGVsZWdhdGUgZnJvbSBhIHNlY29uZGFyeSBsaXN0ZW5lciwgaXQgc2hvdWxkIGFsc28gYmUgdW5zdWJzY3JpYmVkIGZyb20gdGhlIHByaW1hcnkuJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdFUlJPUjogJyArIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZygnRVJST1I6ICcgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDA1ID0gVGVzdDAwNTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ09ic2VydmFibGUgUHJvcGVydHknLFxuICAgICAgICAgICAgZGVzY3JpcHRpb25IdG1sOiBgXG4gICAgICAgICAgICA8aDI+VXNhZ2U8L2gyPlxuICAgICAgICAgICAgPHA+QW4gb2JzZXJ2YWJsZSBwcm9wZXJ0eSBpcyBhIGZpZWxkIHRoYXQsIHdoZW4geW91IHNldCBpdHMgdmFsdWUsIHJhaXNlcyBhbiBldmVudCBvbiBpdHMgZXZlbnQgaGFuZGxlci48L3A+XG4gICAgICAgICAgICA8cD5BbmQgcmVhbGx5LCBpdCdzIG5vIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiB0aGF0LiBZb3Ugd291bGQgdXNlIGl0IGxpa2UgdGhlIGZvbGxvd2luZzo8L3A+XG4gICAgICAgICAgICA8cHJlPjxjb2RlPlxuICAgICAgICAgICAgICAgIHZhciBwcm9wID0gbmV3IE9ic2VydmFibGVQcm9wZXJ0eTxpbnQ+KDQxKTtcbiAgICAgICAgICAgICAgICBwcm9wLnN1YnNjcmliZShzb21lQ29tcG9uZW50LnJlbmRlciwgc29tZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgcHJvcC52YWx1ZSArPSAxO1xuICAgICAgICAgICAgPC9jb2RlPjwvcHJlPlxuICAgICAgICAgICAgPHA+Tm93IHNvbWVDb21wb25lbnQgcmVmcmVzaGVzIHRvIHNob3cgdGhlIGFuc3dlciB0byB0aGUgdWx0aW1hdGUgcXVlc3Rpb24gb2YgbGlmZSwgdGhlIHVuaXZlcnNlLCBhbmQgZXZlcnl0aGluZy4gWW91IHNob3VsZCB0cnkgdG8gdXNlIHNhZmVWYWx1ZSwgd2hpY2ggaXMgYSBub24tbnVsbCwgSFRNTC1lc2NhcGVkIHN0cmluZywgZm9yIGFueSBkaXNwbGF5ZWQgcHJvcGVydGllcy4gQnkgZGVmYXVsdCwgaW5qZWN0aW9uXG4gICAgICAgICAgICBzaG91bGQgbm90IG9jY3VyLiBJZiBpdCBpcyBuZWNlc3NhcnkgdG8gaW5qZWN0IHRoZSB2YWx1ZSBkaXJlY3RseSBpbnRvIHRoZSBIVE1MLCB1c2UgdmFsdWUuPC9wPlxuXG4gICAgICAgICAgICA8aDI+V2FybmluZzwvaDI+XG4gICAgICAgICAgICA8cD5UZXN0cyBhcmUgYXN5bmMgYW5kIHdpbGwga2VlcCBydW5uaW5nLiBXYWl0IGZvciB0ZXN0cyB0byBjb21wbGV0ZSBiZWZvcmUgbGVhdmluZyBwYWdlLjwvcD5cbiAgICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVGVzdDAwNiBleHRlbmRzIFRlc3RDYXNlVmlld18xLlRlc3RDYXNlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG5ldyBUZXN0Vmlld01vZGVsKCkpO1xuICAgIH1cbiAgICB0ZXN0Q2FzZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUxID0gbmV3IEFwaV8xLk9ic2VydmFibGVQcm9wZXJ0eSgxLCB7IG5hbWU6IFwiQSBOdW1iZXJcIiB9KTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlMS52YWx1ZSA9PT0gMSwgXCJPYnNlcnZhYmxlIHZhbHVlIHNob3VsZCByZXR1cm4gaW5pdGlhbCB2YWx1ZVwiKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUxLnN1YnNjcmliZShhcmdzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBOZXc6JHthcmdzLm5ld1ZhbHVlfS4gT2xkOiR7YXJncy5vbGRWYWx1ZX1gLCB7IGlkOiBcInRlc3RcIiArIGFyZ3Mub2xkVmFsdWUgfSkpLCBvYnNlcnZhYmxlMSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMS52YWx1ZSA9IDI7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMS52YWx1ZSA9IDM7XG4gICAgICAgICAgICAvLyBTZWUgbGF0ZXIgZm9yIGFzc2VydFxuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGUxLnRvU3RyaW5nKCkgPT09IFwiM1wiLCBcInRvU3RyaW5nIHNob3VsZCByZXR1cm4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgaW50ZXJuYWwgdmFsdWVcIik7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlMiA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHkoXCJEb2dcIiwgeyBuYW1lOiBcIkRvZyBMb3ZlclwiIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTMgPSBuZXcgQXBpXzEuT2JzZXJ2YWJsZVByb3BlcnR5KFwiQ2F0XCIsIHsgbmFtZTogXCJDYXQgTG92ZXJcIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU0ID0gbmV3IEFwaV8xLk9ic2VydmFibGVQcm9wZXJ0eShcIkhhbXVzdGFhXCIsIHsgbmFtZTogXCJEaXNjb3JkaWFuXCIgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhhcmdzLCBpZCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0QXJlYScpLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChgSSBhbSAke3RoaXMudmFsdWV9LiBFdmVudCB2YWx1ZTogJHthcmdzLm5ld1ZhbHVlfWAsIHsgaWQ6IFwiZm9yd2FyZFRlc3RcIiArIGlkIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhc3NpbmcgYXJvdW5kIHRoaXMgaW4gamF2YXNjcmlwdCBpcyBibG9vZHkgYW5ub3lpbmcuXG4gICAgICAgICAgICAvLyBCdXQgdXN1YWxseSB3ZSBhcmVuJ3QgbGlua2luZyBkaXJlY3RseSB0byB0aGUgb2JzZXJ2YWJsZSBhbmQgdHJ5aW5nIHRvIG1hbnVhbGx5IHNlbmQgaW4gZW5jbG9zZWQgdmFsdWVzLlxuICAgICAgICAgICAgLy8gTm90IFRISVMgcmVkdW5kYW50IGFsbCB0aGUgdGltZS5cbiAgICAgICAgICAgIG9ic2VydmFibGUyLnN1YnNjcmliZShhcmdzID0+IGNhbGxiYWNrLmNhbGwob2JzZXJ2YWJsZTIsIGFyZ3MsIDEpLCBvYnNlcnZhYmxlMik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMy5zdWJzY3JpYmUoYXJncyA9PiBjYWxsYmFjay5jYWxsKG9ic2VydmFibGUzLCBhcmdzLCAyKSwgb2JzZXJ2YWJsZTMpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTQuc3Vic2NyaWJlKGFyZ3MgPT4gY2FsbGJhY2suY2FsbChvYnNlcnZhYmxlNCwgYXJncywgMyksIG9ic2VydmFibGU0KTtcbiAgICAgICAgICAgIG9ic2VydmFibGUzLnNlbmRDaGFuZ2VFdmVudHNUbyhvYnNlcnZhYmxlMik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMy5yZWNlaXZlQ2hhbmdlRXZlbnRzRnJvbShvYnNlcnZhYmxlNCk7XG4gICAgICAgICAgICAvLyA0IGlzIHNlbmRpbmcgdG8gMywgd2hpY2ggaXMgc2VuZGluZyB0byAyLiBTbyBtb2RpZnlpbmcgNCB3aWxsIHRyaWdnZXIgYWxsIDMgY2FsbGJhY2tzLlxuICAgICAgICAgICAgb2JzZXJ2YWJsZTQudmFsdWUgPSBcIkJvYSBDb25zdHJpY3RvclwiO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTUgPSBuZXcgQXBpXzEuT2JzZXJ2YWJsZVByb3BlcnR5KFwiXCIpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTUuc3Vic2NyaWJlKGFyZ3MgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgaW5uZXJIVE1MOiBvYnNlcnZhYmxlNS5zYWZlVmFsdWUsIGlkOiBcImVzY2FwZTFcIiB9KSksIG9ic2VydmFibGU1KTtcbiAgICAgICAgICAgIG9ic2VydmFibGU1LnZhbHVlID0gXCI8cD5wYXJhZ3JhcGggc2hvdWxkIGJlIGVzY2FwZWQ8L3A+XCI7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlNiA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHkoXCJcIik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNi5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBpbm5lckhUTUw6IG9ic2VydmFibGU2LnZhbHVlLCBpZDogXCJlc2NhcGUyXCIgfSkpLCBvYnNlcnZhYmxlNik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNi52YWx1ZSA9IFwiPHA+cGFyYWdyYXBoIHNob3VsZCBub3QgYmUgZXNjYXBlZDwvcD5cIjtcbiAgICAgICAgICAgIC8vIElmIE9ubHlXaGVuQ2hhbmdlZCBpcyB0cnVlLCB0aGVuIG5vIGV2ZW50IGlzIGludm9rZWQgd2hlbiB0aGUgbmV3IHZhbHVlIGlzIHRoZSBzYW1lIGFzIHRoZSBvbGQgdmFsdWUuXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlNyA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHkoJ0ZvbycsIHsgb25seVdoZW5DaGFuZ2VkOiB0cnVlIH0pO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTcuc3Vic2NyaWJlKGFyZ3MgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYE5ldzoke2FyZ3MubmV3VmFsdWV9LiBPbGQ6JHthcmdzLm9sZFZhbHVlfWAsIHsgaWQ6IFwibm9vcFwiIH0pKSwgb2JzZXJ2YWJsZTcpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTcudmFsdWUgPSAnRm9vJztcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU4ID0ge1xuICAgICAgICAgICAgICAgIHByb3A6IG5ldyBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHkoXCJGb29cIilcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvYnNlcnZhYmxlOC5wcm9wLnN1YnNjcmliZSgoYXJncykgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYE5ldzoke2FyZ3MubmV3VmFsdWV9LiBPbGQ6JHthcmdzLm9sZFZhbHVlfWAsIHsgaWQ6IFwiYXNzaWduXCIgfSkpLCBvYnNlcnZhYmxlOCk7XG4gICAgICAgICAgICBBcGlfMS5vYnNlcnZhYmxlQXNzaWduKG9ic2VydmFibGU4LCB7IHByb3A6IFwiQkFSXCIsIG5vdHByb3A6IFwiQkFaXCIgfSk7IC8vIHZlcnkgc2ltcGxlIHRlc3RcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlOC5ub3Rwcm9wID09PSBcIkJBWlwiLCBcIkFsbCBwcm9wZXJ0aWVzIGNvcGllZCBieSBvYnNlcnZhYmxlQXNzaWduXCIpO1xuICAgICAgICAgICAgdGhpcy5sb2coJ0FzeW5jIHRlc3QgaW5pdGlhdGVkICgxIHRlc3Qgc2V0KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIkVSUk9SOiBcIiArIGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdGluZyBhc3luYyBzdHVmZiBpcyBzdXBlciBhbm5veWluZ1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdDEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdDEnKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF0ZXN0MSwgJ2NoYW5naW5nIHZhbHVlIHNob3VsZCBleGVjdXRlIHRoZSBjYWxsYmFjay4nKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXBpXzEuZV8odGVzdDEpLmlubmVySFRNTCA9PT0gXCJOZXc6Mi4gT2xkOjFcIiwgXCJDb3JyZWN0IGFyZ3VtZW50cyBzaG91bGQgYmUgcGFzc2VkXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3QyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlc3QyJyk7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGVzdDIsICdjaGFuZ2luZyB2YWx1ZSBzaG91bGQgZXhlY3V0ZSB0aGUgY2FsbGJhY2sgcmVwZWF0ZWRseS4nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDEnKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDInKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF0ZXN0NCwgXCJXaGVuIHJlY2VpdmluZyBjaGFuZ2UgZXZlbnRzLCBvYnNlcnZhYmxlIHNob3VsZCBiZSBpbnZva2VkIGJ5IGFuIGV2ZW50IG9uIHRoZSBzZW5kZXIsIHVzaW5nIHRoZSBzYW1lIGFyZ3VtZW50c1wiKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoISF0ZXN0MywgXCJXaGVuIHNlbmRpbmcgY2hhbmdlIGV2ZW50cywgb2JzZXJ2YWJsZSBpbnZvY2F0aW9uIHNob3VsZCB0cmlnZ2VyIGFuIGV2ZW50IG9uIHRoZSByZWNlaXZlciwgdXNpbmcgdGhlIHNhbWUgYXJndW1lbnRzXCIpO1xuICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXNjYXBlMScpKS5pbm5lckhUTUwgPT09IFwiJmx0O3AmZ3Q7cGFyYWdyYXBoIHNob3VsZCBiZSBlc2NhcGVkJmx0Oy9wJmd0O1wiLCBcInNhZmVWYWx1ZSBzaG91bGQgYmUgZXNjYXBlZCBmb3Igc3RyaW5nIG9ic2VydmFibGVzXCIpO1xuICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5lXyhkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXNjYXBlMicpKS5xdWVyeVNlbGVjdG9yKCdwJykuaW5uZXJIVE1MID09PSBcInBhcmFncmFwaCBzaG91bGQgbm90IGJlIGVzY2FwZWRcIiwgXCJ2YWx1ZSBzaG91bGQgbm90IGJlIGVzY2FwZWRcIik7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub29wJykgPT09IG51bGwsIFwiTm8gdXBkYXRlIHdoZW4gdmFsdWUgbm90IGNoYW5nZWQgaWYgb25seVdoZW5DaGFuZ2VkIHNldFwiKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Fzc2lnbicpLmlubmVySFRNTCA9PT0gXCJOZXc6QkFSLiBPbGQ6Rm9vXCIsIFwiT2JzZXJ2YWJsZSBhc3NpZ24gYXNzaWducyBmdWxsIG9iamVjdCB3aXRob3V0IGxvc2luZyBzdWJzY3JpYmVyc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhgVEVTVCAke3RoaXMudmlld01vZGVsLnRlc3ROdW1iZXJ9OiBUZXN0IHN1Y2Nlc3NmdWxgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnRVJST1I6ICcgKyBlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDA2ID0gVGVzdDAwNjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ09ic2VydmFibGUgKFJveHkpIGJ5IFByb3h5JyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSHRtbDogYFxuICAgICAgICAgICAgPHA+QSBjbGVhbiBhcHJvYWNoIGZvciB0aGUgcHJvZ3JhbW1lciBpcyB0byB1c2UgRVMyMDE1IHByb3hpZXMuIFByb3hpZXMgaGF2ZSBiZWVuIGFyb3VuZCBmb3IgZW5vdWdoIHllYXJzXG4gICAgICAgICAgICB0aGF0IHRoZXkgc2hvdWxkIGJlIHN1cHBvcnRlZCBieSBhbGwgYnJvd3NlcnMuICBUaGV5IGhhdmUgdGhlIGJlbmVmaXQgb2YgYmVpbmcgYWJsZSB0byB0cmFwIGFjY2VzcyB0byBhblxuICAgICAgICAgICAgb2JqZWN0IGluIGEgd2F5IHRoYXQgaXMgaW52aXNpYmxlLiBUaGV5IGhhdmUgdGhlIGRpc2FkdmFudGFnZSBvZiBiZWluZyBvcmRlcnMgb2YgbWFnbml0dWRlIHNsb3dlciB0aGFuXG4gICAgICAgICAgICBkaXJlY3QgYWNjZXNzLiBCdXQgd2UncmUgZXZlcnl3aGVyZSB1c2luZyBwcm9taXNlcywgd2hpY2ggYXJlIGFuIG9yZGVyIG9mIG1hZ25pdHVkZSBzbG93ZXIgdGhhbiBjYWxsYmFja3MsIHNvXG4gICAgICAgICAgICBjbGVhcmx5IENQVSBjeWNsZXMgYXJlIGNoZWFwIHRoZXNlIGRheXMuIEZvciBub3JtYWwgR1VJIG9wZXJhdGlvbnMsIGhpZ2ggcGVyZm9ybWFuY2UgaXNuJ3QgbmVlZGVkLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhlIHdheSB5b3UgY3JlYXRlIHByb3hpZXMgaW4gSmF2YVNjcmlwdCBpcyBuYXN0eSBzdHVmZiwgYW5kIHJlcXVpcmVzIHRoZSBvcmlnaW5hbCBwcm94aWVkIG9iamVjdCB0b1xuICAgICAgICAgICAgYmUgc3RvcmVkIHNvbWV3aGVyZS4gVGhpcyBpcyBoaWRkZW4gd2F5IGZyb20geW91IGJ5IHRoZSBPYnNlcnZhYmxlUHJveHkucHJveGltYXRlKCkgbWV0aG9kLCB3aGljaCB0YWtlcyBhblxuICAgICAgICAgICAgb2JqZWN0IGFuZCByZXR1cm5zIHRoZSBwcm94aWVkIG9ic2VydmFibGUgdmVyc2lvbi48L3A+XG5cbiAgICAgICAgICAgIDxwPlByb3hpZWQgb2JzZXJ2YWJsZXMgZG8gbm90IGhhdmUgYW55IGhlbHBlciBtZXRob2RzIGxpa2UgdGhlIG9ic2VydmFibGUgcHJvcGVydHkncyBzYWZlVmFsdWUuIFRvIHRoZSB1c2VyLCB0aGV5XG4gICAgICAgICAgICBhcHBlYXIgdG8gYmUgc2ltcGxlIFBPSk9zLCB3aGVyZSBnZXQganVzdCByZXR1cm5zIGEgc3RyaW5nLiBZb3UgaGF2ZSB0byByZW1lbWJlciB0byBlc2NhcGUgaXQgeW91cnNlbGYgKHRoaXMgaXNuJ3RcbiAgICAgICAgICAgIHRvIHNheSBJIHdvbid0IG1ha2UgYW4gZXh0ZW5zaW9uIG1ldGhvZCBhdCBzb21lIHBvaW50KS48L3A+XG5cbiAgICAgICAgICAgIDxwcmU+PGNvZGU+XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSA9IE9ic2VydmFibGVQcm94eS5wcm94aW1hdGU8SVVsdGltYXRlUXVlc3Rpb24+KHsgdGhlQW5zd2VyOiA0MSB9KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmliZShzb21lQ29tcG9uZW50LnJlbmRlciwgc29tZUNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZS50aGVBbnN3ZXIgKz0gMTtcbiAgICAgICAgICAgIDwvY29kZT48L3ByZT5cblxuICAgICAgICAgICAgPHA+QXMgeW91IGNhbiBzZWUsIG90aGVyIHRoYW4gdGhlIGZhY3RvcnkgbWV0aG9kIG5lZWRlZCB0byBjcmVhdGUgc3VjaCBhbiBvYnNlcnZhYmxlLCB5b3UgY2FuIGFjY2VzcyB0aGUgb2JqZWN0J3Mga2V5cyBhcyBub3JtYWwuICBUaGVyZSdzIG5vIG5lZWQgdG8gYWNjZXNzIGFueSBzcGVjaWFsIHZhbHVlIHByb3BlcnR5IGxpa2UgdGhlcmUgaXMgd2l0aCB0aGUgT2JzZXJ2YWJsZVByb3BlcnR5IGNsYXNzLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhlIHBsYWNlIHdoZXJlIGl0IHJlYWxseSBzaGluZXMgaXMgb24gYXJyYXlzLiAgVGhlIGFtb3VudCBvZiBjb2RlIHJlcXVpcmVkIHRvIGNyZWF0ZSBhbiBPYnNlcnZhYmxlTGlzdCBvYmplY3QgaXNcbiAgICAgICAgICAgIGNvbnNpZGVyYWJsZSAoSSBoYXZlIGl0IHJpZ2h0IGhlcmUpLCBhbmQgc3VjaCBhbiBvYmplY3QgY2Fubm90IGJlIGFjY2Vzc2VkIHVzaW5nIHRoZSBvYmpbaW5kZXhlcl0gc3ludGF4LCBiZWNhdXNlIHRoYXRcbiAgICAgICAgICAgIGlzIGJ1aWx0LWluIGFuZCBjYW4ndCBiZSBvdmVycmlkZGVuLiBCdXQgb24gdGhlIG90aGVyIGhhbmQsIHRoaXMgbG9va3MgYWxtb3N0IGxpa2UgYSBub3JtYWwgYXJyYXk6PC9wPlxuXG4gICAgICAgICAgICA8cHJlPjxjb2RlPlxuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUgPSBPYnNlcnZhYmxlUHJveHkucHJveGltYXRlPG51bWJlcltdPihbMCwgMSwgMl0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGUuc3Vic2NyaWJlKHNvbWVDb21wb25lbnQucmVuZGVyLCBzb21lQ29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnB1c2goMywgNCk7XG4gICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVs0XSA9IDQyO1xuICAgICAgICAgICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgICAgICAgICA8aDI+V2FybmluZzwvaDI+XG4gICAgICAgICAgICA8cD5UZXN0cyBhcmUgYXN5bmMgYW5kIHdpbGwga2VlcCBydW5uaW5nLiBXYWl0IGZvciB0ZXN0cyB0byBjb21wbGV0ZSBiZWZvcmUgbGVhdmluZyBwYWdlLjwvcD5cbiAgICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVGVzdDAwNyBleHRlbmRzIFRlc3RDYXNlVmlld18xLlRlc3RDYXNlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG5ldyBUZXN0Vmlld01vZGVsKCkpO1xuICAgIH1cbiAgICB0ZXN0Q2FzZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIHRlc3QgdGhpcyBhcyBhIGJldHRlci1jb25uZWN0ZWQgd2F5IHRvIHNjaGVkdWxlIGFzeW5jIGFzc2VydHMsIHNpbmNlIEknbSBkb2luZyBzbyBtdWNoIG9mIHRoZW1cbiAgICAgICAgICAgIGNvbnN0IGFzeW5jQXNzZXJ0cyA9IG5ldyBBcGlfMS5EZWZlcnJlZFByb21pc2UoQXBpXzEuZGVsYXkoMTAwMCksIHRydWUpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZXhwZWN0ZWQgd2F5IHRvIHByb2R1Y2UgYW4gb2JzZXJ2YWJsZS5cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUxID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZSh7IG51bTE6IDEsIG51bTI6IDIgfSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTEubnVtMSA9PT0gMSAmJiBvYnNlcnZhYmxlMS5udW0yID09PSAyLCAnT2JzZXJ2YWJsZSBzaG91bGQgbWF0Y2ggaW5pdGlhbCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUxLnN1YnNjcmliZShhcmdzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBOZXc6JHthcmdzLm5ld1ZhbHVlfS4gT2xkOiR7YXJncy5vbGRWYWx1ZX0uYCwgeyBpZDogXCJvYnMxdGVzdFwiICsgYXJncy5vbGRWYWx1ZSB9KSkpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTEubnVtMSA9IDI7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMS5udW0xID0gMztcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb2JzMXRlc3QxJykuaW5uZXJIVE1MID09PSAnTmV3OjIuIE9sZDoxLicsICdDYWxsYmFjayAxIGV4ZWN1dGVkIHdpdGggY29ycmVjdCBhcmd1bWVudHMnKSk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29iczF0ZXN0MicpLmlubmVySFRNTCA9PT0gJ05ldzozLiBPbGQ6Mi4nLCAnQ2FsbGJhY2sgMiBleGVjdXRlZCB3aXRoIGNvcnJlY3QgYXJndW1lbnRzJykpO1xuICAgICAgICAgICAgLy8gSXQgaXMgcG9zc2libGUgdG8gYnVpbGQgYSBwcm94eSBvZiBhIHNpbXBsZSB2YWx1ZSAoYW55dGhpbmcgYnV0IGFuIG9iamVjdCBvciBmdW5jdGlvbikuIFRoZSBwcm94aW1hdGUoKSBtZXRob2QgbXVzdCBzdGlsbFxuICAgICAgICAgICAgLy8gcmV0dXJuIGFuIG9iamVjdCwgaG93ZXZlci4gSXQgZG9lcyB0aGlzIGJ5IHB1dHRpbmcgdGhlIHZhbHVlIGludG8gYSBwcm9wZXJ0eSBuYW1lZCAndmFsdWUuJ1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTFhID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZSgxKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlMWEudmFsdWUgPT09IDEsIFwiT2JzZXJ2YWJsZS52YWx1ZSBsb2FkZWQgd2l0aCBpbml0aWFsIHZhbHVlLlwiKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUxYS5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChgS2V5OiAke2FyZ3MucHJvcGVydHlOYW1lfS4gTmV3OiR7YXJncy5uZXdWYWx1ZX0uIE9sZDoke2FyZ3Mub2xkVmFsdWV9LmAsIHsgaWQ6IFwib2JzZXJ2YWJsZTFhXCIgfSkpKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUxYS52YWx1ZSA9IDExMTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb2JzZXJ2YWJsZTFhJykuaW5uZXJIVE1MID09PSAnS2V5OiB2YWx1ZS4gTmV3OjExMS4gT2xkOjEuJywgJ09ic2VydmFibGUudmFsdWUgdHJpZ2dlcnMgY2FsbGJhY2snKSk7XG4gICAgICAgICAgICAvLyBPZiBjb3Vyc2UsIHlvdSBjb3VsZCBkbyBUSElTLCBidXQgaXQgd29uJ3QgZG8gd2hhdCB5b3UncmUgZXhwZWN0aW5nLiBwcm94aW1hdGUoKSBtYWtlcyBhIENPUFkgKHR3byBhY3R1YWxseSksIHNvIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIGRvIG5vdCBtYWtlIGl0IHRvIHRoZSBvcmlnaW5hbCBvYmplY3QuIFNvIGRvbid0IGRvIHRoaXMuXG4gICAgICAgICAgICBjb25zdCBkb250RG9UaGlzID0geyBudW0xOiAxLCBudW0yOiAyIH07XG4gICAgICAgICAgICBjb25zdCBkb250RG9UaGlzT2JzZXJ2YWJsZSA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoZG9udERvVGhpcyk7XG4gICAgICAgICAgICBkb250RG9UaGlzT2JzZXJ2YWJsZS5udW0xID0gMztcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkb250RG9UaGlzLm51bTEgPT09IDEsICdPcmlnaW5hbCBvYmplY3QgaXMgbm90IGFmZmVjdGVkJyk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlMiA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoeyBuYW1lOiBcIkRvZ1wiIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTMgPSBBcGlfMS5PYnNlcnZhYmxlUHJveHkucHJveGltYXRlKHsgbmFtZTogXCJDYXRcIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU0ID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZSh7IG5hbWU6IFwiQ2FjdHVzXCIgfSk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhhcmdzLCBpZCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0QXJlYScpLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChgSSBhbSAke3RoaXMubmFtZX0uIEV2ZW50IHZhbHVlOiAke2FyZ3MubmV3VmFsdWV9YCwgeyBpZDogXCJmb3J3YXJkVGVzdFwiICsgaWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzc2luZyBhcm91bmQgXCJ0aGlzXCIgaW4gamF2YXNjcmlwdCBpcyBibG9vZHkgYW5ub3lpbmcuXG4gICAgICAgICAgICAvLyBCdXQgdXN1YWxseSB3ZSBhcmVuJ3QgbGlua2luZyBkaXJlY3RseSB0byB0aGUgb2JzZXJ2YWJsZSBhbmQgdHJ5aW5nIHRvIG1hbnVhbGx5IHNlbmQgaW4gZW5jbG9zZWQgdmFsdWVzLlxuICAgICAgICAgICAgLy8gTm90IFRISVMgcmVkdW5kYW50ICh1c2luZyBjYWxsKCkpIGFsbCB0aGUgdGltZS5cbiAgICAgICAgICAgIG9ic2VydmFibGUyLnN1YnNjcmliZShhcmdzID0+IGNhbGxiYWNrLmNhbGwob2JzZXJ2YWJsZTIsIGFyZ3MsIDEpLCBvYnNlcnZhYmxlMik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMy5zdWJzY3JpYmUoYXJncyA9PiBjYWxsYmFjay5jYWxsKG9ic2VydmFibGUzLCBhcmdzLCAyKSwgb2JzZXJ2YWJsZTMpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTQuc3Vic2NyaWJlKGFyZ3MgPT4gY2FsbGJhY2suY2FsbChvYnNlcnZhYmxlNCwgYXJncywgMyksIG9ic2VydmFibGU0KTtcbiAgICAgICAgICAgIG9ic2VydmFibGUzLnNlbmRDaGFuZ2VFdmVudHNUbyhvYnNlcnZhYmxlMik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMy5yZWNlaXZlQ2hhbmdlRXZlbnRzRnJvbShvYnNlcnZhYmxlNCk7XG4gICAgICAgICAgICAvLyA0IGlzIHNlbmRpbmcgdG8gMywgd2hpY2ggaXMgc2VuZGluZyB0byAyLiBTbyBtb2RpZnlpbmcgNCB3aWxsIHRyaWdnZXIgYWxsIDMgY2FsbGJhY2tzLlxuICAgICAgICAgICAgb2JzZXJ2YWJsZTQubmFtZSA9IFwiQm9hIENvbnN0cmljdG9yXCI7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvcndhcmRUZXN0MScpLmlubmVySFRNTCA9PT0gJ0kgYW0gRG9nLiBFdmVudCB2YWx1ZTogQm9hIENvbnN0cmljdG9yJywgJ1R3byBzdWJzY3JpYmUgbGF5ZXJzIGRlZXAgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDInKS5pbm5lckhUTUwgPT09ICdJIGFtIENhdC4gRXZlbnQgdmFsdWU6IEJvYSBDb25zdHJpY3RvcicsICdPbmUgc3Vic2NyaWJlIGxheWVyIGRlZXAgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDMnKS5pbm5lckhUTUwgPT09ICdJIGFtIEJvYSBDb25zdHJpY3Rvci4gRXZlbnQgdmFsdWU6IEJvYSBDb25zdHJpY3RvcicsICdPcmlnaW5hbCBzdWJzY3JpYmUgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgLy8gS2V5IGRlbGV0aW9ucyBhcmUgYWxzbyB0cmFwcGVkXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlNSA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoeyB3b3JsZDogJ01hcnMnIH0pO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTUuc3Vic2NyaWJlKGFyZ3MgPT4gdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYFR5cGU6JHthcmdzLnR5cGV9LiBLZXk6JHthcmdzLnByb3BlcnR5TmFtZX0uYCwgeyBpZDogXCJvYnNlcnZhYmxlNVwiIH0pKSk7XG4gICAgICAgICAgICBkZWxldGUgb2JzZXJ2YWJsZTUud29ybGQ7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29ic2VydmFibGU1JykuaW5uZXJIVE1MID09PSAnVHlwZTpkZWxldGUuIEtleTp3b3JsZC4nLCAnUHJveHkgcmFpc2VzIGV2ZW50IG9uIGRlbGV0ZScpKTtcbiAgICAgICAgICAgIC8vIEEgbW9yZSBnZW5lcmFsaXplZCBwcm94aW1hdGUgZnVuY3Rpb24gY2FuIGFsbG93IHlvdSB0byB0cmFjayBhcmJpdHJhcnkgbWV0aG9kIGNhbGxzIG9uIGFuIG9iamVjdC4gVGhpcyBsZXRzIHlvdSB0cmFjayBjaGFuZ2VzXG4gICAgICAgICAgICAvLyB0byBpbm5lciBvYmplY3RzIHdpdGhvdXQgaGF2aW5nIHRvIHByb3h5IHRob3NlIGlubmVyIG9iamVjdHMuXG4gICAgICAgICAgICBjbGFzcyBDb21wbGV4T2JqZWN0IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXJyID0gWzEsIDIsIDMsIDQsIDVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGQodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Fyci5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcnJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTYgPSBBcGlfMS5PYnNlcnZhYmxlUHJveHkucHJveGltYXRlT2JqZWN0KG5ldyBDb21wbGV4T2JqZWN0KCksIGZhbHNlLCBmYWxzZSwgWydhZGQnXSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNi5zdWJzY3JpYmUoYXJncyA9PiB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLnBhcmFncmFwaChgVHlwZToke2FyZ3MudHlwZX0uIEtleToke2FyZ3MucHJvcGVydHlOYW1lfS4gQXJnczoke0pTT04uc3RyaW5naWZ5KGFyZ3MubmV3VmFsdWUpfS5gLCB7IGNsYXNzTmFtZTogJ29ic2VydmFibGU2LW5vJyB9KSkpO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTZhID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZU9iamVjdChuZXcgQ29tcGxleE9iamVjdCgpLCBmYWxzZSwgZmFsc2UsIFsnYWRkJ10pO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTZhLnN1YnNjcmliZShhcmdzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBUeXBlOiR7YXJncy50eXBlfS4gS2V5OiR7YXJncy5wcm9wZXJ0eU5hbWV9LiBBcmdzOiR7SlNPTi5zdHJpbmdpZnkoYXJncy5uZXdWYWx1ZSl9LmAsIHsgY2xhc3NOYW1lOiAnb2JzZXJ2YWJsZTYteWVzJyB9KSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGU2LmdldCg0KSA9PT0gNSwgJ2dldCBtZXRob2QgY2FsbCByZXR1cm5zIGV4cGVjdGVkIHZhbHVlJyk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLm9ic2VydmFibGU2LW5vJykgPT09IG51bGwsIFwiU3Vic2NyaWJlIG5vdCBjYWxsZWQgb24gdW53YXRjaGVkIG1ldGhvZFwiKSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNmEuYWRkKDYpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5vYnNlcnZhYmxlNi15ZXMnKS5pbm5lckhUTUwgPT09IFwiVHlwZTpjYWxsLiBLZXk6YWRkLiBBcmdzOls2XS5cIiwgXCJTdWJzY3JpYmUgY2FsbGVkIG9uIHdhdGNoZWQgbWV0aG9kXCIpKTtcbiAgICAgICAgICAgIC8vIEFycmF5cyBhcmUgdmVyeSBzaW1wbGUsIGFuZCBlYWNoIG1ldGhvZCB0aGF0IG1vZGlmaWVzIHRoZSBhcnJheSB0cmlnZ2VycyBhbiBldmVudC5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBzb21ldGhpbmcgdGhhdCBtb2RpZmllcyBhbiBpdGVtIGNvbnRhaW5lZCBpbnNpZGUgdGhlIGFycmF5LCB3aXRob3V0IG1vZGlmaW5nIHRoZSBhcnJheSBpdHNlbGYsXG4gICAgICAgICAgICAvLyBpcyBub3QgdHJhcHBlZC4gVG8gaGFuZGxlIHRoaXMgY2FzZSwgeW91IG11c3QgbG9hZCB0aGUgYXJyYXkgd2l0aCBvYnNlcnZhYmxlIGNoaWxkcmVuLCBncmFuZGNoaWxkcmVuLCBldGMsIG9yXG4gICAgICAgICAgICAvLyB1c2UgYSBzdGF0ZSBvYnNlcnZhYmxlLlxuICAgICAgICAgICAgY29uc3QgYXJyID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZShbJ2EnLCAnYicsICdjJ10pO1xuICAgICAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgICAgICBhcnIuc3Vic2NyaWJlKGFyZ3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBPcGVyYXRpb246JHthcmdzLnR5cGV9ICR7YXJncy5wcm9wZXJ0eU5hbWV9LiA8c3Bhbj5Ob3c6WyR7YXJncy5uZXdWYWx1ZX1dPC9zcGFuPmAsIHsgaWQ6ICdhcnJheScgKyBpZHggfSkpO1xuICAgICAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcnJbM10gPSAnZCc7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoMCwgJ2EsYixjLGQnLCAnc2V0JykpO1xuICAgICAgICAgICAgYXJyLmxlbmd0aCA9IDM7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoMSwgJ2EsYixjJywgJ2xlbmd0aCcpKTtcbiAgICAgICAgICAgIGFyci5wdXNoKCdEJyk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoMiwgJ2EsYixjLEQnLCAncHVzaCcpKTtcbiAgICAgICAgICAgIGFyci5zcGxpY2UoMSwgMSwgJ0InKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IGFycmF5VGVzdCgzLCAnYSxCLGMsRCcsICdzcGxpY2UnKSk7XG4gICAgICAgICAgICBhcnIuc2hpZnQoKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IGFycmF5VGVzdCg0LCAnQixjLEQnLCAnc2hpZnQnKSk7XG4gICAgICAgICAgICBhcnIudW5zaGlmdCgnQScpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXJyYXlUZXN0KDUsICdBLEIsYyxEJywgJ3Vuc2hpZnQnKSk7XG4gICAgICAgICAgICBhcnIucmV2ZXJzZSgpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXJyYXlUZXN0KDYsICdELGMsQixBJywgJ3JldmVyc2UnKSk7XG4gICAgICAgICAgICBhcnIucG9wKCk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoNywgJ0QsYyxCJywgJ3BvcCcpKTtcbiAgICAgICAgICAgIGFyci5zb3J0KCk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoOCwgJ0IsRCxjJywgJ3NvcnQnKSk7XG4gICAgICAgICAgICBhcnIuZmlsbCgnUScsIDAsIDIpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXJyYXlUZXN0KDksICdRLFEsYycsICdmaWxsJykpO1xuICAgICAgICAgICAgYXJyLmNvcHlXaXRoaW4oMCwgMik7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhcnJheVRlc3QoMTAsICdjLFEsYycsICdjb3B5V2l0aGluJykpO1xuICAgICAgICAgICAgZGVsZXRlIGFyclswXTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IGFycmF5VGVzdCgxMSwgJyxRLGMnLCAnZGVsZXRlJykpO1xuICAgICAgICAgICAgZnVuY3Rpb24gYXJyYXlUZXN0KGludCwgZXhwZWN0ZWQsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgI2FycmF5JHtpbnR9IHNwYW5gKS5pbm5lckhUTUwgPT09IGBOb3c6WyR7ZXhwZWN0ZWR9XWAsIGBBcnJheSAke25hbWV9IHRyaWdnZXJzIG9ic2VydmFibGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRvIG1ha2UgYSBwcm94aWVkIG9ic2VydmFibGUgc3luY2hyb25vdXMsIHNldCBkaXNhYmxlQXN5bmMgdG8gdHJ1ZS4gVGhpcyB3aWxsIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIHRoZSBjYWxsYmFja3MgaW4gYSBzeW5jaHJvbm91cyB3YXkuIE5vdGUgaW4gdGhpcyBleGFtcGxlIGhvdyB0aGUgY3VycmVudCB2YWx1ZSBtYXRjaGVzXG4gICAgICAgICAgICAvLyB0aGUgbmV3VmFsdWUsIHdoZW4gaWYgdGhpcyB3ZXJlIGFzeW5jLCB0aGUgY3VycmVudCB2YWx1ZSB3b3VsZCBhbHdheXMgYmUgUmVtdXMuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgd2hlbiBhIHByb3h5IGlzIHN5bmNocm9ub3VzLCBzdWJzY3JpYmUoKSBkb2VzIG5vdCByZXR1cm4gYSBwcm9taXNlIChvYnZpb3VzbHkpIGJ1dFxuICAgICAgICAgICAgLy8gaW5zdGVhZCByZXR1cm5zIHVuZGVmaW5lZC4gU3luY2hyb25vdXMgc3Vic2NyaWJlIGlzIG5vdCB0aGVuYWJsZS5cbiAgICAgICAgICAgIGxldCBpZHgyID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU3ID0gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZSh7IG5hbWU6ICdXb3JsZCcgfSwgdHJ1ZSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYE5ldzoke2FyZ3MubmV3VmFsdWV9LiBDdXJyZW50OiR7b2JzZXJ2YWJsZTcubmFtZX0uYCwgeyBpZDogXCJzeW5jT2JzZXJ2YWJsZVwiICsgaWR4MiB9KSk7XG4gICAgICAgICAgICAgICAgaWR4MiArPSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy5uYW1lID0gJ1Z1bGNhbic7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNPYnNlcnZhYmxlMCcpLmlubmVySFRNTCA9PT0gJ05ldzpWdWxjYW4uIEN1cnJlbnQ6VnVsY2FuLicsICdDYWxsYmFjayBjYWxsZWQgc3luY2hyb25vdXNseSAxJyk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy5uYW1lID0gJ1JvbXVsdXMnO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jT2JzZXJ2YWJsZTEnKS5pbm5lckhUTUwgPT09ICdOZXc6Um9tdWx1cy4gQ3VycmVudDpSb211bHVzLicsICdDYWxsYmFjayBjYWxsZWQgc3luY2hyb25vdXNseSAyJyk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy5uYW1lID0gJ1JlbXVzJztcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3luY09ic2VydmFibGUyJykuaW5uZXJIVE1MID09PSAnTmV3OlJlbXVzLiBDdXJyZW50OlJlbXVzLicsICdDYWxsYmFjayBjYWxsZWQgc3luY2hyb25vdXNseSAzJyk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlOCA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoeyBuYW1lOiAnRm9vJyB9LCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlOC5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYE5ldzoke2FyZ3MubmV3VmFsdWV9LmAsIHsgaWQ6IFwibm9vcFwiIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTgubmFtZSA9ICdGb28nO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub29wJykgPT09IG51bGwsICdObyB1cGRhdGUgd2hlbiB2YWx1ZSBub3QgY2hhbmdlZCBpZiBvbmx5V2hlbkNoYW5nZWQgc2V0JykpO1xuICAgICAgICAgICAgY29uc3QgYXJyMiA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoWzEsIDIsIDNdLCB0cnVlKTtcbiAgICAgICAgICAgIGFycjIuc3Vic2NyaWJlKGFyZ3MgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBOZXc6JHthcmdzLm5ld1ZhbHVlLmxlbmd0aH0uIEN1cnJlbnQ6JHthcnIyLmxlbmd0aH0uYCwgeyBpZDogXCJzeW5jT2JzZXJ2YWJsZVwiICsgaWR4MiB9KSk7XG4gICAgICAgICAgICAgICAgaWR4MiArPSAxO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhcnIyLnB1c2goNCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNPYnNlcnZhYmxlMycpLmlubmVySFRNTCA9PT0gJ05ldzo0LiBDdXJyZW50OjQuJywgJ0NhbGxiYWNrIGNhbGxlZCBzeW5jaHJvbm91c2x5IChhcnJheSAxKScpO1xuICAgICAgICAgICAgYXJyMi5wdXNoKDUpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzeW5jT2JzZXJ2YWJsZTQnKS5pbm5lckhUTUwgPT09ICdOZXc6NS4gQ3VycmVudDo1LicsICdDYWxsYmFjayBjYWxsZWQgc3luY2hyb25vdXNseSAoYXJyYXkgMiknKTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFN5bmMgdGVzdHMgc3VjY2VlZGVkYCk7XG4gICAgICAgICAgICB0aGlzLmxvZygnU3RhcnRpbmcgYXN5bmMgdGVzdHMnKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IEFzeW5jIHRlc3RzIHN1Y2NlZWRlZGApKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdBU1lOQyBURVNUUyBGQUlMRUQ6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDA3ID0gVGVzdDAwNztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ09ic2VydmFibGUgU3RhdGUnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb25IdG1sOiBgPHA+VGhlIHN0YXRlIG9ic2VydmFibGUsIGFuIGlkZWEgSSBzdG9sZSBmcm9tIFJlYWN0LCBzb2x2ZXMgb25lIG9mIHRoZSBiYXNpYyBwcm9ibGVtcyBvZlxuICAgICAgICAgICAgb2JzZXJ2YWJsZSBvYmplY3RzIHdoaWNoIG1heSBoYXZlIHJlZmVyZW5jZXMsIHVzaW5nIGEgc29tZXdoYXQgY2x1bmt5IGNvbnZlbnRpb24uIFRoaXMgY2FuIGJlIGEgZmFpciB0cmFkZW9mZi5cbiAgICAgICAgICAgIFRoZSB0cmFkZSBpcyBzdWNoOiBieSBvbmx5IHJlYWRpbmcgdGhlIHN0YXRlIHVzaW5nIGRlc2lnbmF0ZWQgbWV0aG9kcyAodmFsdWUsIGdldFN0YXRlLCBnZXRWYWx1ZSwgZ2V0U2FmZVZhbHVlKVxuICAgICAgICAgICAgYW5kIG9ubHkgd3JpdGluZyB0byB0aGUgc3RhdGUgdXNpbmcgc2V0U3RhdGUoKSwgeW91IGNhbiBiZSBzdXJlIHRoYXQgY2hhbmdlcyB0byBhbnkgcmVmZXJlbmNlZCBvYmplY3QgYXJlIHRyYXBwZWQuPC9wPlxuXG4gICAgICAgICAgICA8cD5Gb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cywgbm9ybWFsbHkgdG8gcmFpc2UgYW4gZXZlbnQgd2hlbiBhIHByb3BlcnR5IG9mXG4gICAgICAgICAgICBvbmUgb2YgdGhvc2Ugb2JqZWN0cyBpcyBtb2RpZmllZCwgdGhlbiB0aGF0IG9iamVjdCBtdXN0IGJlIG9ic2VydmFibGUuIFRoYXQgY2FuJ3QgYWx3YXlzIGJlIGRvbmUsIGVzcGVjaWFsbHkgaWZcbiAgICAgICAgICAgIHlvdSBkb24ndCBjb250cm9sIHRoZSBzb3VyY2Ugb2YgdGhlIHJlZmVyZW5jZWQgb2JqZWN0LiBCdXQgd2hlbiBldmVyeSBjaGFuZ2UgaGFzIHRvIGdvIHRocm91Z2ggc2V0U3RhdGUoKSxcbiAgICAgICAgICAgIGl0IGNhbiBiZSB0cmFwcGVkIHRoZXJlLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhlIHN0YXRlIGluIGEgc3RhdGUgb2JzZXJ2YWJsZSBpcyBhbiBpbW11dGFibGUgY2xvbmUgb2YgdGhlIGRhdGEgcHJvdmlkZWQuIEV2ZXJ5IHRpbWUgeW91IGdldCB0aGUgb2JqZWN0IG9yXG4gICAgICAgICAgICB3cml0ZSB0byB0aGUgb2JqZWN0LCBpdCBpcyBjbG9uZWQuIEluIHRlcm1zIG9mIHBlcmZvcm1hbmNlLCBpdCdzIHByb2JhYmx5IGV2ZW4gc2xvd2VyIHRoYW4gYSBwcm94eSwgYnV0IGluIG1vc3RcbiAgICAgICAgICAgIHVzZSBjYXNlcyB5b3Ugd29uJ3QgZXZlbiBub3RpY2UuPC9wPlxuXG4gICAgICAgICAgICA8cD5UaGUgbWV0aG9kcyBnZXRWYWx1ZShrZXkpIGFuZCBnZXRTYWZlVmFsdWUoa2V5KSByZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBrZXkgeW91IHByb3ZpZGUuIFRoZSAudmFsdWUgZ2V0dGVyXG4gICAgICAgICAgICBhbmQgZ2V0U3RhdGUoKSBtZXRob2QgcmV0dXJuIHRoZSBlbnRpcmUgc3RhdGUuPC9wPlxuXG4gICAgICAgICAgICA8cD5UaGUgc2V0dGVyIC52YWx1ZSByZXBsYWNlcyB0aGUgZW50aXJlIHN0YXRlLCBhcyBkb2VzIHRoZSBzZXRTdGF0ZSh2YWwsIHRydWUpIG1ldGhvZCB3aGVuIG92ZXJ3cml0ZUFsbCBpcyB0cnVlLlxuICAgICAgICAgICAgVGhlIG1ldGhvZCBzZXRTdGF0ZSggeyBrZXk6IHZhbCB9ICkgbWV0aG9kIHJlcGxhY2VzIG9ubHkgdGhlIGtleXMgeW91IHByb3ZpZGUsIGFuZCB0aGUgbWV0aG9kIHNldFN0YXRlKCBjYWxsYmFjayApXG4gICAgICAgICAgICBtZXRob2QgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIHRoZSB2YWx1ZS4gIEluIGFsbCBjYXNlcywgc2V0U3RhdGUgcmV0dXJucyB0aGUgYmVmb3JlIGFuZCBhZnRlciB2YWx1ZXMgYXNcbiAgICAgICAgICAgIHsgb2xkVmFsdWUsIG5ld1ZhbHVlIH0uICBXaGVuIGEgY2FsbGJhY2sgaXMgdXNlZCwgYSAncmV0dXJuVmFsdWUnIGtleSByZXR1cm5zIGFueSB2YWx1ZSByZXR1cm5lZCBmcm9tIHRoZSBjYWxsYmFjay48L3A+XG5cbiAgICAgICAgICAgIDxoMj5XYXJuaW5nPC9oMj5cbiAgICAgICAgICAgIDxwPlRlc3RzIGFyZSBhc3luYyBhbmQgd2lsbCBrZWVwIHJ1bm5pbmcuIFdhaXQgZm9yIHRlc3RzIHRvIGNvbXBsZXRlIGJlZm9yZSBsZWF2aW5nIHBhZ2UuPC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDA4IGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGhpcyBzZWVtcyB0byBiZSB3b3JraW5nIG91dCB3ZWxsXG4gICAgICAgICAgICBjb25zdCBhc3luY0Fzc2VydHMgPSBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKEFwaV8xLmRlbGF5KDEwMDApLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgcGxhY2U6ICdtb3RlbHMnLFxuICAgICAgICAgICAgICAgIGhvd01hbnk6IDIwMCxcbiAgICAgICAgICAgICAgICBoZWFkZXI6ICc8aDE+MjAwIE1vdGVsczwvaDE+JyxcbiAgICAgICAgICAgICAgICBjYXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLmhvd01hbnl9ICR7dGhpcy5wbGFjZX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgZ2V0dGVyKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYXBzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2b2ljZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnRmxvJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdFZGRpZScgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnSmltbWllIENhcmwgQmxhY2snIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ0ppbSBQb25zJyB9XG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIERlbW9uc3RyYXRpbmcgc2V0U3RhdGVcbiAgICAgICAgICAgIHRlc3RPYmplY3QueWVhciA9IDE5NzE7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlMSA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlU3RhdGUodGVzdE9iamVjdCk7XG4gICAgICAgICAgICAvLyBCb3RoIGZvciBsZWdpYmlsaXR5IGFuZCB0byBhdm9pZCBwdWxsaW5nIHRoZSB2YWx1ZSA0IHRpbWVzXG4gICAgICAgICAgICBjb25zdCB2MSA9IG9ic2VydmFibGUxLnZhbHVlO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHYxLnBsYWNlID09PSAnbW90ZWxzJyAmJiB2MS5ob3dNYW55ID09PSAyMDAgJiYgdjEudm9pY2VzLmxlbmd0aCA9PT0gNCwgJ3ZhbHVlIHNob3VsZCByZXR1cm4gdGhlIG9yaWdpbmFsIGRhdGEnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh2MSAhPT0gdGVzdE9iamVjdCwgJ3ZhbHVlIHNob3VsZCBub3QgcmV0dXJuIHRoZSBhY3R1YWwgcmVmZXJlbmNlZCBvYmplY3QnKTtcbiAgICAgICAgICAgIGNvbnN0IHYxYiA9IG9ic2VydmFibGUxLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodjFiLnBsYWNlID09PSAnbW90ZWxzJyAmJiB2MWIuaG93TWFueSA9PT0gMjAwICYmIHYxYi52b2ljZXMubGVuZ3RoID09PSA0LCAnZ2V0U3RhdGUgc2hvdWxkIHJldHVybiB0aGUgb3JpZ2luYWwgZGF0YScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGUxLmdldFNhZmVWYWx1ZSgnaGVhZGVyJykgPT09ICcmbHQ7aDEmZ3Q7MjAwIE1vdGVscyZsdDsmI3gyRjtoMSZndDsnLCAnZ2V0U2FmZVZhbHVlIGdldHMgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBpZiBhIHN0cmluZycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGUxLmdldFZhbHVlKCdoZWFkZXInKSA9PT0gJzxoMT4yMDAgTW90ZWxzPC9oMT4nLCAnZ2V0VmFsdWUgaXMgbm90IEhUTUwtZXNjYXBlZCcpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFycmF5LmlzQXJyYXkob2JzZXJ2YWJsZTEuZ2V0VmFsdWUoJ3ZvaWNlcycpKSwgJ2dldFZhbHVlIGdldHMgdGhlIHZhbHVlIGhhdmluZyB0aGUgc3VwcGxpZWQga2V5Jyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTEudmFsdWUuY2FwcygpID09PSAnMjAwIE1PVEVMUycsICdMb2dpYyBzdWNoIGFzIG1ldGhvZHMgY2FuIGJlIHN0b3JlZC9jbG9uZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlMS52YWx1ZS5nZXR0ZXIgPT09ICcyMDAgTU9URUxTJywgJ0N1c3RvbSBnZXR0ZXJzIGNhbiBiZSBzdG9yZWQvY2xvbmVkLCB0aG91Z2ggdGhleSBzdWNrJyk7XG4gICAgICAgICAgICAvLyBZb3UgY2FuIHNldCBzaW5nbGUga2V5cyB1c2luZyBhIHBhcnRpYWwgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkMWEgPSBvYnNlcnZhYmxlMS5zZXRTdGF0ZSh7IHBsYWNlOiAnTW90ZWxzJyB9KTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlMS52YWx1ZS5wbGFjZSA9PT0gJ01vdGVscycsICdzZXRTdGF0ZSB1cGRhdGVzIHRoZSBrZXkgcHJvdmlkZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZhYmxlMS52YWx1ZS5ob3dNYW55ID09PSAyMDAsICdzZXRTdGF0ZSBsZWF2ZXMgb3RoZXIga2V5cyBhcy1pcycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHVwZGF0ZWQxYS5vbGRWYWx1ZS5wbGFjZSA9PT0gJ21vdGVscycgJiYgdXBkYXRlZDFhLm5ld1ZhbHVlLnBsYWNlID09PSAnTW90ZWxzJywgJ3NldFN0YXRlIHJldHVybnMgb2xkIGFuZCBuZXcgdmFsdWVzJyk7XG4gICAgICAgICAgICAvLyBZb3UgY2FuIGFsc28gdXBkYXRlIHVzaW5nIGEgY2FsbGJhY2ssIHdoaWNoIGlzIGdvb2Qgd2hlbiB5b3UgbmVlZCB0byBkbyBpbmNyZW1lbnRhbCBtb2RpZmljYXRpb25zLlxuICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCBpcyBub3QgdmVyeSBnb29kIGFib3V0IHRoaXMsIHRob3VnaC4gSXQgZm9yZ2V0cyB0aGUgdHlwZSBvZiB0aGUgc3RhdGUgb2JqZWN0IGFuZCBmb3JjZXNcbiAgICAgICAgICAgIC8vIGEgdmVyYm9zZSBjYXN0LlxuICAgICAgICAgICAgY29uc3QgdXBkYXRlZDFiID0gb2JzZXJ2YWJsZTEuc2V0U3RhdGUoKHZhbCkgPT4gdmFsLmhvd01hbnkgKz0gMSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTEuZ2V0VmFsdWUoJ2hvd01hbnknKSA9PT0gMjAxLCAnQ2FsbGJhY2sgd2FzIGV4ZWN1dGVkJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodXBkYXRlZDFiLm9sZFZhbHVlLmhvd01hbnkgPT09IDIwMCAmJiB1cGRhdGVkMWIubmV3VmFsdWUuaG93TWFueSA9PT0gMjAxICYmIHVwZGF0ZWQxYi5yZXR1cm5WYWx1ZSA9PT0gMjAxLCAnc2V0U3RhdGUgcmV0dXJucyBvbGQsIG5ldywgYW5kIHJldHVybiB2YWx1ZXMgZm9yIGNhbGxiYWNrIGlucHV0Jyk7XG4gICAgICAgICAgICAvLyBXaGVuIHNldFN0YXRlIGlzIGNhbGxlZCB3aXRoIG92ZXJ3cml0ZUFsbCBzZXQgdG8gdHJ1ZSwgb3Igd2hlbiB1c2luZyB0aGUgc2V0dGVyLCB0aGUgZW50aXJlIG9iamVjdCBpcyByZXBsYWNlZC5cbiAgICAgICAgICAgIG9ic2VydmFibGUxLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwbGFjZTogJ2dvcmUgbW90ZWwnLFxuICAgICAgICAgICAgICAgIGhvd01hbnk6IDEsXG4gICAgICAgICAgICAgICAgaGVhZGVyOiAnPGgxPkdvcmUgTW90ZWw8L2gxPicsXG4gICAgICAgICAgICAgICAgY2FwczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5ob3dNYW55fSAke3RoaXMucGxhY2V9YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGdldHRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FwcygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdm9pY2VzOiBbXVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTEudmFsdWUucGxhY2UgPT09ICdnb3JlIG1vdGVsJywgJ3NldFN0YXRlIHdpdGggYW4gZW50aXJlIG9iamVjdCcpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGUxLnZhbHVlLnllYXIgPT09IHVuZGVmaW5lZCwgJ3NldFN0YXRlIHdpdGggb3ZlcndyaXRlQWxsIHRydWUgcmVwbGFjZXMgZXZlcnl0aGluZywgZXZlbiB1bmxpc3RlZCBwcm9wZXJ0aWVzJyk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMS52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICBwbGFjZTogJ2Z1Z2l0aXZlIG1vdGVsJyxcbiAgICAgICAgICAgICAgICBob3dNYW55OiAxLFxuICAgICAgICAgICAgICAgIGhlYWRlcjogJzxoMT5GdWdpdGl2ZSBNb3RlbDwvaDE+JyxcbiAgICAgICAgICAgICAgICBjYXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBsYWNlfWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBnZXR0ZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhcHMoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHZvaWNlczogW1xuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdHdXkgR2FydmV5JyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdDcmFpZyBQb3R0ZXInIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ01hcmsgUG90dGVyJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdQZXRlIFR1cm5lcicgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTEudmFsdWUucGxhY2UgPT09ICdmdWdpdGl2ZSBtb3RlbCcsICd2YWx1ZSBzZXR0ZXInKTtcbiAgICAgICAgICAgIC8vIFJlbWVtYmVyLCB2YWx1ZSBpcyBhIGNsb25lIG9mIHRoZSBpbnRlcm5hbCBzdGF0ZS4gWW91IGNhbm5vdCB1c2UgaXQgdG8gbW9kaWZ5IHRoZSBzdGF0ZS5cbiAgICAgICAgICAgIG9ic2VydmFibGUxLnZhbHVlLmhvd01hbnkgPSAxMDAwO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGUxLnZhbHVlLmhvd01hbnkgPT09IDEsICdJbnRlcm5hbCBzdGF0ZSBpcyByZWFkLW9ubHknKTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUyID0gbmV3IEFwaV8xLk9ic2VydmFibGVTdGF0ZSh0ZXN0T2JqZWN0KTtcbiAgICAgICAgICAgIG9ic2VydmFibGUyLnN1YnNjcmliZShhcmdzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBOZXc6JHthcmdzLm5ld1ZhbHVlLmhvd01hbnl9LiBPbGQ6JHthcmdzLm9sZFZhbHVlLmhvd01hbnl9LmAsIHsgaWQ6IFwib2JzMnRlc3RcIiArIGFyZ3Mub2xkVmFsdWUuaG93TWFueSB9KSkpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTIuc2V0U3RhdGUoeyBob3dNYW55OiAzMDAgfSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlMi5zZXRTdGF0ZSh7IGhvd01hbnk6IDQwMCB9KTtcbiAgICAgICAgICAgIG9ic2VydmFibGUyLnNldFN0YXRlKChwcmV2KSA9PiBwcmV2Lmhvd01hbnkgPSBwcmV2Lmhvd01hbnkgLyAyKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb2JzMnRlc3QyMDAnKS5pbm5lckhUTUwgPT09ICdOZXc6MzAwLiBPbGQ6MjAwLicsICdDYWxsYmFjayAxIGV4ZWN1dGVkIHdpdGggY29ycmVjdCBhcmd1bWVudHMnKSk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29iczJ0ZXN0MzAwJykuaW5uZXJIVE1MID09PSAnTmV3OjQwMC4gT2xkOjMwMC4nLCAnQ2FsbGJhY2sgMiBleGVjdXRlZCB3aXRoIGNvcnJlY3QgYXJndW1lbnRzJykpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvYnMydGVzdDQwMCcpLmlubmVySFRNTCA9PT0gJ05ldzoyMDAuIE9sZDo0MDAuJywgJ0NhbGxiYWNrIDMgZXhlY3V0ZWQgd2l0aCBjb3JyZWN0IGFyZ3VtZW50cycpKTtcbiAgICAgICAgICAgIC8vIEFuZCBub3csIHRvIGRlbW9uc3RyYXRlIHRoZSByZWFzb24gdGhlIHN0YXRlIG9ic2VydmFibGUgZXhpc3RzLiBUaGUgZm9sbG93aW5nIHRlc3Qgd291bGQgdGFrZSBhIGJpdCBtb3JlIHdvcmsgdG9cbiAgICAgICAgICAgIC8vIGdldCBmdW5jdGlvbmluZyB1c2luZyBvcmRpbmFyeSBvYnNlcnZhYmxlcy4gVm9pY2VzIHdvdWxkIG5lZWQgdG8gYmUgYW4gYXJyYXkgb2Ygb2JzZXJ2YWJsZXMsIG5vdCBzaW1wbGUgb2JqZWN0cy5cbiAgICAgICAgICAgIC8vIFdlJ2xsIGFsc28gZGVtb25zdHJhdGUgdGhlIGNsb25pbmcgb2YgYSBzdGF0ZSBvYnNlcnZhYmxlLlxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTMgPSBuZXcgQXBpXzEuT2JzZXJ2YWJsZVN0YXRlKG9ic2VydmFibGUyKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUzLnN1YnNjcmliZShhcmdzID0+IHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGBWb2ljZXM6JHthcmdzLm5ld1ZhbHVlLnZvaWNlcy5tYXAoKG0pID0+IG0ubmFtZSkuam9pbignLCAnKX1gLCB7IGlkOiBcIm9iczN0ZXN0XCIgfSkpKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUzLnNldFN0YXRlKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICBvYmoudm9pY2VzWzBdLm5hbWUgPSAnTWFyayBWb2xtYW4nO1xuICAgICAgICAgICAgICAgIG9iai52b2ljZXNbMV0ubmFtZSA9ICdIb3dhcmQgS2F5bGFuJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdvYnMzdGVzdCcpLmlubmVySFRNTCA9PT0gJ1ZvaWNlczpNYXJrIFZvbG1hbiwgSG93YXJkIEtheWxhbiwgSmltbWllIENhcmwgQmxhY2ssIEppbSBQb25zJywgJ0NhbGxiYWNrIGV4ZWN1dGVkIHdpdGggbmVzdGVkIG1vZGlmaWNhdGlvbicpKTtcbiAgICAgICAgICAgIC8vIFRoZSBzYW1lIGZvcndhcmQvYnViYmxlIGV2ZW50cyBleGlzdCBhcyBvbiBvdGhlciBvYnNlcnZhYmxlc1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZTQgPSBuZXcgQXBpXzEuT2JzZXJ2YWJsZVN0YXRlKHsgbmFtZTogXCJEb2dcIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU1ID0gbmV3IEFwaV8xLk9ic2VydmFibGVTdGF0ZSh7IG5hbWU6IFwiQ2F0XCIgfSk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlNiA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlU3RhdGUoeyBuYW1lOiBcIkNhY3R1c1wiIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gY2FsbGJhY2soYXJncywgaWQpIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVzdEFyZWEnKS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYEkgYW0gJHt0aGlzLnZhbHVlLm5hbWV9LiBFdmVudCB2YWx1ZTogJHthcmdzLm5ld1ZhbHVlLm5hbWV9YCwgeyBpZDogXCJmb3J3YXJkVGVzdFwiICsgaWQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFzc2luZyBhcm91bmQgXCJ0aGlzXCIgaW4gamF2YXNjcmlwdCBpcyBibG9vZHkgYW5ub3lpbmcuXG4gICAgICAgICAgICBvYnNlcnZhYmxlNC5zdWJzY3JpYmUoYXJncyA9PiBjYWxsYmFjay5jYWxsKG9ic2VydmFibGU0LCBhcmdzLCAxKSwgb2JzZXJ2YWJsZTQpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTUuc3Vic2NyaWJlKGFyZ3MgPT4gY2FsbGJhY2suY2FsbChvYnNlcnZhYmxlNSwgYXJncywgMiksIG9ic2VydmFibGU1KTtcbiAgICAgICAgICAgIG9ic2VydmFibGU2LnN1YnNjcmliZShhcmdzID0+IGNhbGxiYWNrLmNhbGwob2JzZXJ2YWJsZTYsIGFyZ3MsIDMpLCBvYnNlcnZhYmxlNik7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNS5zZW5kQ2hhbmdlRXZlbnRzVG8ob2JzZXJ2YWJsZTQpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTUucmVjZWl2ZUNoYW5nZUV2ZW50c0Zyb20ob2JzZXJ2YWJsZTYpO1xuICAgICAgICAgICAgLy8gNCBpcyBzZW5kaW5nIHRvIDMsIHdoaWNoIGlzIHNlbmRpbmcgdG8gMi4gU28gbW9kaWZ5aW5nIDQgd2lsbCB0cmlnZ2VyIGFsbCAzIGNhbGxiYWNrcy5cbiAgICAgICAgICAgIG9ic2VydmFibGU2LnZhbHVlID0geyBuYW1lOiBcIkJvYSBDb25zdHJpY3RvclwiIH07XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZvcndhcmRUZXN0MScpLmlubmVySFRNTCA9PT0gJ0kgYW0gRG9nLiBFdmVudCB2YWx1ZTogQm9hIENvbnN0cmljdG9yJywgJ1R3byBzdWJzY3JpYmUgbGF5ZXJzIGRlZXAgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDInKS5pbm5lckhUTUwgPT09ICdJIGFtIENhdC4gRXZlbnQgdmFsdWU6IEJvYSBDb25zdHJpY3RvcicsICdPbmUgc3Vic2NyaWJlIGxheWVyIGRlZXAgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmb3J3YXJkVGVzdDMnKS5pbm5lckhUTUwgPT09ICdJIGFtIEJvYSBDb25zdHJpY3Rvci4gRXZlbnQgdmFsdWU6IEJvYSBDb25zdHJpY3RvcicsICdPcmlnaW5hbCBzdWJzY3JpYmUgc3VjY2VlZGVkJykpO1xuICAgICAgICAgICAgLy8gVG8gbWFrZSBhbiBvYnNlcnZhYmxlIHN5bmNocm9ub3VzLCBzZXQgZGlzYWJsZUFzeW5jIHRvIHRydWUuIFRoaXMgd2lsbCBleGVjdXRlIHRoZSBjYWxsYmFja3MgaW4gYSBzeW5jaHJvbm91cyB3YXkuIE5vdGVcbiAgICAgICAgICAgIC8vIGluIHRoaXMgZXhhbXBsZSBob3cgdGhlIGN1cnJlbnQgdmFsdWUgbWF0Y2hlcyB0aGUgbmV3VmFsdWUsIHdoZW4gaWYgdGhpcyB3ZXJlIGFzeW5jLCB0aGUgY3VycmVudCB2YWx1ZSB3b3VsZCBhbHdheXMgYmUgUmVtdXMuXG4gICAgICAgICAgICBsZXQgaWR4ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGU3ID0gbmV3IEFwaV8xLk9ic2VydmFibGVTdGF0ZSh7IG5hbWU6ICdXb3JsZCcgfSwgeyBkaXNhYmxlQXN5bmM6IHRydWUgfSk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy5zdWJzY3JpYmUoYXJncyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoYE5ldzoke2FyZ3MubmV3VmFsdWUubmFtZX0uIEN1cnJlbnQ6JHtvYnNlcnZhYmxlNy5nZXRTYWZlVmFsdWUoJ25hbWUnKX0uYCwgeyBpZDogXCJzeW5jT2JzZXJ2YWJsZVwiICsgaWR4IH0pKTtcbiAgICAgICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTcudmFsdWUgPSB7IG5hbWU6ICdWdWxjYW4nIH07XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNPYnNlcnZhYmxlMCcpLmlubmVySFRNTCA9PT0gJ05ldzpWdWxjYW4uIEN1cnJlbnQ6VnVsY2FuLicsICdDYWxsYmFjayBjYWxsZWQgc3luY2hyb25vdXNseSAxJyk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlNy52YWx1ZSA9IHsgbmFtZTogJ1JvbXVsdXMnIH07XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNPYnNlcnZhYmxlMScpLmlubmVySFRNTCA9PT0gJ05ldzpSb211bHVzLiBDdXJyZW50OlJvbXVsdXMuJywgJ0NhbGxiYWNrIGNhbGxlZCBzeW5jaHJvbm91c2x5IDInKTtcbiAgICAgICAgICAgIG9ic2VydmFibGU3LnZhbHVlID0geyBuYW1lOiAnUmVtdXMnIH07XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N5bmNPYnNlcnZhYmxlMicpLmlubmVySFRNTCA9PT0gJ05ldzpSZW11cy4gQ3VycmVudDpSZW11cy4nLCAnQ2FsbGJhY2sgY2FsbGVkIHN5bmNocm9ub3VzbHkgMycpO1xuICAgICAgICAgICAgLy8gVGhlIG9ic2VydmFibGUgb2JqZWN0IGNhbiBiZSBhIHByaW1pdGl2ZSBvYmplY3QuXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZhYmxlOCA9IG5ldyBBcGlfMS5PYnNlcnZhYmxlU3RhdGUoXCJXb3JsZFwiKTtcbiAgICAgICAgICAgIG9ic2VydmFibGU4LnZhbHVlID0gJ01hcnMnO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGU4LnZhbHVlID09PSAnTWFycycsICdTdGF0ZSBjYW4gYmUgYSBwcmltaXRpdmUgb2JqZWN0Jyk7XG4gICAgICAgICAgICAvLyBZb3UgY2FuIGNhbGwgZ2V0VmFsdWUoKSBhbmQgZ2V0U2F2ZVZhbHVlKCkgd2l0aCBubyBhcmdzLlxuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGU4LmdldFZhbHVlKCkgPT09ICdNYXJzJywgJ2dldFZhbHVlKCkgY2FsbGVkIHdpdGggbm8gYXJncyBmb3IgYSBwcmltaXRpdmUgb2JqZWN0Jyk7XG4gICAgICAgICAgICBvYnNlcnZhYmxlOC52YWx1ZSA9ICc8Pic7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTguZ2V0U2FmZVZhbHVlKCkgPT09ICcmbHQ7Jmd0OycsICdnZXRTYWZlVmFsdWUoKSBjYWxsZWQgd2l0aCBubyBhcmdzIGZvciBhIHByaW1pdGl2ZSBvYmplY3QnKTtcbiAgICAgICAgICAgIC8vIFNldFN0YXRlIGNhbiBiZSB1c2VkLCBpdCBjYW5ub3QgYmUgY2FsbGVkIHdpdGggZWl0aGVyIGEgcGFydGlhbCAocHJpbWl0aXZlcyBkb24ndCBoYXZlIHBhcnRpYWwgb2JqZWN0IHByb3BlcnRpZXMgdG8gc2V0KSBvclxuICAgICAgICAgICAgLy8gYSBtZXRob2QgKGl0IHdpbGwgZXhlY3V0ZSwgYnV0IHByaW1pdGl2ZXMgYXJlIGltbXV0YWJsZSBhbmQgbW9zdGx5IHZhbHVlIHR5cGVzLCBzbyBpZiB5b3UgcmVwbGFjZSB0aGVtLCBjaGFuZ2VzIGFyZSBsb3N0KS5cbiAgICAgICAgICAgIG9ic2VydmFibGU4LnNldFN0YXRlKCdKdXBpdGVyJywgdHJ1ZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQob2JzZXJ2YWJsZTguZ2V0VmFsdWUoKSA9PT0gJ0p1cGl0ZXInLCAnc2V0U3RhdGUoKSBjYWxsZWQgd2l0aCBvdmVyd3JpdGVBbGwgZm9yIGEgcHJpbWl0aXZlIG9iamVjdCcpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZTguc2V0U3RhdGUoJ1NhdHVybicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG9ic2VydmFibGU4LmdldFZhbHVlKCkgPT09ICdTYXR1cm4nLCAnT24gcHJpbWl0aXZlIHR5cGVzLCBvdmVyd3JpdGVBbGwgaXMgc2V0IGF1dG9tYXRpY2FsbHknKTtcbiAgICAgICAgICAgIHRoaXMubG9nKCdTdGFydGluZyBhc3luYyB0ZXN0cycpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gdGhpcy5sb2coYFRFU1QgJHt0aGlzLnZpZXdNb2RlbC50ZXN0TnVtYmVyfTogQXN5bmMgdGVzdHMgc3VjY2VlZGVkYCkpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ0FTWU5DIFRFU1RTIEZBSUxFRDogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5yZXNvbHZlKCk7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVEVTVCAke3RoaXMudmlld01vZGVsLnRlc3ROdW1iZXJ9OiBTeW5jIHRlc3RzIHN1Y2NlZWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiRVJST1I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGVzdDAwOCA9IFRlc3QwMDg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld1wiKTtcbmNvbnN0IFRlc3RDYXNlVmlld01vZGVsXzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdNb2RlbFwiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZXN0Vmlld01vZGVsIGV4dGVuZHMgVGVzdENhc2VWaWV3TW9kZWxfMS5UZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdDb21wb25lbnRzJyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uSHRtbDogYDxwPkEgY29tcG9uZW50IGlzIHRoZSBiYXNlIGNsYXNzIHRoYXQgaW1wbGVtZW50cyBJQ29udGVudCwgYW4gb2JqZWN0IHdob3NlIFwiY29udGVudFwiXG4gICAgICAgICAgICBwcm9wZXJ0eSBpcyBhbiBIVE1MRWxlbWVudCB0aGF0IGlzIHRoZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0IG9uIHRoZSBwYWdlLiBNb3N0IG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgaXMgbWFkZSB1cCBvZiBoZWxwZXJzIHRvIG1ha2UgY29uc3RydWN0aW9uIGVhc3kgYW5kIHRvIGFjY2VzcyBjb21tb24gZnVuY3Rpb25zLCBsaWtlIGlubmVySFRNTCwgd2l0aG91dFxuICAgICAgICAgICAgaGF2aW5nIHRvIHR5cGUgb2JqLmNvbnRlbnQuSFRNTC48L3A+XG5cbiAgICAgICAgICAgIDxoMj5Vc2FnZTwvaDI+XG4gICAgICAgICAgICA8cHJlPjxjb2RlPlxuICAgICAgICAgICAgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50PFRFbGVtZW50PiB7XG4gICAgICAgICAgICAgICAgY29udGVudDogVEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgZ2V0IGlkKCk6IHN0cmluZztcbiAgICAgICAgICAgICAgICBzZXQgaWQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGdldCBpbm5lckhUTUwoKTogc3RyaW5nO1xuICAgICAgICAgICAgICAgIHNldCBpbm5lckhUTUwodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcihsb29rdXBFeGlzdGluZ0VsZW1lbnQ6IElFeGlzdGluZ0xvb2t1cE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKGV4aXN0aW5nRWxlbWVudDogSUV4aXN0aW5nRWxlbWVudE9wdGlvbnM8VEVsZW1lbnQ+KTtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihuZXdFbGVtZW50OiBJSW5uZXJIdG1sT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IobmV3RWxlbWVudDogSU91dGVySHRtbE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKG5ld0VsZW1lbnQ6IHN0cmluZyk7XG5cbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZTogc3RyaW5nLCBldmVudDogKGV2dDogRXZlbnQpID0+IGFueSwgb3B0aW9ucz86IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdGhpcztcbiAgICAgICAgICAgICAgICBhZGRJbmxpbmVFdmVudExpc3RlbmVycyhjb21wb25lbnRGaWx0ZXI/OiBzdHJpbmcpOiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgYXBwZW5kPFQ+KG5ld0NoaWxkOiBUKTogdGhpcztcblxuICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkPFQ+KG5ld0NoaWxkOiBUKTogVDtcblxuICAgICAgICAgICAgICAgIHNldFN0eWxlKHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB0aGlzO1xuICAgICAgICAgICAgICAgIHNldFN0eWxlKHN0eWxlOiB7IFtzdHJpbmddOiBzdHJpbmcgfSk6IHRoaXM7XG5cbiAgICAgICAgICAgICAgICBzZXRDbGFzcyhjbGFzc05hbWU6IHN0cmluZyk6IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0Q2xhc3MoY2xhc3NOYW1lczogc3RyaW5nW10pOiB0aGlzO1xuXG4gICAgICAgICAgICAgICAgYXBwZW5kVG9QYXJlbnQocGFyZW50OiBOb2RlKTogdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvY29kZT48L3ByZT5cblxuICAgICAgICAgICAgPHA+VGhlIGNvbXBvbmVudCBpcyBqdXN0IGEgYmFzZSBjbGFzcywgc28geW91IG11c3QgaW5oZXJpdCBmcm9tIGl0LiBBbGwgdGhlIHdvcmsgaXMgaW4gdGhlIGNvbnN0cnVjdG9yLiBZb3UgY2FuIHBhc3MgaXQgYW5cbiAgICAgICAgICAgIGV4aXN0aW5nIGVsZW1lbnQsIGVub3VnaCBpbmZvIHRvIGxvb2sgdXAgYW4gZWxlbWVudCwgYSB0YWcgbmFtZSBhbmQgdGhlIGlubmVyIEhUTUwsIHRoZSBmdWxsIG91dGVyIEhUTUwgKGVpdGhlciBhcyBhbiBvYmplY3RcbiAgICAgICAgICAgIG9yIGEgc3RyaW5nKS4gVGhlIHJlc3QgYXJlIGp1c3QgaGVscGVyIG1ldGhvZHMgdGhhdCBhY2Nlc3MgdGhlIFwiY29udGVudFwiIG9iamVjdCwgd2hpY2ggaXMgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgeW91XG4gICAgICAgICAgICBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhlIG9uZSBleGNlcHRpb24gdG8gdGhpcyBydWxlIGlzIHRoZSBhZGRJbmxpbmVFdmVudExpc3RlbmVycygpIG1ldGhvZCwgd2hpY2ggYWN0cyB1cG9uIGN1c3RvbSBhdHRyaWJ1dGVzLiBJZiB5b3UgY3JlYXRlXG4gICAgICAgICAgICBhbiBlbGVtZW50IHdpdGggYSBwcm9wZXJ0eSBuYW1lZCBlaXRoZXIgaTVfZXZlbnQgb3IgOmV2ZW50LCBhbG9uZyB3aXRoIGFuIGV2ZW50IG5hbWUgaW4gcGFyZW50aGVzZXMgc2V0IGVxdWFsIHRvIGEgbWV0aG9kXG4gICAgICAgICAgICBvbiB0aGUgY29tcG9uZW50LCBpdCBpcyB0cmFuc2xhdGVkIGludG8gYW4gYWRkRXZlbnRMaXN0ZW5lcigpIGNhbGwuPC9wPlxuXG4gICAgICAgICAgICA8cHJlPjxjb2RlPlxuICAgICAgICAgICAgJmx0O2J1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaTVfZXZlbnQgKGNsaWNrKT1cInNvbWV0aGluZ1wiJmd0O0NsaWNrIE1lJmx0Oy9idXR0b24mZ3Q7XG4gICAgICAgICAgICA8L2NvZGU+PC9wcmU+XG5cbiAgICAgICAgICAgIDxwPlRoaXMgaXMgdGhlIHNhbWUgYXMgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY29tcG9uZW50LnNvbWV0aGluZy5iaW5kKGNvbXBvbmVudCkpOzwvcD5cbiAgICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGNsYXNzIGhhcyBub3RoaW5nIHRvIGFkZCB0byB0aGUgY29tcG9uZW50LiBNYWtlcyBpdCBmYXN0ZXIgdG8gdW5pdCB0ZXN0LlxuICogTm9ybWFsbHkgeW91IHdvdWxkIHByb2JhYmx5IHNldCB0aGlzIHRvIHNvbWV0aGluZyBzcGVjaWZpYy5cbiAqL1xuY2xhc3MgUGFzc1Rocm91Z2hDb21wb25lbnQgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgc3VwZXIoYXJncyk7XG4gICAgfVxufVxuY2xhc3MgVGVzdDAwOSBleHRlbmRzIFRlc3RDYXNlVmlld18xLlRlc3RDYXNlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG5ldyBUZXN0Vmlld01vZGVsKCkpO1xuICAgIH1cbiAgICB0ZXN0Q2FzZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxID0gbmV3IFBhc3NUaHJvdWdoQ29tcG9uZW50KCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDEuY29udGVudC50YWdOYW1lID09PSBcIkRJVlwiLCBcIkRlZmF1bHQgc2hvdWxkIGJlIGRpdiBjb21wb25lbnQuXCIpO1xuICAgICAgICAgICAgY29uc3QgY29tcDIgPSBuZXcgUGFzc1Rocm91Z2hDb21wb25lbnQoeyBpZDogJ2NvbXAyJyB9KTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMi5jb250ZW50LmlkID09PSAnY29tcDInLCBcIklkIHNob3VsZCBtYXRjaCBjb250YWluZXJJZFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMi5pZCA9PT0gY29tcDIuY29udGVudC5pZCwgXCJJZCBoZWxwZXIgc2hvdWxkIHJldHVybiBjb250ZW50IGVsZW1lbnQgaWRcIik7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKGNvbXAyLmNvbnRlbnQpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KCEhdGhpcy50ZXN0QXJlYS5xdWVyeVNlbGVjdG9yKCcjY29tcDInKSwgXCJTaG91bGQgYmUgYWJsZSB0byBhZGQgY29udGVudCB0byBwYWdlXCIpO1xuICAgICAgICAgICAgY29tcDIuaW5uZXJIVE1MID0gXCJIZWxsbyBjb21wb25lbnQgMlwiO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyLmNvbnRlbnQuaW5uZXJIVE1MID09PSBcIkhlbGxvIGNvbXBvbmVudCAyXCIsIFwiaW5uZXJIVE1MIHNldHRlciBzaG91bGQgc2V0IGNvbnRlbnQgSFRNTFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAzID0gbmV3IFBhc3NUaHJvdWdoQ29tcG9uZW50KHsgaWQ6ICdjb21wMycsIGlubmVySHRtbDogJ0hlbGxvIGNvbXBvbmVudCAzJywgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTFNwYW5FbGVtZW50IH0pO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAzLmNvbnRlbnQuaW5uZXJIVE1MID09PSBcIkhlbGxvIGNvbXBvbmVudCAzXCIsIFwiaW5uZXJIdG1sIHNldHRpbmcgc2hvdWxkIHNldCBpbml0aWFsIEhUTUxcIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDMuY29udGVudC50YWdOYW1lID09PSBcIlNQQU5cIiwgXCJTaG91bGQgY3JlYXRlIHRhZyB0eXBlIHByb3ZpZGVkIGluIGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgY29uc3QgYWRpdiA9IEFwaV8xLmRpdihcIlNvbWUgZXhpc3RpbmcgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXA0ID0gbmV3IFBhc3NUaHJvdWdoQ29tcG9uZW50KHsgZWxlbWVudDogYWRpdiB9KTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wNC5jb250ZW50ID09PSBhZGl2LCBcIldoZW4gY29udGFpbmVyRWxlbWVudCBzcGVjaWZpZWQsIGl0IHNob3VsZCBiZWNvbWUgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcGlfMS5Db21wb25lbnRNYXAuY29tcG9uZW50cy5nZXQoY29tcDQuY29udGVudCkgPT09IGNvbXA0LCBcIkNvbXBvbmVudE1hcCBzaG91bGQgcmV0dXJuIGNvbXBvbmVudCB3aGVuIHByb3ZpZGVkIGNvbXBvbmVudCBjb250ZW50XCIpO1xuICAgICAgICAgICAgY29uc3QgY29tcDRhID0gY29tcDQuYXBwZW5kKEFwaV8xLmRpdihcIkEgbmV3IGNoaWxkXCIsIHsgaWQ6ICdjb21wNGEnIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIWNvbXA0LmNvbnRlbnQucXVlcnlTZWxlY3RvcignI2NvbXA0YScpLCBcIkFwcGVuZCgpIHNob3VsZCBhcHBlbmQgdG8gY29udGVudFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wNGEgPT09IGNvbXA0LCBcIkFwcGVuZCgpIHNob3VsZCByZXR1cm4gcmVmZXJlbmNlIHRvIGNvbXBvbmVudC5cIik7XG4gICAgICAgICAgICBjb25zdCBkaXYyID0gQXBpXzEuZGl2KFwiQSBuZXcgY2hpbGRcIiwgeyBpZDogJ2NvbXA0YicgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wNGIgPSBjb21wNC5hcHBlbmRDaGlsZChkaXYyKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIWNvbXA0LmNvbnRlbnQucXVlcnlTZWxlY3RvcignI2NvbXA0YicpLCBcImFwcGVuZENoaWxkKCkgc2hvdWxkIGFwcGVuZCB0byBjb250ZW50XCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA0YiA9PT0gZGl2MiwgXCJhcHBlbmRDaGlsZCgpIHNob3VsZCByZXR1cm4gcmVmZXJlbmNlIHRvIGNoaWxkLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRpdjMgPSBBcGlfMS5kaXYoXCJBbm90aGVyIGVsZW1lbnRcIiwgeyBpZDogJ2NvbXA1YScgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wNSA9IG5ldyBQYXNzVGhyb3VnaENvbXBvbmVudCh7IGVsZW1lbnQ6IGRpdjMgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wNiA9IGNvbXA1LmFkZENsYXNzKCdhLWNsYXNzJykuYWRkQ2xhc3MoJ2ItY2xhc3MgYy1jbGFzcycpLmFkZENsYXNzKFsnZC1jbGFzcycsICdlLWNsYXNzJ10pLnNldFN0eWxlKCdib3JkZXInLCAnc29saWQnKS5zZXRTdHlsZSh7IGNvbG9yOiAnYmx1ZScgfSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDYgPT09IGNvbXA1LCBcInNldENsYXNzKCkgYW5kIHNldFN0eWxlKCkgc2hvdWxkIHJldHVybiByZWZlcmVuY2UgdG8gY2hpbGRcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgWydhLWNsYXNzJywgJ2ItY2xhc3MnLCAnYy1jbGFzcycsICdkLWNsYXNzJywgJ2UtY2xhc3MnXSkge1xuICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChBcnJheS5mcm9tKGRpdjMuY2xhc3NMaXN0KS5pbmNsdWRlcyhjKSwgXCJzZXRDbGFzcygpIHNob3VsZCBhZGQgY2xhc3MgdG8gY29udGVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkaXYzLnN0eWxlLmJvcmRlciA9PT0gJ3NvbGlkJywgXCJzZXRTdHlsZSgpIHNob3VsZCBzZXQgc3R5bGUgb2YgY29udGVudFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkaXYzLnN0eWxlLmNvbG9yID09PSAnYmx1ZScsIFwic2V0U3R5bGUoKSBzaG91bGQgc2V0IHN0eWxlIG9mIGNvbnRlbnRcIik7XG4gICAgICAgICAgICBjb21wNS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIXRoaXMudGVzdEFyZWEucXVlcnlTZWxlY3RvcignI2NvbXA1YScpLCBcImFwcGVuZFRvUGFyZW50KCkgc2hvdWxkIGFkZCBjb250ZW50IGFzIGNoaWxkIG9mIHRhcmdldCBlbGVtZW50XCIpO1xuICAgICAgICAgICAgY29uc3QgY29tcDcgPSBuZXcgUGFzc1Rocm91Z2hDb21wb25lbnQoeyBvdXRlckh0bWw6ICc8c3BhbiBpZD1cImNvbXA3XCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIj5IZWxsbyBjb21wb25lbnQgNzwvc3Bhbj4nIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA3LmNvbnRlbnQuaW5uZXJIVE1MID09PSBcIkhlbGxvIGNvbXBvbmVudCA3XCIsIFwib3V0ZXJIdG1sIHNldHRpbmcgc2hvdWxkIHNldCBpbml0aWFsIEhUTUxcIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDcuY29udGVudC50YWdOYW1lID09PSBcIlNQQU5cIiwgXCJTaG91bGQgY3JlYXRlIHRhZyB0eXBlIHByb3ZpZGVkIGluIG91dGVySFRNTFwiKTtcbiAgICAgICAgICAgIC8vIEhlcmUncyBzb21ldGhpbmcgYSBsaXR0bGUgZmFuY3kuXG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgYWxyZWFkeSB3YXlzIHRvIGFkZCBldmVudHMsIHdpdGggbm8gbmVlZCB0byByZXNvcnQgdG8gc2hvcnRjdXRzLiBCdXQgZXZlbnQgc2hvcnRjdXRzXG4gICAgICAgICAgICAvLyBhcmUgY29tbW9uIGluIGphdmFzY3JpcHQgZnJhbWV3b3Jrcy4gVGFrZSBhbmd1bGFyLCB3aGljaCBzdG9yZXMgbWV0aG9kIGNhbGwgYXMgYSBzdHJpbmcsIHdoaWNoIGlzIGV4ZWN1dGVkLlxuICAgICAgICAgICAgLy8gTm93IHNodWRkZXIuXG4gICAgICAgICAgICAvLyBJbiBJY2hpZ28sIHdlIGFkZCBhbiBpNV9ldmVudCBvciA6ZXZlbnQgYXR0cmlidXRlIHRvIHRoZSBIVE1MIChib3RoIGFyZSBhY2NlcHRhYmxlIC4uLiBpdCBqdXN0IGRlcGVuZHMgb24gaWYgeW91XG4gICAgICAgICAgICAvLyBtaW5kIG5vbi1zdGFuZGFyZCBhdHRyaWJ1dGUgZm9ybWF0IG9yIG5vdCksIGFuZCB0aGVuIHRoZSBldmVudCB0eXBlIGluIHBhcmVudGhlc2VzLCB3aGljaCBpcyBzZXQgZXF1YWwgdG8gYSBtZXRob2QgaW5cbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQuICBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCB0aGUgZXZlbnQgYXMgaXRzIG9ubHkgYXJndW1lbnQsIGFzIGluIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXM6XG4gICAgICAgICAgICAvLyA8ZGl2IGk1X2V2ZW50IChjbGljayk9XCJkb1NvbWV0aGluZ1wiPjwvZGl2PlxuICAgICAgICAgICAgLy8gPGlucHV0IDpldmVudCAoaW5wdXQpPVwid3JpdGVTb21ldGhpbmdcIiAvPlxuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBpcyBpbnZhbGlkIGFuZCB3aWxsIHRocm93OiA8YnV0dG9uIDpldmVudCAoY2xpY2spPVwibW9kaWZ5U29tZXRpbmcoZXZ0LmN1cnJlbnRUYXJnZXQsIHNvbWVDbG9zdXJlKVwiPjwvYnV0dG9uPlxuICAgICAgICAgICAgLy8gSXQgd2lsbCB0aHJvdyBiZWNhdXNlIHRoYXQgc3RyaW5nIGlzIG5vdCBhIG1ldGhvZCBuYW1lIG9uIHRoZSBjb21wb25lbnQgKHVubGVzcyB5b3UgaGF2ZSB3ZWlyZCBtZXRob2RzKS5cbiAgICAgICAgICAgIGxldCBjb21wOGNsaWNrZWQ7XG4gICAgICAgICAgICBjbGFzcyBDb21wOFRlc3QgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcignPGRpdiBpZD1cImNvbXA4XCIgaTVfZXZlbnQgKGNsaWNrKT1cInNpbXBsZVRlc3RcIj5DbGljayBNZTwvZGl2PicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZElubGluZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNpbXBsZVRlc3QoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXA4Y2xpY2tlZCA9ICdJIHdhcyBjbGlja2VkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wOCA9IG5ldyBDb21wOFRlc3QoKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbXA4LmNvbnRlbnQuY2xpY2soKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCghIWNvbXA4Y2xpY2tlZCwgJ0NsaWNrIGV2ZW50IHNob3VsZCBiZSB3aXJlZCB0byBtZXRob2QnKTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiRVJST1I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGVzdDAwOSA9IFRlc3QwMDk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld1wiKTtcbmNvbnN0IFRlc3RDYXNlVmlld01vZGVsXzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdNb2RlbFwiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZXN0Vmlld01vZGVsIGV4dGVuZHMgVGVzdENhc2VWaWV3TW9kZWxfMS5UZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdCb3VuZCBDb21wb25lbnQnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb25IdG1sOiBgPHA+QSBib3VuZCBjb21wb25lbnQgaXMgYSBjb21wb25lbnQgdGhhdCBoYXMgaXRzIDEtIG9yIDItd2F5IGRhdGFiaW5kaW5nIGNvbmZpZ3VyZWQgYnkgY3VzdG9tIEhUTUwgYXR0cmlidXRlcyBiZWdpbm5pbmcgd2l0aCB0aGUgc3RyaW5nIFwiaTVfXCIgKG9yIDosIHdoaWNoIGlzIGVpdGhlciB2YWxpZCBvciBpbnZhbGlkIGRlcGVuZGluZyBvbiB3aGljaCBzcGVjIHlvdSByZWFkKS4gVGhlIG1haW4gaW5zcGlyYXRpb24sIGFuZCBtb3N0IG9mIHRoZSBpZGVhcywgYXJlIHRha2VuIGZyb20gQW5ndWxhckpTIGFuZCBWdWUsIHRob3VnaCBJY2hpZ28ncyB0ZW1wbGF0aW5nIGxhbmd1YWdlIGlzIG11Y2ggbW9yZSBiYXNpYyBhbmQgZG9lcyBub3QgaW52b2x2ZSBzcGVjaWFsIHRva2VucyBsaWtlIHt9IG9yIHt7fX0uPC9wPlxuXG4gICAgICAgICAgICA8cD5BcyB1c3VhbCBpbiBIVE1MNSwgYm91bmQgY29tcG9uZW50cyBjYW4gYmUgY29uc3RydWN0ZWQgaW4gSmF2YVNjcmlwdCBjb2RlIG9yIGEgY29tYmluYXRpb24gb2YgSmF2YVNjcmlwdCBhbmQgSFRNTC4gVGhlcmUgaXMgZXZlbiBwYXJ0aWFsIHN1cHBvcnQgZm9yIGN1c3RvbSBlbGVtZW50IHRhZ3MsIHRob3VnaCB0aGlzIGlzIGRvbmUgYnkgcmVwbGFjaW5nIHRoZSBlbGVtZW50LCBub3QgYnVpbGRpbmcgYSBzaGFkb3cgcm9vdC48L3A+XG5cbiAgICAgICAgICAgIDxwPihBIHNoYWRvdyByb290IHdlYmNvbXBvbmVudCBoZWxwZXIgaXMgYSB0YXNrIGZvciBhbm90aGVyIGRheSwgd2hlbiBJIGZlZWwgdXAgdG8gaXQuIFRoZSBzdGFuZGFyZCBoYXMgY2hhbmdlZCBhbmQgbWFueSBwYWdlcyBhYm91dCBpdCBhcmUgbm93IGluY29ycmVjdCwgc28gaXQncyBhIGNob3JlLik8L3A+XG5cbiAgICAgICAgICAgIDxoMj5Vc2FnZTwvaDI+XG4gICAgICAgICAgICA8cHJlPjxjb2RlPlxuICAgICAgICAgICAgY2xhc3MgQm91bmRDb21wb25lbnQ8VEVsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCA9IEhUTUxFbGVtZW50LCBUTW9kZWwgPSBhbnk+IGV4dGVuZHMgQ29tcG9uZW50PFRFbGVtZW50PiBpbXBsZW1lbnRzIElWaWV3PFRFbGVtZW50LCBUTW9kZWw+IHtcbiAgICAgICAgICAgICAgICBzdGF0aWMgaW5qZWN0PFRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRNb2RlbD4oc2VsZWN0b3I/OiBzdHJpbmcgfCBIVE1MRWxlbWVudCB8IE5vZGVMaXN0T2Y8SFRNTEVsZW1lbnQ+IHwgSFRNTEVsZW1lbnRbXSB8IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50PzogRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3I6IHN0cmluZztcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zPzogQm91bmRJbmplY3RPcHRpb25zPFRNb2RlbD4sIGNvbnN0cnVjdG9yPzogQ29uc3RydWN0YWJsZTxCb3VuZENvbXBvbmVudDxURWxlbWVudCwgVE1vZGVsPj4sIHZpZXdNb2RlbD86IFRNb2RlbCk6IEFycmF5PEJvdW5kQ29tcG9uZW50PFRFbGVtZW50LCBUTW9kZWw+PjtcblxuICAgICAgICAgICAgICAgIHN0YXRpYyBpbmplY3RCaW5kPFRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQsIFRNb2RlbD4odmlld01vZGVsPzogVE1vZGVsLCBzZWxlY3Rvcj86IHN0cmluZyB8IEhUTUxFbGVtZW50IHwgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudFtdIHwge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ/OiBFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnM/OiBCb3VuZEluamVjdE9wdGlvbnM8VE1vZGVsPiwgY29uc3RydWN0b3I/OiBDb25zdHJ1Y3RhYmxlPEJvdW5kQ29tcG9uZW50PFRFbGVtZW50LCBUTW9kZWw+Pik6IEFycmF5PEJvdW5kQ29tcG9uZW50PFRFbGVtZW50LCBUTW9kZWw+PjtcblxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbDogVE1vZGVsKTtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWw6IFRNb2RlbCwgZXhpc3RpbmdFbGVtZW50OiBJRXhpc3RpbmdFbGVtZW50T3B0aW9uczxURWxlbWVudD4gJiBJQ29tcG9uZW50QmluZGluZ09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbDogVE1vZGVsLCBleGlzdGluZ0VsZW1lbnQ6IElFeGlzdGluZ0xvb2t1cE9wdGlvbnMgJiBJQ29tcG9uZW50QmluZGluZ09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbDogVE1vZGVsLCBuZXdFbGVtZW50OiBJSW5uZXJIdG1sT3B0aW9ucyAmIElDb21wb25lbnRCaW5kaW5nT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsOiBUTW9kZWwsIG91dGVyRWxlbWVudDogSU91dGVySHRtbE9wdGlvbnMgJiBJQ29tcG9uZW50QmluZGluZ09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbDogVE1vZGVsLCBuZXdFbGVtZW50OiBzdHJpbmcpO1xuXG4gICAgICAgICAgICAgICAgd3JpdGUoZXZ0OiBFdmVudCk6IHZvaWQ7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZShtb2RlbD86IGFueSk6IHRoaXM7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZUFsbChtb2RlbD86IGFueSk6IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVuZGVyKCk6IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0VGVtcGxhdGUodGVtcGxhdGVUZXh0OiBzdHJpbmcsIHVwZGF0ZT86IGJvb2xlYW4pOiB0aGlzO1xuICAgICAgICAgICAgICAgIHNldEh0bWxUZW1wbGF0ZSh0ZW1wbGF0ZVByb3BlcnR5Pzogc3RyaW5nLCB1cGRhdGU/OiBib29sZWFuKTogdGhpcztcbiAgICAgICAgICAgICAgICBzZXRUZXh0VGVtcGxhdGUodGVtcGxhdGVQcm9wZXJ0eT86IHN0cmluZywgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0TG9vcChzb3VyY2U6IHN0cmluZywgZnJhZ21lbnQ6IERvY3VtZW50RnJhZ21lbnQgfCBzdHJpbmcsIHNraXBQb3N0UHJvY2Vzcz86IGJvb2xlYW4sIHVwZGF0ZT86IGJvb2xlYW4pOiB0aGlzO1xuICAgICAgICAgICAgICAgIHJlbW92ZUxvb3AodXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVBdHRyaWJ1dGUoc291cmNlPzogc3RyaW5nIHwgdW5kZWZpbmVkLCB1cGRhdGU/OiBib29sZWFuKTogdGhpcztcbiAgICAgICAgICAgICAgICBzZXRWaXNpYmlsaXR5KHNvdXJjZT86IHN0cmluZyB8IHVuZGVmaW5lZCwgbmVnYXRpdmU/OiBib29sZWFuLCB1cGRhdGU/OiBib29sZWFuKTogdGhpcztcbiAgICAgICAgICAgICAgICBhZGRBdHRyaWJ1dGVNYXBwaW5nKGF0dHJpYnV0ZTogc3RyaW5nLCBzb3VyY2U/OiBzdHJpbmcsIHVwZGF0ZT86IGJvb2xlYW4pOiB0aGlzO1xuICAgICAgICAgICAgICAgIGFkZEJvb2xlYW5BdHRyaWJ1dGVNYXBwaW5nKGF0dHJpYnV0ZTogc3RyaW5nLCBzb3VyY2U/OiBzdHJpbmcsIG5lZ2F0aXZlPzogYm9vbGVhbiwgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQXR0cmlidXRlTWFwcGluZyhhdHRyaWJ1dGU6IHN0cmluZywgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgc2V0Q3NzQ2xhc3MoY2xzPzogc3RyaW5nIHwgdW5kZWZpbmVkLCB1cGRhdGU/OiBib29sZWFuKTogdGhpcztcbiAgICAgICAgICAgICAgICBzZXRDc3NTdHlsZShzdHlsZT86IHN0cmluZyB8IHVuZGVmaW5lZCwgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgYWRkQ3NzQ2xhc3NTd2l0Y2goY2xzOiBzdHJpbmcsIHNvdXJjZT86IHN0cmluZywgbmVnYXRpdmU/OiBib29sZWFuLCB1cGRhdGU/OiBib29sZWFuKTogdGhpcztcbiAgICAgICAgICAgICAgICByZW1vdmVDc3NDbGFzc1N3aXRjaChjbHM6IHN0cmluZywgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgYWRkV3JpdGVFdmVudCgpOiB0aGlzO1xuICAgICAgICAgICAgICAgIGFkZFdyaXRlVGFyZ2V0KHRhcmdldD86IHN0cmluZywgdXBkYXRlPzogYm9vbGVhbik6IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVtb3ZlV3JpdGVUYXJnZXQodGFyZ2V0OiBzdHJpbmcsIHVwZGF0ZT86IGJvb2xlYW4pOiB0aGlzO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTogdm9pZDtcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgbG9vcFBvc3RQcm9jZXNzKHJvdzogYW55LCBhZGRlZENvbnRlbnQ6IE5vZGVbXSwgYWxsUm93czogSXRlcmFibGU8YW55PiwgcHJldmlvdXNDb250ZW50OiBEb2N1bWVudEZyYWdtZW50KTogdm9pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDwvY29kZT48L3ByZT5cblxuICAgICAgICAgICAgPHA+VGhlIG1vc3QgYmFzaWMgY29uc3RydWN0b3IgbG9va3MgbGlrZSB0aGlzOiBuZXcgQm91bmRDb21wb25lbnQodmlld01vZGVsKS4gIFRoZSB2aWV3IG1vZGVsIGlzIGFueSBkYXRhIHR5cGUuICBOb3JtYWxseSBpdCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYnNlcnZhYmxlIG9iamVjdCwgYnV0IGl0IGNvdWxkIGJlIGEgc2ltcGxlIHN0cmluZyBvciBudW1iZXIsIGlmIG5lZWRlZC48L3A+XG5cbiAgICAgICAgICAgIDxwPllvdSBjYW4gYWxzbyBjb252ZXJ0IGNvbXBvbmVudHMgdXNpbmcgdGhlIHN0YXRpYyBCb3VuZENvbXBvbmVudC5pbmplY3QoKSBtZXRob2QsIHdoaWNoIGlzIGNvbnZlbmllbnQgaWYgeW91IG5lZWQgdG8gY29udmVydCBtYW55IGVsZW1lbnRzIGF0IG9uY2UuPC9wPlxuXG4gICAgICAgICAgICA8cD5UaGUgbW9zdCBpbXBvcnRhbnQgcGFydCBvZiB0aGUgYm91bmQgY29tcG9uZW50IGlzIHRoZSBhYmlsaXR5IHRvIHNldCBhbiBIVE1MIHRlbXBsYXRlIGZvciB0aGUgY29udGVudC4gVGhpcyBpcyBkb25lIHVzaW5nIGJ5IHVzaW5nIEhUTUwgdGVtcGxhdGVzLCBiZWhpbmQgdGhlIHNjZW5lcy4gIFdoYXQgdGhpcyBtZWFucyBpcyB0aGF0IHlvdSBzaG91bGQgcGFzcyB2YWxpZCBIVE1MLCBlaXRoZXIgaW4gdGhlIGlubmVySFRNTCBvZiB0aGUgY29udGVudCBvciBhcyB0aGUgYXJndW1lbnQgb2YgcGFyc2VUZW1wbGF0ZSgpLiBOb3csIHNwZWNpYWwgcmVwbGFjZW1lbnQgdGFncyBsaWtlIHt9IG9yIFxcJHt9IChJIHdpc2ggdGVtcGxhdGUgbGl0ZXJhbHMgd2VyZSBhY3R1YWwgdGVtcGxhdGVzLCB0aGVuIEkgY291bGQgdXNlIHRoZW0pIGFyZSBub3QgcGFydCBvZiBIVE1MLiBUaGUgd2F5IHlvdSBpbmRpY2F0ZSByZXBsYWNlbWVudHMgaXMgd2l0aCBpLXYgdGFncywgZm9yIGV4YW1wbGUgJmx0O2ktdiZndDt2aWV3TW9kZWxWYXJpYWJsZU5hbWUmbHQ7L2ktdiZndDsuIFZpZXdNb2RlbFZhcmlhYmxlTmFtZSBtdXN0IGJlIGEgcHJvcGVydHkgb2YgdGhlIHZpZXdNb2RlbCB5b3Ugc2VudCBpbi48L3A+XG5cbiAgICAgICAgICAgIDxwPklmIHlvdSBzZW5kIGluIGEgc2ltcGxlIGRhdGEgdHlwZSwgbm90IGFuIG9iamVjdCwgeW91IGNhbiByZWZlcmVuY2UgaXQgYnkgYSBwZXJpb2QgYnkgaXRzZWxmICgnLicpIGFzIGluIFwiSGVsbG8gJmx0O2ktdiZndDsuJmx0Oy9pLXYmZ3Q7XCI8L3A+XG5cbiAgICAgICAgICAgIDxwPlRvIGF2b2lkIEhUTUwgZXNjYXBpbmcgcmVwbGFjZW1lbnQgdmFsdWVzLCBpbmNsdWRlIHRoZSBub2VzY2FwZSBhdHRyaWJ1dGUsICZsdDtpLXYgbm9lc2NhcGUmZ3Q7LiBJZiB5b3UgbmVlZCB0byBuZXN0IGNvbXBvbmVudHMsIGluZGljYXRlIHdoaWNoIGNvbXBvbmVudCBvd25zIGEgcmVwbGFjZW1lbnQgYnkgdXNpbmcgdGhlIG5hbWUgYXMgYSBjdXN0b20gYXR0cmlidXRlICZsdDtpLXYgbmFtZSZndDsgKHRodXMsIG5hbWVzIHNob3VsZCBjb250YWluIG9ubHkgdmFsaWQgY2hhcmFjdGVycykuPC9wPlxuXG4gICAgICAgICAgICA8cD5UaGVyZSBhcmUgc28gbWFueSBjdXN0b20gcHJvcGVydGllcyBpbiB0aGUgYm91bmQgY29tcG9uZW50IHRoYXQgSSBjYW4ndCByZWFsbHkgZ28gdGhyb3VnaCB0aGVtIGhlcmUuIEknbGwgc3VtbWFyaXplIHRoZW0gYW5kIHlvdSBjYW4gbG9vayB0aHJvdWdoIHRoZSB0ZXN0IGNhc2VzLiBUaGUgZm9sbG93aW5nIGFyZSBjdXN0b20gZWxlbWVudCBhdHRyaWJ1dGVzOjwvcD5cblxuICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgPGxpPiBpNV9uYW1lPVwiXCIgb3IgOm5hbWU9XCJcIiAtIE5hbWUgZm9yIHRoZSBjb21wb25lbnQsIHVzZWQgdG8gYmluZCBzcGVjaWZpYyAmbHQ7aS12IG5hbWUmZ3Q7IHRhZ3Mgd2hlbiB0aGVyZSBhcmUgbmVzdGVkIGNvbXBvbmVudHNcbiAgICAgICAgICAgIDxsaT4gaTVfdGV4dD1cInByb3BlcnR5XCIgb3IgOnRleHQ9XCJwcm9wZXJ0eVwiIC0gU2V0IGlubmVySFRNTCB0byBlc2NhcGVkIHByb3BlcnR5XG4gICAgICAgICAgICA8bGk+IGk1X2h0bWw9XCJwcm9wZXJ0eVwiIG9yIDpodG1sPVwicHJvcGVydHlcIiAtIFNldCBpbm5lckhUTUwgdG8gdW5lc2NhcGVkIHByb3BlcnR5XG4gICAgICAgICAgICA8bGk+IGk1X3ZhbHVlPVwicHJvcGVydHlcIiBvciA6dmFsdWU9XCJwcm9wZXJ0eVwiIC0gU2V0IGZvcm0gZmllbGQgdmFsdWUgdG8gcHJvcGVydHlcbiAgICAgICAgICAgIDxsaT4gaTVfYXR0cl9hdHRyaWJ1dGVOYW1lPVwicHJvcGVydHlcIiBvciBpNV9hdHRyOmF0dHJpYnV0ZU5hbWU9XCJwcm9wZXJ0eVwiIG9yIDphdHRyOmF0dHJpYnV0ZU5hbWU9XCJwcm9wZXJ0eVwiIC0gU2V0IGF0dHJpYnV0ZSBhdHRyaWJ1dGVOYW1lIHRvIHByb3BlcnR5XG4gICAgICAgICAgICA8bGk+IGk1X2Jvb2xfYXR0cmlidXRlTmFtZT1cInByb3BlcnR5XCIgb3IgaTVfYm9vbDphdHRyaWJ1dGVOYW1lPVwicHJvcGVydHlcIiBvciA6Ym9vbDphdHRyaWJ1dGVOYW1lPVwicHJvcGVydHlcIiAtIEFkZCBib29sZWFuIGF0dHJpYnV0ZSBhdHRyaWJ1dGVOYW1lIGlmIHByb3BlcnR5IGlzIHRydXRoeVxuICAgICAgICAgICAgPGxpPiBpNV9ib29sMF9hdHRyaWJ1dGVOYW1lPVwicHJvcGVydHlcIiBvciBpNV9ib29sLTphdHRyaWJ1dGVOYW1lPVwicHJvcGVydHlcIiBvciA6Ym9vbC06YXR0cmlidXRlTmFtZT1cInByb3BlcnR5XCIgLSBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGUgYXR0cmlidXRlTmFtZSBpZiBwcm9wZXJ0eSBpcyB0cnV0aHlcbiAgICAgICAgICAgIDxsaT4gaTVfc3R5bGU9XCJwcm9wZXJ0eVwiIG9yIDpzdHlsZT1cInByb3BlcnR5XCIgLSBTZXQgc3R5bGUgc3RyaW5nIHRvIHByb3BlcnR5XG4gICAgICAgICAgICA8bGk+IGk1X2NsYXNzPVwicHJvcGVydHlcIiBvciA6Y2xhc3M9XCJwcm9wZXJ0eVwiIC0gU2V0IGNsYXNzTGlzdCBzdHJpbmcgdG8gcHJvcGVydHlcbiAgICAgICAgICAgIDxsaT4gaTVfc3dpdGNoX2NsYXNzTmFtZT1cInByb3BlcnR5XCIgb3IgaTVfc3dpdGNoOmNsYXNzTmFtZT1cInByb3BlcnR5XCIgb3IgOnN3aXRjaDpjbGFzc05hbWU9XCJwcm9wZXJ0eVwiIC0gSWYgcHJvcGVydHkgaXMgdHJ1dGh5LCBhZGQgY2xhc3NOYW1lLiBJZiBmYWxzeSwgcmVtb3ZlIGNsYXNzTmFtZVxuICAgICAgICAgICAgPGxpPiBpNV9zd2l0Y2gwX2NsYXNzTmFtZT1cInByb3BlcnR5XCIgb3IgaTVfc3dpdGNoLTpjbGFzc05hbWU9XCJwcm9wZXJ0eVwiIG9yIDpzd2l0Y2gtOmNsYXNzTmFtZT1cInByb3BlcnR5XCIgLSBSZXZlcnNlIG9mIHByZXZpb3VzIG9wdGlvblxuICAgICAgICAgICAgPGxpPiBpNV9pZj1cInByb3BlcnR5XCIgb3IgOmlmPVwicHJvcGVydHlcIiAtIElmIHByb3BlcnR5IGlzIHRydXRoeSwgZGlzcGxheTpub25lIGFwcGxpZWQuIElmIGZhbHN5LCByZW1vdmVkIChhbmQgcG9zc2libHkgcmVzZXQgaWYgc3dpdGNoZWQgb24gdGhlbiBvZmYpXG4gICAgICAgICAgICA8bGk+IGk1X2lmMD1cInByb3BlcnR5XCIgb3IgOmlmLT1cInByb3BlcnR5XCIgLSBSZXZlcnNlIG9mIHByZXZpb3VzIG9wdGlvblxuICAgICAgICAgICAgPGxpPiBpNV9sb29wPVwicHJvcGVydHlcIiBvciA6bG9vcD1cInByb3BlcnR5XCIgLSBSZXBlYXQgZWxlbWVudCBvbmNlIGZvciBlYWNoIGl0ZW0gaW4gcHJvcGVydHksIGNhbGxpbmcgbG9vcFBvc3RQcm9jZXNzKCkgYWZ0ZXJcbiAgICAgICAgICAgIDxsaT4gaTVfbG9vcF9udWxsPVwicHJvcGVydHlcIiBvciBpNV9sb29wOm51bGw9XCJwcm9wZXJ0eVwiIG9yIDpsb29wOm51bGw9XCJwcm9wZXJ0eVwiIC0gVGhlIHNhbWUsIGJ1dCBsb29wUG9zdFByb2Nlc3MoKSBpcyBub3QgY2FsbGVkXG4gICAgICAgICAgICA8bGk+IGk1X2l0ZW0gb3IgOml0ZW0gKG5vIHZhbHVlKSAtIEluZGljYXRlIGEgdGhlIGl0ZW0gaW4gYSBsb29wIHRoYXQgc2hvdWxkIGJlIGNvbnZlcnRlZCBpbnRvIGEgY29tcG9uZW50XG4gICAgICAgICAgICA8bGk+IGk1X2lucHV0IG9yIDppbnB1dCAobm8gdmFsdWUpIC0gQmluZCBpbnB1dCBldmVudHMgb24gZm9ybSBmaWVsZCB0byB0aGUgQm91bmRDb21wb25lbnQud3JpdGUoKSBtZXRob2RcbiAgICAgICAgICAgIDxsaT4gaTVfdGFyZ2V0PVwicHJvcGVydHlcIiBvciA6dGFyZ2V0PVwicHJvcGVydHlcIiAtIEJvdW5kQ29tcG9uZW50LndyaXRlKCkgc2hvdWxkIHNlbmQgaW5wdXQgZGF0YSB0byBwcm9wZXJ0eVxuICAgICAgICAgICAgPGxpPiBpNV90YXJnZXQxPVwicHJvcGVydHlcIiwgaTVfdGFyZ2V0Mj1cInByb3BlcnR5XCIsIDp0YXJnZXQxPVwicHJvcGVydHlcIiwgZXRjIC0gVGhlIHNhbWUsIGJ1dCB3cml0ZSB0byBtdWx0aXBsZSB0YXJnZXRzXG4gICAgICAgICAgICA8bGk+IGk1X2lucHV0PVwicHJvcGVydHlcIiBvciA6aW5wdXQ9XCJwcm9wZXJ0eVwiIC0gU2hvcnRjdXQgZm9yIGk1X2lucHV0IGk1X3RhcmdldD1cInByb3BlcnR5XCJcbiAgICAgICAgICAgIDwvdWw+XG5cbiAgICAgICAgICAgIDxwPlwiUHJvcGVydHlcIiBjYW4gYmUgYW4gb2JqZWN0IHByb3BlcnR5LCBvYnNlcnZhYmxlIHByb3BlcnR5LCBvciBwYXJhbWV0ZXJsZXNzIGZ1bmN0aW9uIG5hbWUuIENhbiBiZSBwcmVmaXhlZCB3aXRoIFwidGhpcy5cIiB0byByZWZlcmVuY2UgdGhlIGNvbXBvbmVudCBpdHNlbGYuIFRoZXNlIGN1c3RvbSBhdHRyaWJ1dGVzIGNhbiBiZSB1c2VkIGFzIGF0dHJpYnV0ZXMsIGRhdGEgYXR0cmlidXRlcywgb3IgcGFzc2VkIGluIHRoZSBjb25zdHJ1Y3Rvci48L3A+XG5cbiAgICAgICAgICAgIDxoMj5XYXJuaW5nPC9oMj5cbiAgICAgICAgICAgIDxwPlRlc3RzIGFyZSBhc3luYyBhbmQgd2lsbCBrZWVwIHJ1bm5pbmcuIFdhaXQgZm9yIHRlc3RzIHRvIGNvbXBsZXRlIGJlZm9yZSBsZWF2aW5nIHBhZ2UuPC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDEwIGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYmFzaWNWaWV3TW9kZWwgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJXb3JsZFwiLFxuICAgICAgICAgICAgICAgIGxpc3Q6IFtcIldvcmxkXCIsIFwiVW5kZXJ3b3JsZFwiXSxcbiAgICAgICAgICAgICAgICBjc3NDbGFzczogJ2RvZXMtbm90aGluZycsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3NlczogJ2NsYXNzLTEgY2xhc3MtMicsXG4gICAgICAgICAgICAgICAgcmF3SHRtbDogXCJIZWxsbyA8ZW0+V29ybGQ8L2VtPlwiLFxuICAgICAgICAgICAgICAgIHRydXRoaW5lc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgdHJ1bXBpbmVzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgbm90aGluZzogbnVsbCxcbiAgICAgICAgICAgICAgICBibG9jazogXCJkaXNwbGF5OiBibG9ja1wiLFxuICAgICAgICAgICAgICAgIGJvbGQ6IFwiZm9udC13ZWlnaHQ6IGJvbGRcIixcbiAgICAgICAgICAgICAgICBzYW1wbGVNZXRob2Q6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubmFtZTsgfSxcbiAgICAgICAgICAgICAgICBzYW1wbGVNZXRob2QyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmNzc0NsYXNzOyB9LFxuICAgICAgICAgICAgICAgIHNhbXBsZU1ldGhvZDM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGBIZWxsbyA8ZW0+JHt0aGlzLm5hbWV9PC9lbT5gOyB9LFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiBudWxsLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlMjogbnVsbCxcbiAgICAgICAgICAgICAgICB3cml0ZXJNZXRob2Q6IGZ1bmN0aW9uIChhcmcpIHsgdGhpcy53cml0YWJsZSA9IGFyZzsgfSxcbiAgICAgICAgICAgICAgICBsYXN0TGlzdEl0ZW06IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMubGlzdFt0aGlzLmxpc3QubGVuZ3RoIC0gMV07IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhc3luY0Fzc2VydHMgPSBuZXcgQXBpXzEuRGVmZXJyZWRQcm9taXNlKEFwaV8xLmRlbGF5KDEwMDApLCB0cnVlKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgbW9zdCBiYXNpYyB0ZW1wbGF0ZSB1c2luZyBwdXJlIEpTIGFuZCBhIHNpbXBsZSBIVE1MIHRlbXBsYXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBzaG93cyB0aGUgdGVtcGxhdGUgcmVwbGFjZW1lbnQgZm9ybWF0LCB1c2luZyA8aS12PiB0YWdzLlxuICAgICAgICAgICAgY29uc3QgY29tcDEgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsIHsgZWxlbWVudDogQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MRGl2RWxlbWVudCwgeyBpbm5lckhUTUw6ICdIZWxsbyA8aS12Pm5hbWU8L2ktdj4nIH0pIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+V29ybGQ8L2ktdj4nLCAnU2ltcGxlIEhUTUwgcmVwbGFjZW1lbnQgc2hvdWxkIHBvcHVsYXRlIGktdiB0YWdzLicpO1xuICAgICAgICAgICAgLy8gVGhlIHZpZXdNb2RlbCBjYW4gYmUgYSBzaW1wbGUgb2JqZWN0IGFuZCBjYW4gYmUgcmVmZXJlbmNlZCBieSAnLidcbiAgICAgICAgICAgIGNvbnN0IGNvbXAyID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KFwiV29ybGRcIiwgeyBpbm5lckh0bWw6ICdIZWxsbyA8aS12Pi48L2ktdj4nIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+V29ybGQ8L2ktdj4nLCAnUGVyaW9kIHNob3VsZCBpbmRpY2F0ZSB0aGUgdmlld01vZGVsIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIC8vIEF0dHJpYnV0ZXMgYW1kIG90aGVyIGNhbiBiZSBzZXQgdXNpbmcgc3BlY2lhbCBhdHRyaWJ1dGVzLiBNb3JlIG9uIHRoaXMgbGF0ZXIuXG4gICAgICAgICAgICBjb25zdCBjb21wMyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgIGlkOiAnY29tcDMnLFxuICAgICAgICAgICAgICAgIGlubmVySHRtbDogJ0hlbGxvIDxpLXY+bmFtZTwvaS12PicsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBpNV9jbGFzczogJ2Nzc0NsYXNzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAzLmNsYXNzTGlzdC50b1N0cmluZygpID09PSAnZG9lcy1ub3RoaW5nJywgXCJDU1MgY2xhc3MgYXR0cmlidXRlIHNob3VsZCBiZSBzZXRcIik7XG4gICAgICAgICAgICAvLyBMaWtlIGl0cyBiYXNlIGNsYXNzLCBDb21wb25lbnQsIGl0IGNhbiBiZSBjcmVhdGVkIHdpdGggbm8gcmVuZGVyaW5nIGFyZ3VtZW50cywgb25seSB0aGUgdmlld01vZGVsICh3aGljaCBpcyByZXF1aXJlZCkuXG4gICAgICAgICAgICAvLyBJZiB5b3UgZG8gdGhpcywgeW91J2xsIG5lZWQgdG8gcGFzcyBpbiBhbnkgZHluYW1pYyBhdHRyaWJ1dGVzIGFmdGVyIHRoZSBmYWN0LlxuICAgICAgICAgICAgY29uc3QgY29tcDQgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpXG4gICAgICAgICAgICAgICAgLnNldFRlbXBsYXRlKCdIZWxsbyA8aS12Pm5hbWU8L2ktdj4nKVxuICAgICAgICAgICAgICAgIC5zZXRDc3NDbGFzcygnY3NzQ2xhc3MnLCB0cnVlKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wNC5pbm5lckhUTUwgPT09ICdIZWxsbyA8aS12PldvcmxkPC9pLXY+JywgJ3NldFRlbXBsYXRlIHNob3VsZCByZXBsYWNlIHRoZSBIVE1MIHRlbXBsYXRlLicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA0LmNsYXNzTGlzdC50b1N0cmluZygpID09PSAnZG9lcy1ub3RoaW5nJywgXCJDU1MgY2xhc3MgYXR0cmlidXRlIHNob3VsZCBiZSBzZXRcIik7XG4gICAgICAgICAgICAvLyBUaGUgbm9ybWFsIHdheSB0byBjcmVhdGUgYSBjb21wb25lbnQgaXMgbm90IGxpa2UgdGhlIGV4YW1wbGVzIGdpdmVuIGJlZm9yZSwgYnV0IHRvXG4gICAgICAgICAgICAvLyByZWZlcmVuY2UgYW4gZXhpc3RpbmcgSFRNTCBET00gZWxlbWVudC4gV2hpbGUgaXQgaXMgcG9zc2libGUgdG8gc2V0IHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBlbnRpcmVseSBpbiBKUyBjb2RlLCB0aGVyZSdzIG5vIG5lZWQgZm9yIGEgYm91bmQgY29tcG9uZW50IHdpdGhvdXQgSFRNTCBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoZSBUUyBoYXMgdG8gdGFrZSBvdXIgd29yZCBmb3IgaXQgdGhhdCB0aGUgZWxlbWVudCBpcyBIVE1MRGl2RWxlbWVudC5cbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlSHRtbCgnPGRpdiBpZD1cImNvbXA1XCIgaTVfY2xhc3M9XCJjc3NDbGFzc1wiPkhlbGxvIDxpLXY+bmFtZTwvaS12PjwvZGl2PicpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXA1ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21wNScpIH0pO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA1LmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+V29ybGQ8L2ktdj4nLCAnU2ltcGxlIEhUTUwgcmVwbGFjZW1lbnQgc2hvdWxkIHBvcHVsYXRlIGktdiB0YWdzLicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA1LmNsYXNzTGlzdC50b1N0cmluZygpID09PSAnZG9lcy1ub3RoaW5nJywgXCJDU1MgY2xhc3MgYXR0cmlidXRlIHNob3VsZCBiZSBzZXRcIik7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHRoZSBzYW1lIHRoaW5nICh3aXRoIGEgc21hbGwgdHdpc3QpLiBJdCBnZXRzIGV4dHJhIHNwZWVkIGJlY2F1c2UgdGhlIHR5cGUgaXNuJ3QgY2hlY2tlZC5cbiAgICAgICAgICAgIC8vIFNvIGl0IGhhcyBhIG1pbnVzLCB3aGljaCBpcyB0aGF0IFRTIGRvZXNuJ3QgZ2V0IHRoZSB0eXBlLlxuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVIdG1sKCc8ZGl2IGlkPVwiY29tcDVhXCIgaTVfY2xhc3M9XCJjc3NDbGFzc1wiPkhlbGxvIDxpLXY+bmFtZTwvaS12PjwvZGl2PicpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXA1YSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgeyBwYXJlbnQ6IHRoaXMudGVzdEFyZWEsIHNlbGVjdG9yOiAnI2NvbXA1YScgfSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDVhLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+V29ybGQ8L2ktdj4nLCAnU2ltcGxlIEhUTUwgcmVwbGFjZW1lbnQgc2hvdWxkIHBvcHVsYXRlIGktdiB0YWdzLicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA1YS5jbGFzc0xpc3QudG9TdHJpbmcoKSA9PT0gJ2RvZXMtbm90aGluZycsIFwiQ1NTIGNsYXNzIGF0dHJpYnV0ZSBzaG91bGQgYmUgc2V0XCIpO1xuICAgICAgICAgICAgLy8gWW91IGNvdWxkIGFsc28gY3JlYXRlIGEgbmV3IGNvbXBvbmVudCB1c2luZyBuZXcgSFRNTCwgdXNpbmcgYWxtb3N0IHRoZSBzYW1lIGNvZGUsIHVzaW5nIHRoZSBvdXRlckh0bWwgb3ZlcmxvYWQuXG4gICAgICAgICAgICAvLyBBZ2FpbiwgVFMgaGFzIHRvIHRha2Ugb3VyIHdvcmQgZm9yIGl0IHRoYXQgd2UncmUgdXNpbmcgYSBESVYsIGJlY2F1c2UgaXQncyBub3QgbGlrZSBpdCBrbm93cy5cbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBtYWtlIGZvciB0aGUgcXVpY2tlc3QgdW5pdCB0ZXN0aW5nLCBob3dldmVyLCBzbyBJIHdpbGwgdXNlIGl0IGV4dGVuc2l2ZWx5LlxuICAgICAgICAgICAgY29uc3QgY29tcDYgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsIHsgb3V0ZXJIdG1sOiAnPGRpdiBpZD1cImNvbXA2XCIgaTVfY2xhc3M9XCJjc3NDbGFzc1wiPkhlbGxvIDxpLXY+bmFtZTwvaS12PjwvZGl2PicgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDYuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5Xb3JsZDwvaS12PicsICdTaW1wbGUgSFRNTCByZXBsYWNlbWVudCBzaG91bGQgcG9wdWxhdGUgaS12IHRhZ3MuJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDYuY2xhc3NMaXN0LnRvU3RyaW5nKCkgPT09ICdkb2VzLW5vdGhpbmcnLCBcIkNTUyBjbGFzcyBhdHRyaWJ1dGUgc2hvdWxkIGJlIHNldFwiKTtcbiAgICAgICAgICAgIC8vIFByb3BlcnR5IG5hbWVzIGNhbiByZWZlcmVuY2UgZGF0YSBmaWVsZHMgYnV0IHRoZXkgY2FuIGFsc28gcmVmZXJlbmNlIG1ldGhvZHMuIElmIGEgbWV0aG9kIGlzIHJlZmVyZW5jZWQsIGl0IGlzIGV4ZWN1dGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHJlc3VsdCBpcyBpbnNlcnRlZC4gVGhlIG1ldGhvZCBpcyBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMuXG4gICAgICAgICAgICAvLyBBbHNvLCBvdXRlckh0bWwgaXMgc28gZWFzeSB0byBzZXQgdGhhdCB5b3UgbWF5IHdhbnQgdG8gdXNlIHRoaXMgc2hvcnRjdXQuXG4gICAgICAgICAgICAvLyBDT05TSURFUjogT2ZmZXIgYSB3YXkgdG8gc2V0IGFyZ3VtZW50cy4gVGhpcyBjYW4gZWFzaWx5IGdldCBoYWlyeS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXA3ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGRpdiBpZD1cImNvbXA3XCIgaTVfY2xhc3M9XCJzYW1wbGVNZXRob2QyXCI+SGVsbG8gPGktdj5zYW1wbGVNZXRob2Q8L2ktdj48L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wNy5pbm5lckhUTUwgPT09ICdIZWxsbyA8aS12PldvcmxkPC9pLXY+JywgJ01ldGhvZHMgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIHJlZmVyZW5jZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wNy5jbGFzc0xpc3QudG9TdHJpbmcoKSA9PT0gJ2RvZXMtbm90aGluZycsIFwiTWV0aG9kcyBzaG91bGQgYmUgY2FsbGVkIHdoZW4gcmVmZXJlbmNlZFwiKTtcbiAgICAgICAgICAgIC8vIFZhbHVlcyBhcmUgYnkgZGVmYXVsdCBlc2NhcGVkLlxuICAgICAgICAgICAgY29uc3QgY29tcDggPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8ZGl2IGlkPVwiY29tcDhcIj5Fc2NhcGVkOiA8aS12PnJhd0h0bWw8L2ktdj48L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wOC5pbm5lckhUTUwgPT09ICdFc2NhcGVkOiA8aS12PkhlbGxvICZsdDtlbSZndDtXb3JsZCZsdDsvZW0mZ3Q7PC9pLXY+JywgXCJCeSBkZWZhdWx0IHJlcGxhY2VtZW50cyBzaG91bGQgYmUgSFRNTCBlc2NhcGVkXCIpO1xuICAgICAgICAgICAgLy8gWW91IGNhbiBza2lwIHRoZSBIVE1MIGVzY2FwZSBwcm9jZXNzIGJ5IGFkZGluZyBhIG5vZXNjYXBlIHByb3BlcnR5IHRvIHRoZSBpLXYgZWxlbWVudC5cbiAgICAgICAgICAgIGNvbnN0IGNvbXA5ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGRpdiBpZD1cImNvbXA5XCI+Tm90IGVzY2FwZWQ6IDxpLXYgbm9lc2NhcGU+cmF3SHRtbDwvaS12PjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXA5LmNvbnRlbnQucXVlcnlTZWxlY3RvcignaS12JykuaW5uZXJIVE1MID09PSAnSGVsbG8gPGVtPldvcmxkPC9lbT4nLCBcIklmIG5vZXNjYXBlIHNldCwgcmVwbGFjZW1lbnRzIHNob3VsZCBub3QgYmUgSFRNTCBlc2NhcGVkXCIpO1xuICAgICAgICAgICAgLy8gRXNjYXBlZCB0ZXh0IGNhbiBiZSBzZXQgZGlyZWN0bHkgYnkgdXNpbmcgdGhlIGk1X3RleHQgYXR0cmlidXRlLCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBIVE1MIHRlbXBsYXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYWtlcyBhIHNpbXBsZSBvbmUtZWxlbWVudCB0ZW1wbGF0ZVxuICAgICAgICAgICAgY29uc3QgY29tcDEwID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IG91dGVySHRtbDogJzxkaXYgaWQ9XCJjb21wMTBcIiBpNV90ZXh0PVwicmF3SHRtbFwiPjwvZGl2PicgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDEwLmlubmVySFRNTCA9PT0gJzxpLXY+SGVsbG8gJmx0O2VtJmd0O1dvcmxkJmx0Oy9lbSZndDs8L2ktdj4nLCBcIlRleHQgcHJvcGVydHkgc2hvdWxkIHNldCBlc2NhcGVkIEhUTUxcIik7XG4gICAgICAgICAgICAvLyBUaGUgbm9uLWVzY2FwZWQgSFRNTCBjYW4gYWxzbyBiZSBzZXQgZGlyZWN0bHkgYnkgdGhlIGk1X2h0bWwgYXR0cmlidXRlLCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBIVE1MIHRlbXBsYXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYWtlcyBhIHNpbXBsZSBvbmUtZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAxMSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgaWQ9XCJjb21wMTFcIiBpNV9odG1sPVwicmF3SHRtbFwiPjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgLy8gVGhlIEhUTUwgaW4gdGhpcyBjYXNlIGlzIC0tIDxpLXYgbm9lc2NhcGU9XCJcIj5IZWxsbyA8ZW0+V29ybGQ8L2VtPjwvaS12PiAtLSB3aGljaCBtYXkgYmUgYnJvd3NlciBzcGVjaWZpYy5cbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTEuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPT09ICdIZWxsbyA8ZW0+V29ybGQ8L2VtPicsICdIVE1MIHByb3BlcnR5IHNob3VsZCBzZXQgdW5lc2NhcGVkIEhUTUwnKTtcbiAgICAgICAgICAgIC8vIE9uZSB3aWxsIHByb2JhYmx5IHVzZSB0aGUgc2hvcnRjdXQgdGV4dCBhbmQgaHRtbCBwcm9wZXJ0aWVzIHdpdGggbWV0aG9kcywgaG93ZXZlciwgaW4gcGxhY2VzIHdoZXJlIHRoZSBIVE1MIG5lZWRzIHRvIGJlXG4gICAgICAgICAgICAvLyB2ZXJ5IGR5bmFtaWMuIEp1c3QgbGlrZSBhbHdheXMsIG1ldGhvZHMgYXJlIGZpbmUuXG4gICAgICAgICAgICBjb25zdCBjb21wMTIgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsIHsgb3V0ZXJIdG1sOiAnPGRpdiBpZD1cImNvbXAxMlwiIGk1X2h0bWw9XCJzYW1wbGVNZXRob2QzXCI+PC9kaXY+JyB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTIuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPT09ICdIZWxsbyA8ZW0+V29ybGQ8L2VtPicsICdNZXRob2RzIHNob3VsZCBiZSBjYWxsZWQgd2hlbiByZWZlcmVuY2VkJyk7XG4gICAgICAgICAgICAvLyBBbmQganVzdCBsaWtlIGFsd2F5cywgc2ltcGxlIG1vZGVscyBjYW4gYmUgYWNjZXNzZWQgYnkgJy4nXG4gICAgICAgICAgICBjb25zdCBjb21wMTMgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoXCJIZWxsbyA8ZW0+V29ybGQ8L2VtPlwiLCAnPGRpdiBpZD1cImNvbXAxM1wiIGk1X2h0bWw9XCIuXCI+PC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDEzLmNvbnRlbnQuZmlyc3RFbGVtZW50Q2hpbGQuaW5uZXJIVE1MID09PSAnSGVsbG8gPGVtPldvcmxkPC9lbT4nLCAnU2ltcGxlIG9iamVjdHMgc2hvdWxkIGJlIHJlZmVyZW5jZWQgYnkgcGVyaW9kJyk7XG4gICAgICAgICAgICAvLyBGb3JtIGZpZWxkcyBhcmUgcHJldHR5IG5hc3R5IGJlY2F1c2UgdGhlIEhUTUwgc3RhbmRhcmQgZG9lc24ndCBoYXZlIGEgc3RhbmRhcmQgd2F5IHRvIHNldCB0aGUgdmFsdWUuXG4gICAgICAgICAgICAvLyBUbyBtYWtlIHNldHRpbmcgdGhlbSBhcyBlYXN5IGFzIGl0IGlzIHRvIHNldCB0aGUgSFRNTCwgdGhlIGk1X3ZhbHVlIHByb3BlcnR5IGlzIGludHJvZHVjZWQuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUZyYWdtZW50KGA8ZGl2PlxuICAgICAgICAgICAgICAgIDxpbnB1dCBpZD1cImNvbXAxNGFcIiBpNV92YWx1ZT1cIm5hbWVcIiAvPlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjb21wMTRiXCIgaTVfdmFsdWU9XCJuYW1lXCI+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTdW5cIj5TdW48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIk1vb25cIj5Nb29uPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTdGFyc1wiPlN0YXJzPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJXb3JsZFwiPldvcmxkPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJVbmRlcndvcmxkXCI+VW5kZXJ3b3JsZDwvb3B0aW9uPlxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJjb21wMTRjXCIgaTVfdmFsdWU9XCJsaXN0XCIgbXVsdGlwbGUgc2l6ZT1cIjJcIj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIldvcmxkXCI+V29ybGQ8L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlVuZGVyd29ybGRcIj5VbmRlcndvcmxkPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTdW5cIj5TdW48L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIk1vb25cIj5Nb29uPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJTdGFyc1wiPlN0YXJzPC9vcHRpb24+XG4gICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICA8L2Rpdj5gKSk7XG4gICAgICAgICAgICBjb25zdCBjb21wMTRhID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21wMTRhJykgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wMTRiID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21wMTRiJykgfSk7XG4gICAgICAgICAgICBjb25zdCBjb21wMTRjID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IGVsZW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21wMTRjJykgfSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDE0YS52YWx1ZSA9PT0gJ1dvcmxkJywgJ0lucHV0IHZhbHVlIGNhbiBiZSBzZXQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTRiLnZhbHVlID09PSAnV29ybGQnLCAnU2luZ2xlIHNlbGVjdCB2YWx1ZSBjYW4gYmUgc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBzZXRzQXJlRXF1YWwgPSAoYSwgYikgPT4gYS5zaXplID09PSBiLnNpemUgJiYgWy4uLmFdLmV2ZXJ5KHYgPT4gYi5oYXModikpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNldHNBcmVFcXVhbChuZXcgU2V0KGNvbXAxNGMudmFsdWUpLCBuZXcgU2V0KFsnV29ybGQnLCAnVW5kZXJ3b3JsZCddKSksICdNdWx0aSBzZWxlY3QgdmFsdWUgY2FuIGJlIHNldCcpO1xuICAgICAgICAgICAgLy8gWW91IGNhbiBzZXQgYXR0cmlidXRlcyBieSB1c2luZyBpNV9hdHRyX2F0dHJpYnV0ZSBvciBpNV9hdHRyOmF0dHJpYnV0ZS5cbiAgICAgICAgICAgIC8vIE9uZSBsb29rcyBuaWNlciBpbiBIVE1MIGJ1dCBpc24ndCB2YWxpZCBKUy4gVGhlIG90aGVyIGlzIGxlc3MgY2xlYXIgYnV0IGlzIHZhbGlkLlxuICAgICAgICAgICAgLy8gWW91IGNhbiBzZXQgYm9vbGVhbiBhdHRyaWJ1dGVzIGJ5IHVzaW5nIGk1X2Jvb2xfYXR0cmlidXRlIG9yIGk1X2Jvb2w6YXR0cmlidXRlXG4gICAgICAgICAgICBjb25zdCBjb21wMTVhID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IGlkPVwiY29tcDE1YVwiIGk1X3ZhbHVlPVwibmFtZVwiIGk1X2Jvb2w6ZGlzYWJsZWQ9XCJ0cnV0aGluZXNzXCIgaTVfYXR0cjpzdHlsZT1cImJsb2NrXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTVhLnZhbHVlID09PSAnV29ybGQnLCAnVmFsdWUgc2hvdWxkIHNldCB2YWx1ZScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxNWEuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJywgJ0F0dHIgc2hvdWxkIHNldCBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTVhLmNvbnRlbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpLCAnQXR0ciBzaG91bGQgc2V0IGJvb2xlYW4gYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAvLyBTYW1lIHRoaW5nLCBkaWZmZXJlbnQgc3R5bGVcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxNWIgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICBpZDogJ2NvbXAxNWInLFxuICAgICAgICAgICAgICAgIHR5cGU6IEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxJbnB1dEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b2JqZWN0LWxpdGVyYWwta2V5LXF1b3Rlc1xuICAgICAgICAgICAgICAgICAgICBpNV92YWx1ZTogJ25hbWUnLFxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6b2JqZWN0LWxpdGVyYWwta2V5LXF1b3Rlc1xuICAgICAgICAgICAgICAgICAgICBpNV9hdHRyX3N0eWxlOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAnaTVfYm9vbDpkaXNhYmxlZCc6ICd0cnV0aGluZXNzJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxNWIudmFsdWUgPT09ICdXb3JsZCcsICdWYWx1ZSBzaG91bGQgc2V0IHZhbHVlJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDE1Yi5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snLCAnQXR0ciBzaG91bGQgc2V0IGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxNWIuY29udGVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJyksICdBdHRyIHNob3VsZCBzZXQgYm9vbGVhbiBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgIC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhcmUgb25lcyB0aGF0IHRha2UgZWZmZWN0IGlmIHRoZXkgZXZlbiBleGlzdCwgcmVnYXJkbGVzcyBvZiB0aGVpciB2YWx1ZXMuXG4gICAgICAgICAgICAvLyBUaGV5IGNhbiBiZSBuZWdhdGVzIGJ5IGFkZGluZyAhIHRvIHRoZSBlbmQsIGk1X2Jvb2whOmF0dHJpYnV0ZVxuICAgICAgICAgICAgLy8gQWxzbyB0aGVyZSdzIGEgZGlmZmVyZW50IHdheSB0byBzZXQgc3R5bGUuIFdoaWxlIGl0IGlzIHBvc3NpYmxlIHRvIHNldCBzdHlsZSB0aHJvdWdoIGF0dHJpYnV0ZXMsIHRoaXMgaXMgcHJvYmFibHkgbm90IG5vcm1hbC5cbiAgICAgICAgICAgIC8vIE1haW5seSBiZWNhdXNlIGF0dHJpYnV0ZXMgYXJlIHRoZSBpbml0aWFsIHZhbHVlLCBub3QgdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICAvLyBZb3UgY2FuIHNldCBvbmx5IG9uZSBzdHlsZSBzdHJpbmcsIG1haW5seSBiZWNhdXNlIGl0IGdpdmVzIHlvdSBhbiBlYXN5IHdheSB0byByZW1vdmUgcHJldmlvdXMgc3R5bGVzLlxuICAgICAgICAgICAgY29uc3QgY29tcDE1YyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxpbnB1dCBpZD1cImNvbXAxNWNcIiBpNV92YWx1ZT1cIm5hbWVcIiBpNV9ib29sLTpkaXNhYmxlZD1cIm5vdGhpbmdcIiBpNV9zdHlsZT1cImJsb2NrXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTVjLmNvbnRlbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpLCAnTnVsbCBhdHRyIHNob3VsZCBzZXQgbmVnYXRlZCBib29sZWFuIGF0dHJpYnV0ZScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxNWMuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJywgJ1N0eWxlIHNob3VsZCBzZXQgc3R5bGUnKTtcbiAgICAgICAgICAgIC8vIFlvdSBjYW4gc2V0IHRoZSBjbGFzc0xpc3Qgd2l0aCBpNV9jbGFzcywgd2hpY2ggd2UndmUgYWxyZWFkeSBzZWVuLiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2xhc3NlcywgaW5jbHVkZSB0aGVtXG4gICAgICAgICAgICAvLyBzZXBhcmF0ZWQgYnkgc3BhY2UsIGp1c3QgbGlrZSB5b3UgZG8gaW4gSFRNTC4gVGhpcyBsZXRzIHlvdSB0dXJuIGNsYXNzZXMgb24gb3Igb2ZmLlxuICAgICAgICAgICAgLy8gWW91IGNhbiBhbHNvIHN3dGljaCBjbGFzc2VzIG9uIG9yIG9mZiBiYXNlZCBvbiB0cnV0aHkvZmFsc3kgdmFsdWVzIHVzaW5nIGk1X3N3aXRjaDpjbGFzcyAob3IgaTVfc3dpdGNoX2NsYXNzKS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAxNiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgaWQ9XCJjb21wMTZcIiBpNV9jbGFzcz1cImNzc0NsYXNzZXNcIiBpNV9zd2l0Y2hfY2xhc3MtMz1cIm5vdGhpbmdcIiBpNV9zd2l0Y2g6Y2xhc3MtND1cInRydXRoaW5lc3NcIj5IZWxsbyBXb3JsZDwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAxNi5jbGFzc05hbWUgPT09ICdjbGFzcy0xIGNsYXNzLTIgY2xhc3MtNCcsICdDYW4gc3dpdGNoIGNsYXNzZXMgb24gb3Igb2ZmIGFuZCBzZXQgbXVsdGlwbGUgY2xhc3NlcycpO1xuICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzd2l0Y2ggaXMgZm9sbGV3ZWQgYnkgYSAtIG9yIGEgMCBiZWZvcmUgdGhlIGZpcnN0IGNvbG9uLlxuICAgICAgICAgICAgY29uc3QgY29tcDE2YSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgaWQ9XCJjb21wMTZhXCIgaTVfc3dpdGNoMF9jbGFzcy0zPVwidHJ1bXBpbmVzc1wiIGk1X3N3aXRjaC06Y2xhc3MtND1cInRydW1waW5lc3NcIiBpNV9zd2l0Y2gtOmNsYXNzLTU9XCJ0cnV0aGluZXNzXCI+SGVsbG8gV29ybGQ8L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTZhLmNsYXNzTmFtZSA9PT0gJ2NsYXNzLTMgY2xhc3MtNCcsICdOZWdhdGl2ZSBzd2l0Y2hlcyByZXZlcnNlIHN3aXRjaCBsb2dpYycpO1xuICAgICAgICAgICAgLy8gaTVfaWYgY2FuIGJlIHVzZWQgdG8gbWFrZSBhIGNvbXBvbmVudCBlbGVtZW50IHZpc2libGUgb3IgaW52aXNpYmxlLCB1c2luZyBkaXNwbGF5OiBub25lLlxuICAgICAgICAgICAgY29uc3QgY29tcDE3YSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgaWQ9XCJjb21wMTdhXCIgaTVfaWY9XCJ0cnV0aGluZXNzXCI+SGVsbG8gV29ybGQ8L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxN2IgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8ZGl2IGlkPVwiY29tcDE3YlwiIGk1X2lmPVwidHJ1bXBpbmVzc1wiPkhlbGxvIFdvcmxkPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDE3YS5zdHlsZS5kaXNwbGF5ID09PSAnJywgJ2k1X2lmIGlzIHRydWUsIGVsZW1lbnQgaXMgZGlzcGxheWVkJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDE3Yi5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScsICdpNV9pZiBpcyBmYWxzZSwgZWxlbWVudCBpcyBub3QgZGlzcGxheWVkJyk7XG4gICAgICAgICAgICAvLyBJZiBpNV9pZiBpcyBzd2l0Y2hlZCBvZmYgYW5kIHRoZW4gb24sIHRoZSBvcmlnaW5hbCB2YWx1ZSBvZiBkaXNwbGF5IGlzIHJlc3RvcmVkLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSwgYXNpZGUgZnJvbSB1c2luZyBjbGFzc2VzICh3aGljaCBhcmUgcHJvYmFibHkgYSBNVUNIIGJldHRlciBzb2x1dGlvbiksXG4gICAgICAgICAgICAvLyB0aGVyZSBpcyBubyBzaW1wbGUgJ25vdC1kaXNwbGF5LW5vbmUnIHN0eWxlLCBidXQgaW5zdGVhZCBhIGhvc3Qgb2YgdmFsdWVzIGZvciB0aGUgZGlzcGxheSBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIFdlIGhhdmVuJ3QgdGVzdGVkIG9ic2VydmFibGVzIHlldCBzbyB0aGlzIHRlc3Qgd2lsbCB0b2dnbGUgbWFudWFsbHkuXG4gICAgICAgICAgICBjb25zdCBjb21wMTdjID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IGlkPVwiY29tcDE3Y1wiIGk1X3N0eWxlPVwiYmxvY2tcIiB2YWx1ZT1cIkhlbGxvIFdvcmxkXCIvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29tcDE3Yy5zZXRWaXNpYmlsaXR5KCd0cnVtcGluZXNzJyk7XG4gICAgICAgICAgICBjb21wMTdjLnNldFZpc2liaWxpdHkoJ3RydXRoaW5lc3MnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMTdjLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycsICdpNV9pZiBpcyB0cnVlLCBlbGVtZW50IGRpc3BsYXkgcHJvcGVydHkgaXMgcmVzdG9yZWQnKTtcbiAgICAgICAgICAgIC8vIFRoZSBtb3N0IGNvbW1vbiBwaWVjZSBvZiBldmVudC1iYXNlZCBmdW5jdGlvbmFsaXR5IGlzIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS4gSW4gbW9zdCBjYXNlcywgdGhpc1xuICAgICAgICAgICAgLy8gdHJpZ2dlcnMgYW4gaW5wdXQgZXZlbnQuIEFjY29yZGluZyB0byB0aGUgSFRNTDUgc3BlY2lmaWNhdGlvbiwgdGhlIGlucHV0IGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgICAgICAgICAgLy8gb24gYW55IGlucHV0LCBzZWxlY3QsIG9yIHRleHRhcmVhLCBidXQgcmVhbCBsaWZlIGJyb3dzZXJzIG1heSB2YXJ5LiBGb3IgZXhhbXBsZSwgaW4gRWRnZSxcbiAgICAgICAgICAgIC8vIHRoZSBpbnB1dCBldmVudCBpc24ndCBzdXBwb3J0ZWQgdGhyb3VnaCBtb3N0IG9mIGl0cyBoaXN0b3J5LlxuICAgICAgICAgICAgLy8gVXNlIHRoZSBidWlsdC1pbiBhdHRyaWJ1dGUgaTVfdGFyZ2V0PVwicHJvcGVydHlOYW1lXCIgdG8gaW5kaWNhdGUgd2hhdCBwcm9wZXJ0aWVzIHRoZSBidWlsdC1pblxuICAgICAgICAgICAgLy8gd3JpdGUgbWV0aG9kIHNob3VsZCBzZXQuIElmIHByb3BlcnR5TmFtZSBpbmRpY2F0ZXMgYSBtZXRob2QsIHRoZW4gdGhhdCBtZXRob2QgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVhbiB0aGUgc2FtZSB0aGluZzpcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxOGEgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgaWQ9XCJjb21wMThhXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBpNV9pbnB1dCBpNV90YXJnZXQ9XCJ3cml0YWJsZVwiLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIC8vIFNob3J0Y3V0IGNvbWJpbmluZyB0aGUgZXZlbnQgYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxOGIgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgaWQ9XCJjb21wMThiXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBpNV9pbnB1dD1cIndyaXRhYmxlXCIvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29tcDE4YS52YWx1ZSA9ICdGaXJzdCB0ZXN0JztcbiAgICAgICAgICAgIGNvbXAxOGEuY29udGVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGJhc2ljVmlld01vZGVsLndyaXRhYmxlID09PSAnRmlyc3QgdGVzdCcsICdJbnB1dCB3b3JrcycpO1xuICAgICAgICAgICAgY29tcDE4Yi52YWx1ZSA9ICdTZWNvbmQgdGVzdCc7XG4gICAgICAgICAgICBjb21wMThiLmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChiYXNpY1ZpZXdNb2RlbC53cml0YWJsZSA9PT0gJ1NlY29uZCB0ZXN0JywgJ0lucHV0IHNob3J0Y3V0IGNhbiB0YWtlIHRhcmdldCBhcyBhbiBhcmd1bWVudCcpO1xuICAgICAgICAgICAgLy8gVGhlIHByb3BlcnR5ICd3cml0YWJsZScgY2FuIGJlIHJlcGxhY2VkIGJ5IGEgbWV0aG9kIGNhbGxcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxOGMgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgaWQ9XCJjb21wMThjXCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBpNV9pbnB1dD1cIndyaXRlck1ldGhvZFwiLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAxOGQgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoKHgpID0+IGJhc2ljVmlld01vZGVsLndyaXRlck1ldGhvZCh4KSwgJzxpbnB1dCBpZD1cImNvbXAxOGRcIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiIGk1X2lucHV0PVwiLlwiLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbXAxOGMudmFsdWUgPSAnRm91cnRoIHRlc3QnO1xuICAgICAgICAgICAgY29tcDE4Yy5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYmFzaWNWaWV3TW9kZWwud3JpdGFibGUgPT09ICdGb3VydGggdGVzdCcsICdXcml0ZSBtZXRob2QgY2FuIGNhbGwgbWV0aG9kcycpO1xuICAgICAgICAgICAgY29tcDE4ZC52YWx1ZSA9ICdGaWZ0aCB0ZXN0JztcbiAgICAgICAgICAgIGNvbXAxOGQuY29udGVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGJhc2ljVmlld01vZGVsLndyaXRhYmxlID09PSAnRmlmdGggdGVzdCcsICdXcml0ZSBtZXRob2QgY2FuIGNhbGwgZnVuY3Rpb25zJyk7XG4gICAgICAgICAgICAvLyBPZnRlbiB5b3Ugd2FudCB0byBzZXQgYm90aCB0aGUgaW5wdXQgYW5kIHRoZSB2YWx1ZSB0byB0aGUgc2FtZSB0aGluZy5cbiAgICAgICAgICAgIC8vIFlvdSBjYW4gdXNlIGk1X2lucHV0X3ZhbHVlPVwiZm9vXCIgYXMgYSBzaG9ydGN1dCBmb3IgaTVfaW5wdXQ9XCJmb29cIiBhbmQgaTVfdmFsdWU9XCJmb29cIlxuICAgICAgICAgICAgY29uc3QgY29tcDE4ZSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxpbnB1dCBpZD1cImNvbXAxOGVcIiBzdHlsZT1cImRpc3BsYXk6IGJsb2NrO1wiIGk1X2lucHV0X3ZhbHVlPVwid3JpdGFibGVcIi8+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDE4ZS52YWx1ZSA9PT0gJ0ZpZnRoIHRlc3QnLCAnaTVfaW5wdXRfdmFsdWUgc2V0cyB2YWx1ZSBiZWZvcmUnKTtcbiAgICAgICAgICAgIGNvbXAxOGUudmFsdWUgPSAnU2l4dGggdGVzdCc7XG4gICAgICAgICAgICBjb21wMThlLmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChiYXNpY1ZpZXdNb2RlbC53cml0YWJsZSA9PT0gJ1NpeHRoIHRlc3QnLCAnaTVfaW5wdXQgc3RpbGwgd29ya3MnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMThlLnZhbHVlID09PSAnU2l4dGggdGVzdCcsICdpNV9pbnB1dF92YWx1ZSBzZXRzIHZhbHVlIGFmdGVyJyk7XG4gICAgICAgICAgICAvLyBUaGUgaTVfdGFyZ2V0IGF0dHJpYnV0ZSBjYW4gYmUgcmVwbGljYXRlZCB0byB3cml0ZSB0byBtdWx0aXBsZSB0YXJnZXRzLlxuICAgICAgICAgICAgLy8gRXZlcnl0aGluZyBhZnRlciB0aGUgXCJ0YXJnZXRcIiwgc28gaTVfdGFyZ2V0MSwgaTVfdGFyZ2V0d2hhdGV2ZXIgYXJlIHZhbGlkLlxuICAgICAgICAgICAgY29uc3QgY29tcDE5ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IGlkPVwiY29tcDE5XCIgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBpNV9pbnB1dCBpNV90YXJnZXQxPVwid3JpdGFibGVcIiBpNV90YXJnZXQyPVwid3JpdGFibGUyXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbXAxOS52YWx1ZSA9ICdTaXh0aCB0ZXN0JztcbiAgICAgICAgICAgIGNvbXAxOS5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYmFzaWNWaWV3TW9kZWwud3JpdGFibGUgPT09ICdTaXh0aCB0ZXN0JyAmJiBiYXNpY1ZpZXdNb2RlbC53cml0YWJsZTIgPT09ICdTaXh0aCB0ZXN0JywgJ1dyaXRlIG1ldGhvZCBjYW4gd3JpdGUgdG8gbXVsdGlwbGUgdGFyZ2V0cycpO1xuICAgICAgICAgICAgLy8gVGhlIGJhc2ljIGxvb3AsIGNhbGxpbmcgdGhlIGJ1aWx0LWluIG1ldGhvZCBCb3VuZENvbXBvbmVudC5sb29wUG9zdFByb2Nlc3MuXG4gICAgICAgICAgICAvLyBXaXRob3V0IGFueSBpbmplY3Rpb24gb2YgbG9vcCBpdGVtIGNvbXBvbmVudHMgKHdoaWNoIEkgd2lsbCBnZXQgdG8gc2hvcnRseSksIHRoZSBkZWZhdWx0IGxvb3BQb3N0UHJvY2VzcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuICAgICAgICAgICAgLy8gSSB3aWxsIG5lZWQgdG8gZGV0b3VyIGludG8gaW5qZWN0aW9uIHRvIGdvIG92ZXIgdGhlIGRlZmF1bHQgcG9zdCBwcm9jZXNzIG1ldGhvZC5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyMGEgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sICc8ZGl2IGlkPVwiY29tcDIwYVwiIGk1X2xvb3A9XCIuXCI+UmFuZG9tIDxzcGFuPnNwYW4gY29udGVudDwvc3Bhbj4uIDwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29uc3QgY29tcDIwYiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgaWQ9XCJjb21wMjBiXCIgaTVfbG9vcD1cImxpc3RcIj5SYW5kb20gPHNwYW4+c3BhbiBjb250ZW50PC9zcGFuPi4gPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIwYS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NwYW4nKS5sZW5ndGggPT09IDMsIFwiSW5uZXIgbG9vcCBjb250ZW50IHNob3VsZCBiZSByZXBsaWNhdGVkXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyMGIuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzcGFuJykubGVuZ3RoID09PSAyLCBcIklubmVyIGxvb3AgY29udGVudCBzaG91bGQgYmUgcmVwbGljYXRlZFwiKTtcbiAgICAgICAgICAgIGxldCBsb29wY2FsbGVkMjFhID0gMDtcbiAgICAgICAgICAgIC8vIFRvIGRvIHlvdXIgb3duIGxvZ2ljLCBvdmVycmlkZSB0aGUgbWV0aG9kIGxvb3BQb3N0UHJvY2Vzcy4gbG9vcFBvc3RQcm9jZXNzKCkgaXMgY2FsbGVkIG9uY2UgZm9yIGVhY2ggcm93IGluIHRoZSBpdGVyYWJsZS5cbiAgICAgICAgICAgIGNsYXNzIExvb3BDb21wb25lbnQxIGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIGxvb3BQb3N0UHJvY2Vzcyhyb3csIGFkZGVkQ29udGVudCwgYWxsUm93cywgcHJldmlvdXNDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb3BjYWxsZWQyMWErKzsgLy8gc2ltcGxlIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgQXBpXzEubm9kZUxpc3RTZWxlY3RvcihhZGRlZENvbnRlbnQsICdzcGFuJykuaW5uZXJIVE1MID0gcm93OyAvLyBmaWxsIGZpcnN0IHNwYW4gaW4gdGhlIGFkZGVkIGNvbnRlbnQgd2l0aCBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBBcnJheS5mcm9tKGFsbFJvd3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbGFzdCBpdGVtIGluIHRoZSBpdGVyYWJsZSwgYWRkIGEgcGVyaW9kLiBUaGlzIGxvZ2ljIGRlcGVuZHMgb24gdGhlIGl0ZW1zIGJlaW5nIHVuaXF1ZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvd3MuaW5kZXhPZihyb3cpID09PSByb3dzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFwaV8xLm5vZGVMaXN0U2VsZWN0b3JBbGwoYWRkZWRDb250ZW50LCAnc3BhbicpWzFdLmlubmVySFRNTCA9ICcuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyMWEgPSBuZXcgTG9vcENvbXBvbmVudDEoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sICc8ZGl2IGlkPVwiY29tcDIxYVwiIGk1X2xvb3A9XCIuXCI+QSA8c3Bhbj5zcGFuIGNvbnRlbnQ8L3NwYW4+PHNwYW4+LDwvc3Bhbj4gPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQobG9vcGNhbGxlZDIxYSA9PT0gMywgJ01hbnVhbCBsb29wIHdhcyBjYWxsZWQgb25jZSBwZXIgcm93Jyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIxYS5pbm5lckhUTUwgPT09IFwiQSA8c3Bhbj5PbmU8L3NwYW4+PHNwYW4+LDwvc3Bhbj4gQSA8c3Bhbj5Ud288L3NwYW4+PHNwYW4+LDwvc3Bhbj4gQSA8c3Bhbj5UaHJlZTwvc3Bhbj48c3Bhbj4uPC9zcGFuPiBcIiwgJ01hbnVhbCBsb29wIHNob3VsZCBnZXQgdGhlIGNvcnJlY3QgaW5wdXRzIGFuZCBiZSBhYmxlIHRvIG1vZGlmeSB0aGUgb3V0cHV0LicpO1xuICAgICAgICAgICAgLy8gQnV0IGV2ZW4gdGhvdWdoIHRoYXQncyBwb3NzaWJsZSwgZG9pbmcgZXZlcnl0aGluZyBtYW51YWxseSBpc24ndCBpZGVhbC5cbiAgICAgICAgICAgIC8vIFdoYXQgd291bGQgYmUgaWRlYWwgaXMgaWYgdGhlcmUgd2VyZSBhIHdheSB0byBjb21wb25lbnRpemUgZWFjaCBpdGVtLCBkb2luZyByZXBsYWNlbWVudHMsIGV0Yy5cbiAgICAgICAgICAgIC8vIERFVE9VUiBBSEVBRFxuICAgICAgICAgICAgLy8gU28gbm93IHdlIG1ha2UgYSBkZXRvdXIgaW50byBpbmplY3Rpb24sIGJlY2F1c2UgdGhlIGRlZmF1bHQgd2F5IHRvIGluY2x1ZGUgdmFyaWF0aW9uIGluXG4gICAgICAgICAgICAvLyB0aGUgbG9vcCBpcyBieSBtYWtpbmcgdGhlbSBhIGNvbXBvbmVudCwgYnkgaW5qZWN0aW5nIGNvbXBvbmVudCBjb2RlLlxuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgdGhlIGV4aXN0aW5nIGVsZW1lbnQgaXMga2VwdCBhbmQgY29udmVydGVkIGludG8gYSBjb21wb25lbnQuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgPGRpdj5Eb3duIGluIGhlcmUgaXMgYSBjb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgPGRpdiBpY2hpZ28gaWQ9XCJpbmplY3QwMWFcIj5IZWxsbyA8aS12Pm5hbWU8L2ktdj4gIzE8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2IGljaGlnbyBpNV9zdHlsZT1cImJvbGRcIj5IZWxsbyA8aS12Pm5hbWU8L2ktdj4gIzI8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PmApKTtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0SW5qZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luamVjdDAxYScpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBhcyBjYWxsaW5nIGluamVjdCh2aWV3bW9kZWwsICdbaWNoaWdvXScpO1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWRbMF0uaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5Xb3JsZDwvaS12PiAjMScsICdJbmplY3Qgc2hvdWxkIHJlcGxhY2UgZmlyc3QuJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWRbMF0uY29udGVudCA9PT0gZmlyc3RJbmplY3QsICdJbmplY3Qgd2l0aCBrZWVwPXRydWUgc2hvdWxkIGtlZXAgdGhlIGV4aXN0aW5nIGVsZW1lbnQgaW4gcGxhY2UuJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWRbMV0uaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5Xb3JsZDwvaS12PiAjMicsICdJbmplY3Qgc2hvdWxkIHJlcGxhY2Ugc2Vjb25kLicpO1xuICAgICAgICAgICAgLy8gVXNpbmcgdGhlIGRlZmF1bHQgc2VsZWN0b3Igb2YgW2ljaGlnb10gaXMgcHJvYmFibHkgbm90IGEgZ29vZCBpZGVhLCBiZWNhdXNlIGl0IGRvZXNuJ3QgYWxsb3cgbXVsdGlwbGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudHMgLi4uIG9yIG11bHRpcGxlIHRlc3RzLiBMZXQgbWUgY2xlYW4gdXAuXG4gICAgICAgICAgICBmdW5jdGlvbiBpbmplY3RDbGVhbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2ljaGlnb10nKSkge1xuICAgICAgICAgICAgICAgICAgICBlLnJlbW92ZUF0dHJpYnV0ZSgnaWNoaWdvJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5qZWN0Q2xlYW4oKTtcbiAgICAgICAgICAgIC8vIFRoZSBzdHJlbmd0aCBvZiB0aGUgaW5qZWN0IG1ldGhvZCwgaG93ZXZlciwgaXNuJ3QgYXMgYSBzaG9ydGN1dCBmb3IgdGhlIHJlZ3VsYXIgY29uc3RydWN0b3IuXG4gICAgICAgICAgICAvLyBJdCdzIGFzIGEgd2F5IHRvIHJlcGxhY2UgY3VzdG9tIHRhZ3MuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgXG4gICAgICAgICAgICAgICAgPGluamVjdC10ZXN0LTIgaWQ9XCJpbmplY3QwMmFcIj5IZWxsbyA8aS12Pm5hbWU8L2ktdj4gIzE8L2luamVjdC10ZXN0LTI+XG4gICAgICAgICAgICAgICAgPGluamVjdC10ZXN0LTIgaTVfc3R5bGU9XCJib2xkXCI+SGVsbG8gPGktdj5uYW1lPC9pLXY+ICMyPC9pbmplY3QtdGVzdC0yPlxuICAgICAgICAgICAgICAgIDxpbmplY3QtdGVzdC0zIGlkPVwiaW5qZWN0MDJiXCI+SGVsbG8gPGktdj5uYW1lPC9pLXY+ICMzIDwvaW5qZWN0LXRlc3QtMz5cbiAgICAgICAgICAgICAgICA8aW5qZWN0LXRlc3QtMz5IZWxsbyA8aS12Pm5hbWU8L2ktdj4gIzQgPC9pbmplY3QtdGVzdC0zPlxuICAgICAgICAgICAgICAgIDxkaXYgaWNoaWdvIGlkPVwiZXJhc2VNZVwiIGk1X3N0eWxlPVwiYm9sZFwiPlNvbWV0aGluZyA8aS12PnRvIGJlIHJlcGxhY2VkPC9pLXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBpZD1cImlkMDRkXCI+QWxzbyA8aS12PnRvIGJlIHJlcGxhY2VkPC9pLXY+PC9kaXY+XG4gICAgICAgICAgICBgKSk7XG4gICAgICAgICAgICBjb25zdCBpbmplY3RlZDIgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoJ2luamVjdC10ZXN0LTInLCB7IHJlcGxhY2U6IHRydWUgfSwgQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICBjb25zdCBpbmplY3RlZDJiID0gQXBpXzEuQm91bmRDb21wb25lbnQuaW5qZWN0KCdpbmplY3QtdGVzdC0zJywgeyB0eXBlOiAnc3BhbicsIHJlcGxhY2U6IHRydWUgfSwgQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWQyWzBdLmNvbnRlbnQudGFnTmFtZSA9PT0gJ0RJVicgJiYgaW5qZWN0ZWQyYlswXS5jb250ZW50LnRhZ05hbWUgPT09ICdTUEFOJywgJ0VsZW1lbnRzIChpbmNsdWRpbmcgY3VzdG9tIHRhZ3MpIGFyZSByZXBsYWNlZCB3aGVuIHJlcGxhY2UgaXMgdHJ1ZScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGluamVjdGVkMlsxXS5zdHlsZS5jc3NUZXh0ID09PSAnZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ0V4aXN0aW5nIGF0dHJpYnV0ZXMgYXJlIGtlcHQgZXZlbiB3aGVuIHJlcGxhY2UgaXMgdHJ1ZSBhbmQgYXJlIGF0dHJpYnV0ZSB0ZW1wbGF0ZSBsb2dpYyBpcyBhcHBsaWVkJyk7XG4gICAgICAgICAgICBjb25zdCBpbmplY3RlZDJjID0gQXBpXzEuQm91bmRDb21wb25lbnQuaW5qZWN0KCdbaWNoaWdvXScsIHsgb3V0ZXJIdG1sOiAnPHNwYW4gaTVfc3R5bGU9XCJib2xkXCI+VGhlIG5ldyA8aS12Pm5hbWU8L2ktdj48L3NwYW4+JywgaWQ6ICdpbmplY3QwMmMnLCByZXBsYWNlOiB0cnVlIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCBiYXNpY1ZpZXdNb2RlbCkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGluamVjdGVkMmNbMF0uaW5uZXJIVE1MID09PSAnVGhlIG5ldyA8aS12PldvcmxkPC9pLXY+JywgJ1doZW4gT3V0ZXJIdG1sIHBhc3NlZCwgdGhlIGN1cnJlbnQgaW5uZXJIVE1MIG9mIHRoZSBlbGVtZW50IGlzIGRpc2NhcmRlZCcpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGluamVjdGVkMmNbMF0uaWQgPT09ICdpbmplY3QwMmMnLCAnT3V0ZXJIdG1sIG9wdGlvbnMgYWxzbyB3b3JrIHdpdGggaW5qZWN0aW9uJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWQyY1swXS5jb250ZW50LnRhZ05hbWUgPT09ICdTUEFOJywgJ091dGVySHRtbCBpbmplY3Qgc3RpbGwgd29ya3Mgd2l0aG91dCB1c2luZyBjdXN0b20gdGFncycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGluamVjdGVkMmNbMF0uc3R5bGUuY3NzVGV4dCA9PT0gJ2ZvbnQtd2VpZ2h0OiBib2xkOycsICdPdXRlckh0bWwgaW5qZWN0IGtlZXBzIGV4aXN0aW5nIGF0dHJpYnV0ZXMgaWYgbm90IG92ZXJyaWRkZW4nKTtcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGVkMmQgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoJyNpZDA0ZCcsICc8c3BhbiBpZD1cImluamVjdDAyZFwiIGk1X3N0eWxlPVwiYm9sZFwiPkFsc28gdGhlIG5ldyA8aS12Pm5hbWU8L2ktdj48L3NwYW4+JywgQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoaW5qZWN0ZWQyZFswXS5pZCA9PT0gJ2luamVjdDAyZCcgJiYgaW5qZWN0ZWQyZFswXS5pbm5lckhUTUwgPT09ICdBbHNvIHRoZSBuZXcgPGktdj5Xb3JsZDwvaS12PicsICdPdXRlckh0bWwgcmVwbGFjZSBzaG9ydGN1dCBhbHNvIHdvcmtzJyk7XG4gICAgICAgICAgICBpbmplY3RDbGVhbigpO1xuICAgICAgICAgICAgLy8gV2hlbiBzZWxlY3RvciBpcyBhIHN0cmluZywgdGhlIGVsZW1lbnRzIGFyZSBwaWNrZWQgdXAgdXNpbmcgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpLlxuICAgICAgICAgICAgLy8gSWYgeW91IGFyZSByZS11c2luZyBzZWxlY3RvcnMsIHRoaXMgd2lsbCBwaWNrIHVwIHN0dWZmIHlvdSBkb24ndCB3YW50IHRvIHVzZS5cbiAgICAgICAgICAgIC8vIEZlZWwgZnJlZSB0byBkbyB5b3VyIG93biBxdWVyeSBhbmQgcGFzcyBpbiB0aGUgcmVzdWx0cywgb3Igc2ltcGx5IGFuIGFycmF5IG9mIGVsZW1lbnRzIHRvIHJlcGxhY2UuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImluamVjdC1zZWxlY3Rvci0xXCI+SGVsbG8gPGktdj5uYW1lPC9pLXY+ICMxPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImluamVjdC1zZWxlY3Rvci0xXCI+SGVsbG8gPGktdj5uYW1lPC9pLXY+ICMyPC9kaXY+XG4gICAgICAgICAgICBgLCB7IGlkOiAnaW5qZWN0MDNhJyB9KSk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgPGRpdiBjbGFzcz1cImluamVjdC1zZWxlY3Rvci0xXCI+SGVsbG8gPGktdj4uPC9pLXY+ICMzPC9kaXY+YCwgeyBpZDogJ2luamVjdDAzYicgfSkpO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5kaXYoJ0hlbGxvIDxpLXY+LjwvaS12PiAjNCcsIHsgaWQ6ICdpbmplY3QwM2MnIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGVkMyA9IEFwaV8xLkJvdW5kQ29tcG9uZW50LmluamVjdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5qZWN0MDNhJykucXVlcnlTZWxlY3RvckFsbCgnLmluamVjdC1zZWxlY3Rvci0xJyksIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCBiYXNpY1ZpZXdNb2RlbCkpO1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWQzYiA9IEFwaV8xLkJvdW5kQ29tcG9uZW50LmluamVjdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5qZWN0MDNiJykucXVlcnlTZWxlY3RvckFsbCgnLmluamVjdC1zZWxlY3Rvci0xJyksIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCBcIlNla2FpXCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGVkM2MgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luamVjdDAzYycpLCBBcGlfMS5rdygndmlld01vZGVsJywgXCJXQVJVRE9cIikpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGluamVjdGVkM1swXS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2ktdicpLmlubmVySFRNTCA9PT0gJ1dvcmxkJyAmJiBpbmplY3RlZDNiWzBdLmNvbnRlbnQucXVlcnlTZWxlY3RvcignaS12JykuaW5uZXJIVE1MID09PSAnU2VrYWknLCAnSW5qZWN0aW9uIGFwcGxpZWQgdG8gTm9kZUxpc3Qgd2hlbiBwYXNzZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChpbmplY3RlZDNjWzBdLmNvbnRlbnQucXVlcnlTZWxlY3RvcignaS12JykuaW5uZXJIVE1MID09PSAnV0FSVURPJywgJ0luamVjdGlvbiBhcHBsaWVkIHRvIHNpbmdsZSBlbGVtZW50IHdoZW4gcGFzc2VkJyk7XG4gICAgICAgICAgICAvLyBUaGUgZmluYWwgcGllY2Ugb2YgdGhlIGluamVjdGlvbiByZWNpcGUgaXMgd2hhdCBjb21wb25lbnQgaXMgaW5qZWN0ZWQuXG4gICAgICAgICAgICAvLyBNb3N0IG9mIHRoZXNlIHRlc3RzIGFyZSB1c2luZyB0aGUgZGVmYXVsdCBCb3VuZENvbXBvbmVudCBjbGFzcywgYnV0IGluIHRoZSB3aWxkLFxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG1vc3QgY29tbW9ubHkgYmUgdGhlIHJlbGV2YW50IHZpZXcgY2xhc3MsIHN1Y2ggYXMgT3JkZXJWaWV3IG9yIEJsb2dFbnRyeVZpZXcuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgXG4gICAgICAgICAgICAgICAgPGluamVjdC10ZXN0LTQ+SGVsbG8gPGktdj5uYW1lPC9pLXY+PC9pbmplY3QtdGVzdC00PlxuICAgICAgICAgICAgICAgIDxpbmplY3QtdGVzdC01PkhlbGxvIDxpLXY+bmFtZTwvaS12PjwvaW5qZWN0LXRlc3QtNT5cbiAgICAgICAgICAgIGApKTtcbiAgICAgICAgICAgIGNsYXNzIEluamVjdFRlc3RDb21wb25lbnQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodm0sIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gT2JqZWN0LmFzc2lnbih7fSwgdm0sIHsgbmFtZTogJ0Rlcml2ZWQgQ2xhc3MnIH0pOyAvLyBDaGFuZ2UgbmFtZVxuICAgICAgICAgICAgICAgICAgICBzdXBlcih0bXAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZXNlIGFyZSBib3RoIHdheXMgdG8gZG8gdGhlIHNhbWUgdGhpbmdcbiAgICAgICAgICAgIGNvbnN0IGluamVjdGVkNCA9IEluamVjdFRlc3RDb21wb25lbnQuaW5qZWN0KCdpbmplY3QtdGVzdC00JywgeyByZXBsYWNlOiB0cnVlIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCBiYXNpY1ZpZXdNb2RlbCkpO1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWQ0YiA9IEFwaV8xLkJvdW5kQ29tcG9uZW50LmluamVjdCgnaW5qZWN0LXRlc3QtNScsIHsgcmVwbGFjZTogdHJ1ZSB9LCBJbmplY3RUZXN0Q29tcG9uZW50LCBBcGlfMS5rdygndmlld01vZGVsJywgYmFzaWNWaWV3TW9kZWwpKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChpbmplY3RlZDRbMF0uaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5EZXJpdmVkIENsYXNzPC9pLXY+JyAmJiBpbmplY3RlZDRiWzBdLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+RGVyaXZlZCBDbGFzczwvaS12PicsICdDYW4gcmVwbGFjZSBjb21wb25lbnQgY2xhc3MgaW4gaW5qZWN0KCknKTtcbiAgICAgICAgICAgIC8vIEVORCBERVRPVVJcbiAgICAgICAgICAgIC8vIEFuZCBub3cgdGhhdCB3ZSB1bmRlcnN0YW5kIGluamVjdGlvbiwgd2UgY2FuIGZpbmFsbHkgaGFuZGxlIGxvb3AgaXRlbXMgdXNpbmcgdGhlIGRlZmF1bHQgbG9vcGVyLlxuICAgICAgICAgICAgLy8gVGhpcyB1c2VzIHRoZSBkZWZhdWx0IEJvdW5kQ29tcG9uZW50IGZvciB0aGUgdG9wLWxldmVsLCB1c2luZyBhIHN0cmluZ1tdIHZpZXdNb2RlbCwgYW5kIHRoZSBzYW1lIGNsYXNzIGZvciB0aGVcbiAgICAgICAgICAgIC8vIGl0ZW0tbGV2ZWwsIHVzaW5nIGEgc3RyaW5nIHZpZXdNb2RlbCAobm90IHZhbGlkYXRlZCBieSBUeXBlU2NyaXB0KS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyMiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChbJ09uZScsICdUd28nLCAnVGhyZWUnXSwgYDxkaXYgaWQ9XCJjb21wMjJcIiBpNV9sb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12PiA8L3NwYW4+PC9kaXY+YCkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIyLmlubmVySFRNTCA9PT0gJzxzcGFuIGl2X2JvdW5kX2NvbXBvbmVudD1cIlwiPjxpLXY+T25lPC9pLXY+IDwvc3Bhbj48c3BhbiBpdl9ib3VuZF9jb21wb25lbnQ9XCJcIj48aS12PlR3bzwvaS12PiA8L3NwYW4+PHNwYW4gaXZfYm91bmRfY29tcG9uZW50PVwiXCI+PGktdj5UaHJlZTwvaS12PiA8L3NwYW4+JywgJ0JvdW5kQ29tcG9uZW50IHRlbXBsYXRlIHByb2Nlc3NlZCBlYWNoIGxpbmUgaW5kaXZpZHVhbGx5Jyk7XG4gICAgICAgICAgICAvLyBOb3cgdGVzdCB0aGUgXiAocGFyZW50KSBkYXRhIHNvdXJjZS5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyMmEgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoeyBwYXJlbnRQcm9wZXJ0eTogJ291dCBvZiBUaHJlZScsIGl0ZXI6IFsnT25lJywgJ1R3bycsICdUaHJlZSddIH0sIGA8ZGl2IGlkPVwiY29tcDIyYVwiIGk1X2xvb3A9XCJpdGVyXCI+PHNwYW4+PGktdj4uPC9pLXY+IDxpLXY+XnBhcmVudFByb3BlcnR5PC9pLXY+IDwvc3Bhbj48L2Rpdj5gKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjJhLmlubmVySFRNTCA9PT0gJzxzcGFuIGl2X2JvdW5kX2NvbXBvbmVudD1cIlwiPjxpLXY+T25lPC9pLXY+IDxpLXY+b3V0IG9mIFRocmVlPC9pLXY+IDwvc3Bhbj48c3BhbiBpdl9ib3VuZF9jb21wb25lbnQ9XCJcIj48aS12PlR3bzwvaS12PiA8aS12Pm91dCBvZiBUaHJlZTwvaS12PiA8L3NwYW4+PHNwYW4gaXZfYm91bmRfY29tcG9uZW50PVwiXCI+PGktdj5UaHJlZTwvaS12PiA8aS12Pm91dCBvZiBUaHJlZTwvaS12PiA8L3NwYW4+JywgJ0JvdW5kQ29tcG9uZW50IGxvb3AgY29udGFpbnMgcmVmZXJlbmNlIHRvIHBhcmVudCB2aWV3TW9kZWwgd2hlbiByZWZlcmVuY2VkIGJ5IF4nKTtcbiAgICAgICAgICAgIC8vIFRoZSBpLXYgOnNvdXJjZSBwcm9wZXJ0eSBsZXRzIHlvdSBncmFiIGRhdGEgZnJvbSBhbnkgYm91bmRDb21wb25lbnQgb24gdGhlIHBhZ2UsIHJlZmVyZW5jZWQgYnkgaWRcbiAgICAgICAgICAgIGNvbnN0IGNvbXAyMmIxID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KFwib3V0IG9mIFRocmVlXCIsIHsgaWQ6IFwiY29tcDIyYjFcIiwgdHlwZTogXCJzcGFuXCIgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBjb25zdCBjb21wMjJiID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KFsnT25lJywgJ1R3bycsICdUaHJlZSddLCBgPGRpdiBpZD1cImNvbXAyMmJcIiBpNV9sb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12PiA8aS12IDpzb3VyY2U9XCJjb21wMjJiMVwiPi48L2ktdj4gPC9zcGFuPjwvZGl2PmApLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyMmIuaW5uZXJIVE1MID09PSAnPHNwYW4gaXZfYm91bmRfY29tcG9uZW50PVwiXCI+PGktdj5PbmU8L2ktdj4gPGktdiA6c291cmNlPVwiY29tcDIyYjFcIj5vdXQgb2YgVGhyZWU8L2ktdj4gPC9zcGFuPjxzcGFuIGl2X2JvdW5kX2NvbXBvbmVudD1cIlwiPjxpLXY+VHdvPC9pLXY+IDxpLXYgOnNvdXJjZT1cImNvbXAyMmIxXCI+b3V0IG9mIFRocmVlPC9pLXY+IDwvc3Bhbj48c3BhbiBpdl9ib3VuZF9jb21wb25lbnQ9XCJcIj48aS12PlRocmVlPC9pLXY+IDxpLXYgOnNvdXJjZT1cImNvbXAyMmIxXCI+b3V0IG9mIFRocmVlPC9pLXY+IDwvc3Bhbj4nLCAnRGF0YSBmZXRjaGVkIGZyb20gb3RoZXIgY29tcG9uZW50IHdoZW4gcmVmZXJlbmNlZCBieSA6c291cmNlJyk7XG4gICAgICAgICAgICAvLyBUaGUgOnNvdXJjZSBwcm9wZXJ0eSBhbHNvIHdvcmtzIGZvciBvdGhlciBjdXN0b20gYXR0cmlidXRlcyB0aGF0IGFyZSB1c2VkIHRvIHJlbmRlciB0aGUgZGF0YSAoYWxsIGJ1dCB3cml0ZSB0YXJnZXRzKVxuICAgICAgICAgICAgY29uc3QgY29tcDIyYyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh7IHBhc3NGYWlsOiBcIlBBU1NFRFwiLCBmYWxzeTogZmFsc2UsIHN0eWxlOiBcInRleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7XCIgfSwgeyBpZDogXCJjb21wMjJjXCIsIHR5cGU6IFwic3BhblwiIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29uc3QgY29tcDIyZCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh7IHBhc3NGYWlsOiBcIkZBSUxFRFwiLCBmYWxzeTogdHJ1ZSB9LCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnB1dFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaTVfc291cmNlOiBcImNvbXAyMmNcIixcbiAgICAgICAgICAgICAgICAgICAgaTVfYXR0cl9hdHRyaWJ1dGVjaGVjazogXCJwYXNzRmFpbFwiLFxuICAgICAgICAgICAgICAgICAgICBpNV92YWx1ZTogXCJwYXNzRmFpbFwiLFxuICAgICAgICAgICAgICAgICAgICBpNV9jbGFzczogXCJwYXNzRmFpbFwiLFxuICAgICAgICAgICAgICAgICAgICBpNV9zdHlsZTogXCJzdHlsZVwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIyZC5jb250ZW50LmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlY2hlY2snKSA9PT0gXCJQQVNTRURcIiwgXCJPdGhlciBjb21wb25lbnQgY2FuIGJlIHVzZWQgYXMgc291cmNlIGZvciA6YXR0cjp2YWx1ZVwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjJkLmNvbnRlbnQudmFsdWUgPT09IFwiUEFTU0VEXCIsIFwiT3RoZXIgY29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIHNvdXJjZSBmb3IgOnZhbHVlXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyMmQuY29udGVudC5jbGFzc05hbWUgPT09IFwiUEFTU0VEXCIsIFwiT3RoZXIgY29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIHNvdXJjZSBmb3IgOmNsYXNzXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyMmQuY29udGVudC5zdHlsZS50ZXh0RGVjb3JhdGlvbiA9PT0gXCJ1bmRlcmxpbmVcIiwgXCJPdGhlciBjb21wb25lbnQgY2FuIGJlIHVzZWQgYXMgc291cmNlIGZvciA6c3R5bGVcIik7XG4gICAgICAgICAgICBjb25zdCBjb21wMjJlID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHsgcGFzc0ZhaWw6IFwiRkFJTEVEXCIsIGZhbHN5OiB0cnVlIH0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRpdlwiLFxuICAgICAgICAgICAgICAgIGlkOiBcImNvbXAyMmVcIixcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogJzxkaXY+PGktdiAjY29tcDIyZT4uPC9pLXY+PC9kaXY+JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaTVfc291cmNlOiBcImNvbXAyMmNcIixcbiAgICAgICAgICAgICAgICAgICAgaTVfc3dpdGNoMF9wYXNzZWQ6IFwiZmFsc3lcIixcbiAgICAgICAgICAgICAgICAgICAgaTVfaWY6IFwiZmFsc3lcIixcbiAgICAgICAgICAgICAgICAgICAgaTVfbG9vcDogXCJwYXNzRmFpbFwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIyZS5jb250ZW50LmNsYXNzTmFtZSA9PT0gXCJwYXNzZWRcIiwgXCJPdGhlciBjb21wb25lbnQgY2FuIGJlIHVzZWQgYXMgc291cmNlIGZvciA6c3dpdGNoOmNsYXNzXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyMmUuY29udGVudC5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiwgXCJPdGhlciBjb21wb25lbnQgY2FuIGJlIHVzZWQgYXMgc291cmNlIGZvciA6aWZcIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoQXJyYXkuZnJvbShjb21wMjJlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcImRpdlwiKSkubGVuZ3RoID09PSA2ICYmIGNvbXAyMmUuY29udGVudC5xdWVyeVNlbGVjdG9yKFwiZGl2XCIpLmlubmVyVGV4dCA9PT0gXCJQXCIsIFwiT3RoZXIgY29tcG9uZW50IGNhbiBiZSB1c2VkIGFzIHNvcnVjZSBmb3IgOmxvb3BcIik7XG4gICAgICAgICAgICAvLyBPZiBjb3Vyc2UsIHRoZSBjb21wb25lbnQgY2FuIGJlIGFueSBjbGFzcyB0aGF0IGluaGVyaXRzIEJvdW5kQ29tcG9uZW50XG4gICAgICAgICAgICBjbGFzcyBMb29wQ29tcG9uZW50MiBleHRlbmRzIEFwaV8xLkJvdW5kQ29tcG9uZW50IHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyM2EgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sIHtcbiAgICAgICAgICAgICAgICBvdXRlckh0bWw6IGA8ZGl2IGlkPVwiY29tcDIzYVwiIGk1X2xvb3A9XCIuXCI+PHNwYW4+PGktdj4uPC9pLXY+IDwvc3Bhbj48L2Rpdj5gXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjNhLmNvbnRlbnQucXVlcnlTZWxlY3Rvcignc3BhbicpLmlubmVySFRNTCA9PT0gJzxpLXY+T25lPC9pLXY+ICcsICdTdWNjZXNzZnVsbHkgdXNlIGRlcml2ZWQgY2xhc3MnKTtcbiAgICAgICAgICAgIC8vIEluIHRoZXNlIGNhc2VzLCB3aGVuIHlvdSBoYXZlIGEgdmlldyBjbGFzcyBmb3IgdGhlIHRvcC1sZXZlbCBjb21wb25lbnQsIHlvdSBwcm9iYWJseVxuICAgICAgICAgICAgLy8gZG9uJ3Qgd2FudCB0byB1c2UgdGhlIGRlZmF1bHQgQm91bmRDb21wb25lbnQgY2xhc3MgZm9yIHRoZSBsb29wIGl0ZW1zLiBTZXQgdGhlIGxvb3BJdGVtQ2xhc3MgdG9cbiAgICAgICAgICAgIC8vIGluZGljYXRlIGEgY2xhc3MgdG8gdXNlIChvZiBjb3Vyc2UsIGlmIHlvdSBkb24ndCB1c2UgdGhlIGRlZmF1bHQgbG9vcGVyLCB5b3UgY2FuIGRvIHdoYXRldmVyKS5cbiAgICAgICAgICAgIC8vIFRoZSBpbXBvcnRhbnQgcG9pbnQgaW4gc29tZSBjb250ZXh0cyBpcyB0aGF0IHRoZSBwYXJlbnQgY29tcG9uZW50IGlzIHBhc3NlZCBvbiBvcHRpb25zLnBhcmVudC5cbiAgICAgICAgICAgIC8vIFVzZSBpdCBpbiB0aGUgb2NjYXNpb25hbCBjYXNlIHdoZXJlIGEgY2hpbGQgbmVlZHMgdG8ga25vdyBpdHMgcGFyZW50LlxuICAgICAgICAgICAgLy8gSWYgeW91IHdhbnQgdG8gaGF2ZSBkaWZmZXJlbnQgY29tcG9uZW50cyBmb3IgZGlmZmVyZW50IGNoaWxkcmVuIChmb3IgZXhhbXBsZSwgYSB0aXRsZSBjb21wb25lbnQgZm9sbG93ZWQgYnlcbiAgICAgICAgICAgIC8vIGFuIGltYWdlIGNvbXBvbmVudCksIGVpdGhlciBlbmNhcHN1bGF0ZSB0aGVtIGluIGEgcGFyZW50IGNvbXBvbmVudCBvciBkb24ndCB1c2UgdGhlIGRlZmF1bHQgY2xhc3MvbG9vcC5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRlbnQgaXMgbG9vcGVkLCBiZWZvcmUgcmVuZGVyKCkgaXMgY2FsbGVkLCB0aGUgaW5uZXJIVE1MIGlzIGJsYW5rLiBJdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBrZWVwIHRoZVxuICAgICAgICAgICAgLy8gdGVtcGxhdGUgY29udGVudCwgYnV0IGluIHRoZSBjYXNlIG9mIGFuIGFzeW5jIGNvbXBvbmVudCwgdGhhdCB3b3VsZCBjcmVhdGUgYSBmbGFzaCBvZiB1bnByb2Nlc3NlZCBjb250ZW50LiBUaGUgd2F5XG4gICAgICAgICAgICAvLyBpdCdzIGJlaW5nIGRvbmUgaGVyZSwgaXQgZ29lcyBmcm9tIGJsYW5rIHRvIGhhdmluZyBkYXRhLiBNdWNoIGNsZWFuZXIuXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBCeSBkZWZhdWx0LCByZW5kZXIoKSAod2hpY2ggY29udGFpbnMgdGhlIGxvb3BQb3N0UHJvY2VzcygpIGNhbGwpIGlzIGNhbGxlZCBpbiB0aGUgY29uc3RydWN0b3Igb2YgQm91bmRDb21wb25lbnQuXG4gICAgICAgICAgICAvLyBJZiB5b3VyIGNoaWxkIGNvbXBvbmVudCBkZXBlbmRzIG9uIGxvZ2ljIHNldCB1cCBpbiB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIHBhcmVudCBjb21wb25lbnQsIHRoaXMgd2lsbCBwcm9kdWNlIGJ1Z3MuXG4gICAgICAgICAgICAvLyBMaWZlY3ljbGU6IE1haW4gQ1RPUigpID0+IE1haW4gc3VwZXIoKSA9PiBNYWluIHJlbmRlcigpID0+IExvb3AgaW5qZWN0ID0+IEl0ZW0gQ1RPUigpID0+IEl0ZW0gQ1RPUiBlbmQgPT4gTWFpbiBzdXBlciBlbmQgPT4gTWFpbiBDVE9SIGJvZHkgKFR5cGVTY3JpcHQgZmllbGQgaW5pdGlhbGl6YXRpb24pID0+IE1haW4gQ1RPUiBlbmRcbiAgICAgICAgICAgIC8vIEFzIHlvdSBjYW4gc2VlIGZyb20gdGhlIGxpZmVjeWNsZSwgYW55IGxvZ2ljIGluIHRoZSBpdGVtIENUT1IgaXMgY2FsbGVkIGJlZm9yZSBNYWluIENUT1IgYm9keS5cbiAgICAgICAgICAgIC8vIEl0IGNhbiBiZSBmaXhlZCBpbiB0d28gd2F5cy4gT25lIGlzIHRvIHNldCBhc3luYzogdHJ1ZSBpbiB0aGUgb3B0aW9ucywgY3JlYXRpbmcgYW4gYXN5bmMgY29tcG9uZW50LlxuICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBpcyB0byBzZXQgZGVmZXI6IHRydWUgYW5kIGNhbGwgcmVuZGVyKCkgbWFudWFsbHkgd2hlbiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSBuZWl0aGVyIG9mIHRoZXNlIGlzIGRlZmF1bHQuXG4gICAgICAgICAgICBsZXQgbG9vcGNvdW50ZXIyM2IgPSAwO1xuICAgICAgICAgICAgY2xhc3MgTG9vcENvbXBvbmVudDMgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodm0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgZGVmZXJyZWQgb3IgYXN5bmMsIHNvIGlmIHRoaXMgcmVmZXJlbmNlZCB0aGUgcGFyZW50IGNvbXBvbmVudCwgdGhlIGxvb3Bjb3VudGVyIGZpZWxkIHdvdWxkIGJlIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IGxvb3Bjb3VudGVyMjNiKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5kYXRhc2V0LmlkID0gdGhpcy5pbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyM2IgPSBuZXcgTG9vcENvbXBvbmVudDIoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sIG5ldyBBcGlfMS5PdXRlckh0bWxCaW5kaW5nT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgb3V0ZXJIdG1sOiBgPGRpdiBpZD1cImNvbXAyM2JcIiBpNV9sb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12PiA8L3NwYW4+PC9kaXY+YCxcbiAgICAgICAgICAgICAgICBsb29wSXRlbUNsYXNzOiBMb29wQ29tcG9uZW50MyxcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UgLy8gTm90IHVzaW5nIGFzeW5jIHJlbmRlciBiZWNhdXNlIGl0IG1ha2VzIHRlc3Rpbmcgc3VjayAodGhpcyBpcyBkZWZhdWx0KVxuICAgICAgICAgICAgfSkpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyM2IuY29udGVudC5xdWVyeVNlbGVjdG9yKCdzcGFuOm50aC1jaGlsZCgyKScpLmRhdGFzZXQuaWQgPT09ICcxJywgJ1N1Y2Nlc3NmdWxseSBjYWxsIGNvbnN0cnVjdG9yIG9mIGRlcml2ZWQgY2xhc3MnKTtcbiAgICAgICAgICAgIGxvb3Bjb3VudGVyMjNiID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAyM2MgPSBuZXcgTG9vcENvbXBvbmVudDIoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sIG5ldyBBcGlfMS5PdXRlckh0bWxCaW5kaW5nT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgb3V0ZXJIdG1sOiBgPGRpdiBpZD1cImNvbXAyM2NcIiBpNV9sb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12PiA8L3NwYW4+PC9kaXY+YCxcbiAgICAgICAgICAgICAgICBsb29wSXRlbUNsYXNzOiBMb29wQ29tcG9uZW50MyxcbiAgICAgICAgICAgICAgICBkZWZlcjogdHJ1ZVxuICAgICAgICAgICAgfSkpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyM2MuaW5uZXJIVE1MID09PSAnJywgXCJEZWZlciB0cnVlIHByZXZlbnRzIGNhbGxpbmcgb2YgdGhlIHJlbmRlcigpIG1ldGhvZFwiKTtcbiAgICAgICAgICAgIGNvbXAyM2MucmVuZGVyKCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoY29tcDIzYy5pbm5lckhUTUwgPT09IGNvbXAyM2IuaW5uZXJIVE1MLCBcIlJlbmRlciBjYW4gYmUgY2FsbGVkIGF0IGFueSB0aW1lIGFmdGVyLCBldmVuIG91dHNpZGUgdGhlIGRlcml2ZWQgY29uc3RydWN0b3JcIik7XG4gICAgICAgICAgICAvLyBJZiB5b3Ugd2FudCB0byBkbyBub3RoaW5nIGFmdGVyIGNyZWF0aW9uLCB0aGUgZWFzaWVzdCB3YXkgaXMgdG8gc3VwcGx5IGFuIGVtcHR5IG1ldGhvZCwgYXMgaW4gdGhlIGV4YW1wbGUgaTVfbG9vcDpudWxsPVwiLlwiXG4gICAgICAgICAgICBjb25zdCBjb21wMjQgPSBuZXcgTG9vcENvbXBvbmVudDIoWydPbmUnLCAnVHdvJywgJ1RocmVlJ10sIG5ldyBBcGlfMS5PdXRlckh0bWxCaW5kaW5nT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgb3V0ZXJIdG1sOiBgPGRpdiBpZD1cImNvbXAyNFwiIGk1X2xvb3A6bnVsbD1cIi5cIj48c3Bhbj48aS12Pi48L2ktdj4gPC9zcGFuPjwvZGl2PmAsXG4gICAgICAgICAgICAgICAgbG9vcEl0ZW1DbGFzczogTG9vcENvbXBvbmVudDNcbiAgICAgICAgICAgIH0pKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjQuaW5uZXJIVE1MID09PSAnPHNwYW4+PGktdj4uPC9pLXY+IDwvc3Bhbj48c3Bhbj48aS12Pi48L2ktdj4gPC9zcGFuPjxzcGFuPjxpLXY+LjwvaS12PiA8L3NwYW4+JywgJ051bGwgbG9vcCBoYW5kbGVyIGRvZXMgbm90IGluamVjdCBhbnkgY29tcG9uZW50Jyk7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHRpbWUsIEkgZGVjaWRlZCB0byBhZGQgYSB3YXkgdG8gYWNjZXNzIHByb3BlcnRpZXMgb2YgdGhlIHZpZXcsIHJhdGhlciB0aGFuIHRoZSB2aWV3TW9kZWwsIGJ5XG4gICAgICAgICAgICAvLyBwcmVmaXhpbmcgdGhlbSB3aXRoIFwidGhpcy5cIiBUaGlzIHdvdWxkIG5lZWQgdG8gYmUgaW4gYSBkZXJpdmVkIGNsYXNzLCBiZWNhdXNlIG5vbmUgb2YgdGhlIG1ldGhvZHNcbiAgICAgICAgICAgIC8vIGJhc2UgY2xhc3MgYXJlIGFwcGxpY2FibGUuXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBOb3JtYWxseSwgcmVuZGVyKCkgaXMgY2FsbGVkIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBCb3VuZENvbXBvbmVudC4gSW4gdGhlIHN1cGVyKCkgY2FsbCBvZiB5b3VyIGNsYXNzLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdXNlIHByb2JsZW1zIGluIG1vc3QgY2FzZXMgd2hlcmUgcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRvIGhhbmRsZSB0aGlzLCB1c2luZyB0aGlzLnByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIHRyaWdnZXJzIGF1dG9tYXRpYyB7IGRlZmVyOiB0cnVlIH0gYmVoYXZpb3IuXG4gICAgICAgICAgICAvLyBUbyBoYW5kbGUgaXQsIHlvdSBjYW4gc2V0IGFzeW5jIHRvIHRydWUgb3IgeW91IGNhbiBjYWxsIHJlbmRlcigpIGF0IHRoZSBlbmQgb2YgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY2xhc3MgTG9vcENvbXBvbmVudDQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodm0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgeW91IGxvb2sgYXQgdGhlIEpTIHRoYXQgVFMgZ2VuZXJhdGVzLCB5b3UnbGwgc2VlIHRoYXQgdGhpcy5pbmRleCA9IDAgaXNuJ3QgY2FsbGVkIHVudGlsIGFmdGVyIHN1cGVyKCkuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIHJlbmRlcigpIChjYWxsZWQgaW4gc3VwZXIoKSksIGluZGV4IGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleCA9IG9wdGlvbnMubG9vcFBhcmVudC52aWV3TW9kZWwuaW5kZXhPZih2bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29tcDI1YSA9IG5ldyBMb29wQ29tcG9uZW50MihbJ09uZScsICdUd28nLCAnVGhyZWUnXSwgbmV3IEFwaV8xLk91dGVySHRtbEJpbmRpbmdPcHRpb25zKHtcbiAgICAgICAgICAgICAgICBvdXRlckh0bWw6IGA8ZGl2IGlkPVwiY29tcDI1YVwiIGk1X2xvb3A9XCIuXCI+PHNwYW4gaTVfYXR0cjpkYXRhLWlkPVwidGhpcy5pbmRleFwiPjxpLXY+LjwvaS12PiA8L3NwYW4+PC9kaXY+YCxcbiAgICAgICAgICAgICAgICBsb29wSXRlbUNsYXNzOiBMb29wQ29tcG9uZW50NFxuICAgICAgICAgICAgfSkpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyNWEuaW5uZXJIVE1MID09PSAnPHNwYW4gaTVfYXR0cjpkYXRhLWlkPVwidGhpcy5pbmRleFwiIGl2X2xvb3BfY29tcG9uZW50ND1cIlwiPjxpLXY+LjwvaS12PiA8L3NwYW4+PHNwYW4gaTVfYXR0cjpkYXRhLWlkPVwidGhpcy5pbmRleFwiIGl2X2xvb3BfY29tcG9uZW50ND1cIlwiPjxpLXY+LjwvaS12PiA8L3NwYW4+PHNwYW4gaTVfYXR0cjpkYXRhLWlkPVwidGhpcy5pbmRleFwiIGl2X2xvb3BfY29tcG9uZW50ND1cIlwiPjxpLXY+LjwvaS12PiA8L3NwYW4+JywgJ1JlbmRlcigpIG5vdCBjYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIFwidGhpcy5cIiB1c2VkLicpO1xuICAgICAgICAgICAgLy8gWW91IGNhbiB1c2UgZmllbGRzIHdpdGhvdXQgZGlmZmljdWx0eSBpZiBhc3luYyBpcyB0cnVlXG4gICAgICAgICAgICBjb25zdCBjb21wMjViID0gbmV3IExvb3BDb21wb25lbnQyKFsnT25lJywgJ1R3bycsICdUaHJlZSddLCBuZXcgQXBpXzEuT3V0ZXJIdG1sQmluZGluZ09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIG91dGVySHRtbDogYDxkaXYgaWQ9XCJjb21wMjViXCIgaTVfbG9vcD1cIi5cIj48c3BhbiBpNV9hdHRyOmRhdGEtaWQ9XCJ0aGlzLmluZGV4XCI+PGktdj50aGlzLmluZGV4PC9pLXY+OiA8aS12Pi48L2ktdj4gPC9zcGFuPjwvZGl2PmAsXG4gICAgICAgICAgICAgICAgbG9vcEl0ZW1DbGFzczogTG9vcENvbXBvbmVudDQsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgICAgICAgIH0pKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgd2h5IEkgaGF0ZSB0ZXN0aW5nIHdpdGggYXN5bmMuIFRocm93IGEgZGVidWdnZXIgaW4gYW5kIHRoaXMgd2lsbCBmYWlsOlxuICAgICAgICAgICAgdGhpcy5sb2coJ0FzeW5jIHRlc3QgaW5pdGF0ZWQgZm9yIDI1Yi4nKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29tcDI1YiBzcGFuOm50aC1jaGlsZCgyKScpLmRhdGFzZXQuaWQgPT09ICcxJywgJ3RoaXMuaW5kZXggY2FuIGJlIGFjY2Vzc2VkIGFzeW5jaHJvbm91c2x5JykpO1xuICAgICAgICAgICAgLy8gSWYgeW91IHdhbnQgdG8gZG8gYSBzeW5jaHJvbm91cyBjYWxsLCBkbyBpdCB0aGlzIHdheS5cbiAgICAgICAgICAgIGNsYXNzIExvb3BDb21wb25lbnQ1IGV4dGVuZHMgTG9vcENvbXBvbmVudDQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZtLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZtLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTsgLy8gTm93IGl0J3Mgc2FmZSB0byBjYWxsIHJlbmRlci5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb21wMjVjID0gbmV3IExvb3BDb21wb25lbnQyKFsnT25lJywgJ1R3bycsICdUaHJlZSddLCBuZXcgQXBpXzEuT3V0ZXJIdG1sQmluZGluZ09wdGlvbnMoe1xuICAgICAgICAgICAgICAgIG91dGVySHRtbDogYDxkaXYgaWQ9XCJjb21wMjVjXCIgaTVfbG9vcD1cIi5cIj48c3BhbiBpNV9hdHRyOmRhdGEtaWQ9XCJ0aGlzLmluZGV4XCI+PGktdj50aGlzLmluZGV4PC9pLXY+OiA8aS12Pi48L2ktdj4gPC9zcGFuPjwvZGl2PmAsXG4gICAgICAgICAgICAgICAgbG9vcEl0ZW1DbGFzczogTG9vcENvbXBvbmVudDVcbiAgICAgICAgICAgIH0pKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjY29tcDI1YyBzcGFuOm50aC1jaGlsZCgyKScpLmRhdGFzZXQuaWQgPT09ICcxJywgJ3RoaXMuaW5kZXggY2FuIGJlIGFjY2Vzc2VkIGlmIHJlbmRlcigpIGNhbGxlZCBpbiBjb25zdHJ1Y3RvcicpO1xuICAgICAgICAgICAgLy8gSSB3YXJuZWQgeW91IGFnYWluc3QgaGF2aW5nIHJlcGxhY2VtZW50IHZhbHVlcyB0aGF0IHJldHVybiBvdGhlciBjb21wb25lbnRzLCBiZWNhdXNlIHRoZSBwcm9jZXNzIG9mIHJlZnJlc2hpbmcgdGhlIGRhdGFcbiAgICAgICAgICAgIC8vIChpZiBhbiBvYnNlcnZhYmxlIGlzIGluIHBsYXkpIHdpbGwgZGVsZXRlIHlvdXIgcmVmZXJlbmNlcy4gQW5kIHRoZSB0aW1pbmcgY2FuIGJlIHRyaWNreS5cbiAgICAgICAgICAgIC8vIFRoYXQgc2FpZCwgdGhlcmUgc2hvdWxkIGJlIG5vIGlzc3VlcyB3aXRoIG5lc3RpbmcgYSBjb21wb25lbnQgaW5zaWRlICAodGhlIHN0YXRpYyBwb3J0aW9uIG9mKSBhbm90aGVyIGNvbXBvbmVudC4gRG9uJ3RcbiAgICAgICAgICAgIC8vIGxvb3AsIGJlY2F1c2UgbG9vcHMgYXJlIGFsbCBkeW5hbWljLlxuICAgICAgICAgICAgLy8gQnV0IHRoZXJlIHdpbGwgYmUgaXNzdWVzIHdpdGhvdXQgYWRkaXRpb25hbCB3b3JrLlxuICAgICAgICAgICAgLy8gSW4gdGhlIGZvbGxvd2luZyBleGFtcGxlLCB5b3UnbGwgc2VlIHRoYXQgd2l0aG91dCBmaWx0ZXJpbmcgaS12IHRhZ3MsIHRoZSByZXBsYWNlbWVudCBpbiBjb21wLTIgd2lsbCB3YW50IHRvIHByaW50XG4gICAgICAgICAgICAvLyBbT2JqZWN0IG9iamVjdF0uIFdoaWNoIHdpbGwgYnJlYWsgY29tcC0yJ3MgcmVwbGFjZW1lbnQuXG4gICAgICAgICAgICAvLyBCdXQgYnkgc2V0dGluZyB0aGUgbmFtZSBhbmQgbWF0Y2hpbmcgaXQgdXAgaW4gdGhlIFwiY29tcG9uZW50XCIgcHJvcGVydHkgb2YgdGhlIGktdiB0YWdzLCB0aGUgcmVwbGFjZW1lbnRzIGFyZSBmaWx0ZXJlZCB0b1xuICAgICAgICAgICAgLy8gb25seSBjZXJ0YWluIGNvbXBvbmVudHMuXG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihgXG4gICAgICAgICAgICAgICAgPGNvbXAtMT5cbiAgICAgICAgICAgICAgICAgICAgSGVsbG8gPGktdiAjY29tcDI2YT5uYW1lPC9pLXY+XG4gICAgICAgICAgICAgICAgICAgIDxjb21wLTI+VGhpcyBpcyA8aS12ICNjb21wMjZiPi48L2ktdj48L2NvbXAtMj5cbiAgICAgICAgICAgICAgICA8L2NvbXAtMT5cbiAgICAgICAgICAgIGApKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbXAyNmEgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoJ2NvbXAtMScsIHsgcmVwbGFjZTogdHJ1ZSwgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTERpdkVsZW1lbnQsIGlkOiAnY29tcDI2YScgfSwgQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICAvLyBZb3UgY2FuIHNldCBuYW1lIGJ5IGF0dHJpYnV0ZSBpdl9uYW1lIG9yIGJ5IG5hbWUgb3B0aW9uLlxuICAgICAgICAgICAgY29uc3QgY29tcDI2YiA9IEFwaV8xLkJvdW5kQ29tcG9uZW50LmluamVjdCgnY29tcC0yJywgeyByZXBsYWNlOiB0cnVlLCB0eXBlOiBBcGlfMS5lbGVtZW50VHlwZS5IVE1MRGl2RWxlbWVudCwgaWQ6ICdjb21wMjZiJyB9LCBBcGlfMS5rdygndmlld01vZGVsJywgJ25lc3RlZCcpKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjZhWzBdLmlubmVySFRNTC5pbmNsdWRlcygnSGVsbG8gPGktdiAjY29tcDI2YT1cIlwiPldvcmxkPC9pLXY+JyksICdJLVYgdGFncyBhcmUgcmVwbGFjZWQgYmFzZWQgb24gdGhlaXIgYXNzaWduZWQgY29tcG9uZW50cycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyNmFbMF0uaW5uZXJIVE1MLmluY2x1ZGVzKCc8ZGl2IGlkPVwiY29tcDI2YlwiIGl2X2JvdW5kX2NvbXBvbmVudD1cIlwiPlRoaXMgaXMgPGktdiAjY29tcDI2Yj1cIlwiPm5lc3RlZDwvaS12PjwvZGl2PicpLCAnSS1WIHRhZ3MgYXJlIHJlc3RyaWN0ZWQgdG8gdGhlaXIgYXNzaWduZWQgY29tcG9uZW50cycpO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5kaXYoYFxuICAgICAgICAgICAgICAgIDxjb21wLTE+XG4gICAgICAgICAgICAgICAgICAgIEhlbGxvIDxpLXY+bmFtZTwvaS12PlxuICAgICAgICAgICAgICAgICAgICA8Y29tcC0yPlRoaXMgaXMgPGktdiBjb21wb25lbnQ9XCJjb21wMjZkXCI+LjwvaS12PjwvY29tcC0yPlxuICAgICAgICAgICAgICAgIDwvY29tcC0xPlxuICAgICAgICAgICAgYCkpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBwcmV0dHkgcmlza3kgYmVjYXVzZSBpLXYgaGFzIG5vIHJlZmVyZW5jZSBzbyBJIGRvbid0IHJlY29tbWVuZCBiZWluZyBsYXp5IGxpa2UgdGhpcy5cbiAgICAgICAgICAgIGNvbnN0IGNvbXAyNmMgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoJ2NvbXAtMScsIHsgcmVwbGFjZTogdHJ1ZSwgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTERpdkVsZW1lbnQsIGlkOiAnY29tcDI2YycgfSwgQXBpXzEua3coJ3ZpZXdNb2RlbCcsIGJhc2ljVmlld01vZGVsKSk7XG4gICAgICAgICAgICBjb25zdCBjb21wMjZkID0gQXBpXzEuQm91bmRDb21wb25lbnQuaW5qZWN0KCdjb21wLTInLCB7IHJlcGxhY2U6IHRydWUsIHR5cGU6IEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCBpZDogJ2NvbXAyNmQnIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCAnbmVzdGVkJykpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGNvbXAyNmNbMF0uaW5uZXJIVE1MLmluY2x1ZGVzKCdIZWxsbyA8aS12PldvcmxkPC9pLXY+JyksICdOb24tc2NvcGVkIEktViB0YWdzIG1hdGNoIGZpcnN0IGNvbXBvbmVudCByZXF1ZXN0ZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjb21wMjZjWzBdLmlubmVySFRNTC5pbmNsdWRlcygnPGRpdiBpZD1cImNvbXAyNmRcIiBpdl9ib3VuZF9jb21wb25lbnQ9XCJcIj5UaGlzIGlzIDxpLXYgY29tcG9uZW50PVwiY29tcDI2ZFwiPm5lc3RlZDwvaS12PjwvZGl2PicpLCAnSS1WIHRhZ3MgYXJlIHJlcGxhY2VkIGJhc2VkIG9uIHRoZWlyIGFzc2lnbmVkIGNvbXBvbmVudHMgd2hlbiBib3VuZCB1c2luZyBmdWxsIHN5bnRheCcpO1xuICAgICAgICAgICAgLy8gU0hPUlRDVVRTXG4gICAgICAgICAgICAvLyBUbyBtYWtlIHRoaW5ncyBxdWlja2VyLCB0aGVyZSBpcyBhIHNob3J0Y3V0IGZvciB0aGUgXCJpNV9cIiBwcmVmaXggb24gY3VzdG9tIGF0dHJpYnV0ZXM6IDpcbiAgICAgICAgICAgIC8vIFRoaXMgbWFrZXMgOmF0dHIsIDp2YWx1ZSwgOmxvb3AsIGFuZCBzbyBmb3J0aC5cbiAgICAgICAgICAgIC8vIDogaXMgY29tcGxldGVseSBub24tc3RhbmRhcmQgYnV0IGl0IGlzIGxlZ2FsIGluIGF0dHJpYnV0ZSBuYW1lcy5cbiAgICAgICAgICAgIGNvbnN0IHNob3J0MSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgOmNsYXNzPVwiY3NzQ2xhc3NcIj5TaG9ydGN1dDwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0MS5jbGFzc0xpc3QudG9TdHJpbmcoKSA9PT0gJ2RvZXMtbm90aGluZycsICc6Y2xhc3Mgc2hvcnRjdXQgZm9yIGk1X2NsYXNzJyk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydDIgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8c3BhbiA6c3R5bGU9XCJibG9ja1wiPlNob3J0Y3V0PC9zcGFuPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0Mi5zdHlsZS5kaXNwbGF5ID09PSAnYmxvY2snLCAnOnN0eWxlIHNob3J0Y3V0IGZvciBpNV9zdHlsZScpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnQzID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGRpdiA6dGV4dD1cInJhd0h0bWxcIj48L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChzaG9ydDMuaW5uZXJIVE1MID09PSAnPGktdj5IZWxsbyAmbHQ7ZW0mZ3Q7V29ybGQmbHQ7L2VtJmd0OzwvaS12PicsIFwiOnRleHQgc2hvcnRjdXQgZm9yIGk1X3RleHRcIik7XG4gICAgICAgICAgICBjb25zdCBzaG9ydDQgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8ZGl2IDpodG1sPVwicmF3SHRtbFwiPjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0NC5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxlbT5Xb3JsZDwvZW0+JywgXCI6aHRtbCBzaG9ydGN1dCBmb3IgaTVfaHRtbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0NSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxpbnB1dCA6c3R5bGU9XCJibG9ja1wiIDp2YWx1ZT1cIm5hbWVcIiAvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0NS52YWx1ZSA9PT0gJ1dvcmxkJywgJzp2YWx1ZSBzaG9ydGN1dCBmb3IgaTVfdmFsdWUnKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3J0NiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxpbnB1dCA6c3R5bGU9XCJibG9ja1wiIDp2YWx1ZT1cIm5hbWVcIiA6YXR0cjpkaXNhYmxlZD1cInRydXRoaW5lc3NcIiAvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0Ni5jb250ZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSwgJzphdHRyIHNob3J0Y3V0IGZvciBpNV9hdHRyJyk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydDcgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8ZGl2IDppZj1cInRydXRoaW5lc3NcIj5TaG9ydGN1dCBzZWVuPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydDggPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8ZGl2IDppZj1cInRydW1waW5lc3NcIj5TaG9ydGN1dCBub3Qgc2VlbjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnQ5ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGRpdiA6aWYtPVwidHJ1dGhpbmVzc1wiPlNob3J0Y3V0IG5vdCBzZWVuPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoc2hvcnQ3LnN0eWxlLmRpc3BsYXkgPT09ICcnLCAnOmlmIHNob3J0Y3V0IGZvciBpNV9pZicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHNob3J0OC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScsICc6aWYgc2hvcnRjdXQgZm9yIGk1X2lmJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoc2hvcnQ5LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJywgJzppZi0gc2hvcnRjdXQgZm9yIGk1X2lmMCcpO1xuICAgICAgICAgICAgY29uc3Qgc2hvcnQxMCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxpbnB1dCA6c3R5bGU9XCJibG9ja1wiIDppbnB1dD1cIndyaXRhYmxlXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIHNob3J0MTAudmFsdWUgPSAnU2hvcnRjdXQgMTAnO1xuICAgICAgICAgICAgc2hvcnQxMC5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYmFzaWNWaWV3TW9kZWwud3JpdGFibGUgPT09ICdTaG9ydGN1dCAxMCcsICc6aW5wdXQgc2hvcnRjdXQgZm9yIGk1X2lucHV0Jyk7XG4gICAgICAgICAgICBjb25zdCBzaG9ydDExID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IDpzdHlsZT1cImJsb2NrXCIgOmlucHV0IDp0YXJnZXQxPVwid3JpdGFibGVcIiA6dGFyZ2V0Mj1cIndyaXRhYmxlMlwiIC8+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBzaG9ydDExLnZhbHVlID0gJ1Nob3J0Y3V0IDExJztcbiAgICAgICAgICAgIHNob3J0MTEuY29udGVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGJhc2ljVmlld01vZGVsLndyaXRhYmxlID09PSAnU2hvcnRjdXQgMTEnICYmIGJhc2ljVmlld01vZGVsLndyaXRhYmxlMiA9PT0gJ1Nob3J0Y3V0IDExJywgJzp0YXJnZXQgc2hvcnRjdXQgY2FuIGhhbmRsZSBtdWx0aXBsZSB0YXJnZXRzJyk7XG4gICAgICAgICAgICAvLyBUaGUgc2hvcnRjdXQgZm9yIGk1X2lucHV0X3ZhbHVlIGlzIDppbnB1dDogKDppbnB1dF92YWx1ZSB3aWxsIHN0aWxsIHdvcmsgYnV0IGl0J3Mgc3RpbGwgd29yZHkpXG4gICAgICAgICAgICBjb25zdCBzaG9ydDEyID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IHN0eWxlPVwiZGlzcGxheTogYmxvY2s7XCIgOmlucHV0Oj1cIndyaXRhYmxlXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChzaG9ydDEyLnZhbHVlID09PSAnU2hvcnRjdXQgMTEnLCAnOmlucHV0OiBiZWZvcmUnKTtcbiAgICAgICAgICAgIHNob3J0MTIudmFsdWUgPSAnU2hvcnRjdXQgMTInO1xuICAgICAgICAgICAgc2hvcnQxMi5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoc2hvcnQxMi52YWx1ZSA9PT0gJ1Nob3J0Y3V0IDEyJywgJzppbnB1dDogYWZ0ZXInKTtcbiAgICAgICAgICAgIC8vIFlvdSBjYW4gc2hvcnRjdXQgbG9vcHNcbiAgICAgICAgICAgIGNvbnN0IHNob3J0MTMgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoWydTaG9ydCcsICdTaG9ydGVyJywgJ1Nob3J0ZXN0J10sIGA8ZGl2IDpsb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12Pjwvc3Bhbj48L2Rpdj5gKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIC8vIFRoZSA6IHNob3J0Y3V0IGlzIG9ubHkgaW50ZW5kZWQgdG8gcmVwbGFjZSBjdXN0b20gY29tcG9uZW50IGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICBjb25zdCBzaG9ydDE0ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KFsnU2hvcnQnLCAnU2hvcnRlcicsICdTaG9ydGVzdCddLCBgPGRpdiA6bG9vcD1cIi5cIj48c3Bhbj48aS12Pi48L2ktdj48L3NwYW4+PC9kaXY+YCkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICAvLyBJY2hpZ28gbWFrZXMgaGVhdnkgdXNlIG9mIGN1c3RvbSBhdHRyaWJ1dGVzLCBhbmQgcHVyaXN0cyBtaWdodCByZWZ1c2UgdG8gdXNlIGl0IGJlY2F1c2UgYWxsIHRoZSBhdHRyaWJ1dGVzIGFyZVxuICAgICAgICAgICAgLy8gdGVjaG5pY2FsbHkgaW52YWxpZCwgbm90IGV2ZW4gY29uc2lkZXJpbmcgdGhlIHNob3J0Y3V0IGNoYXJhY3Rlci5cbiAgICAgICAgICAgIC8vIFRvIG1ha2UgdGhlbSBoYXBweSwgSWNoaWdvIGNhbiBhbHNvIGJlIGNvbmZpZ3VyZWQgdXNpbmcgZGF0YSBhdHRyaWJ1dGVzLCB3aGljaCBhcmUgdmFsaWQuIEl0IGRpZG4ndCB0YWtlIGEgbG90IG9mIGNvZGUuXG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0MSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgZGF0YS1pNV9jbGFzcz1cImNzc0NsYXNzXCI+U2hvcnRjdXQ8L2Rpdj4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkYXRhc2V0MS5jbGFzc0xpc3QudG9TdHJpbmcoKSA9PT0gJ2RvZXMtbm90aGluZycsICdpNV9jbGFzcyBpbiBkYXRhc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0MiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxzcGFuIGRhdGEtaTVfc3R5bGU9XCJibG9ja1wiPlNob3J0Y3V0PC9zcGFuPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRhdGFzZXQyLnN0eWxlLmRpc3BsYXkgPT09ICdibG9jaycsICdpNV9zdHlsZSBpbiBkYXRhc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0MyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgZGF0YS1pNV90ZXh0PVwicmF3SHRtbFwiPjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRhdGFzZXQzLmlubmVySFRNTCA9PT0gJzxpLXY+SGVsbG8gJmx0O2VtJmd0O1dvcmxkJmx0Oy9lbSZndDs8L2ktdj4nLCBcImk1X3RleHQgaW4gZGF0YXNldFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQ0ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGRpdiBkYXRhLWk1X2h0bWw9XCJyYXdIdG1sXCI+PC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZGF0YXNldDQuY29udGVudC5maXJzdEVsZW1lbnRDaGlsZC5pbm5lckhUTUwgPT09ICdIZWxsbyA8ZW0+V29ybGQ8L2VtPicsIFwiaTVfaHRtbCBpbiBkYXRhc2V0XCIpO1xuICAgICAgICAgICAgY29uc3QgZGF0YXNldDUgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiIGRhdGEtaTVfdmFsdWU9XCJuYW1lXCIgLz4nKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkYXRhc2V0NS52YWx1ZSA9PT0gJ1dvcmxkJywgJ2k1X3ZhbHVlIGluIGRhdGFzZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQ2ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIiBkYXRhLWk1X3ZhbHVlPVwibmFtZVwiIGRhdGEtaTVfYXR0cl9kaXNhYmxlZD1cInRydXRoaW5lc3NcIiAvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRhdGFzZXQ2LmNvbnRlbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpLCAnaTVfYXR0ciBpbiBkYXRhc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0NyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgZGF0YS1pNV9pZj1cInRydXRoaW5lc3NcIj5TaG9ydGN1dCBzZWVuPC9kaXY+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0OCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgJzxkaXYgZGF0YS1pNV9pZj1cInRydW1waW5lc3NcIj5TaG9ydGN1dCBub3Qgc2VlbjwvZGl2PicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRhdGFzZXQ3LnN0eWxlLmRpc3BsYXkgPT09ICcnLCAnaTVfaWYgaW4gZGF0YXNldCcpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRhdGFzZXQ4LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJywgJ2k1X2lmIGluIGRhdGFzZXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQ5ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCAnPGlucHV0IHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIiBkYXRhLWk1X2lucHV0PVwid3JpdGFibGVcIiAvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgZGF0YXNldDkudmFsdWUgPSAnRGF0YXNldCA5JztcbiAgICAgICAgICAgIGRhdGFzZXQ5LmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChiYXNpY1ZpZXdNb2RlbC53cml0YWJsZSA9PT0gJ0RhdGFzZXQgOScsICdpNV9pbnB1dCBpbiBkYXRhc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0MTAgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgc3R5bGU9XCJkaXNwbGF5OiBibG9ja1wiIGRhdGEtaTVfaW5wdXQgZGF0YS1pNV90YXJnZXQxPVwid3JpdGFibGVcIiBkYXRhLWk1X3RhcmdldDI9XCJ3cml0YWJsZTJcIiAvPicpLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgZGF0YXNldDEwLnZhbHVlID0gJ0RhdGFzZXQgMTAnO1xuICAgICAgICAgICAgZGF0YXNldDEwLmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChiYXNpY1ZpZXdNb2RlbC53cml0YWJsZSA9PT0gJ0RhdGFzZXQgMTAnICYmIGJhc2ljVmlld01vZGVsLndyaXRhYmxlMiA9PT0gJ0RhdGFzZXQgMTAnLCAnZGF0YS1pNV90YXJnZXQgc2hvcnRjdXQgY2FuIGhhbmRsZSBtdWx0aXBsZSB0YXJnZXRzJyk7XG4gICAgICAgICAgICBjb25zdCBkYXRhc2V0MTEgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoYmFzaWNWaWV3TW9kZWwsICc8aW5wdXQgc3R5bGU9XCJkaXNwbGF5OiBibG9jaztcIiBkYXRhLWk1X2lucHV0X3ZhbHVlPVwid3JpdGFibGVcIi8+JykuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZGF0YXNldDExLnZhbHVlID09PSAnRGF0YXNldCAxMCcsICdkYXRhLWk1X2lucHV0X3ZhbHVlIGJlZm9yZScpO1xuICAgICAgICAgICAgZGF0YXNldDExLnZhbHVlID0gJ0RhdGFzZXQgMTEnO1xuICAgICAgICAgICAgZGF0YXNldDExLmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkYXRhc2V0MTEudmFsdWUgPT09ICdEYXRhc2V0IDExJywgJ2RhdGEtaTVfaW5wdXRfdmFsdWUgYWZ0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQxMiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChbJ1Nob3J0JywgJ1Nob3J0ZXInLCAnU2hvcnRlc3QnXSwgYDxkaXYgZGF0YS1pNV9sb29wPVwiLlwiPjxzcGFuPjxpLXY+LjwvaS12Pjwvc3Bhbj48L2Rpdj5gKS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIC8vIEFnYWluLCBzb21lIGV4dHJhIGNvbXBsZXhpdHkgZm9yIHRoZSBzYWtlIG9mIGNvbnNpc3RlbmN5LlxuICAgICAgICAgICAgY29uc3QgZGF0YXNldDEzID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KFsnU2hvcnQnLCAnU2hvcnRlcicsICdTaG9ydGVzdCddLCBgPGRpdiBkYXRhLWk1X2xvb3A9XCIuXCI+PHNwYW4+PGktdj4uPC9pLXY+PC9zcGFuPjwvZGl2PmApLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgLy8gSWYgeW91IHN1YnNjcmliZSB0aGUgcmVuZGVyKCkgbWV0aG9kIG9mIHRoZSBjb21wb25lbnQgdG8gYW4gb2JzZXJ2YWJsZSdzIGNoYW5nZXMsXG4gICAgICAgICAgICAvLyB0aGVuIHdoZW4gdGhlIGRhdGEgaXMgbW9kaWZpZWQsIHRoZSByZW5kZXJpbmcgb2YgdGhhdCBkYXRhIHdpbGwgYmUgdXBkYXRlZC5cbiAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgYnkgZGVmYXVsdCwgb2JzZXJ2YWJsZXMgd29yayBhc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2aWV3IG1vZGVsIGlzIGFuIG9ic2VydmFibGUsIHlvdSBjYW4gb2JzZXJ2ZSBpdCBzaW1wbHkgYnlcbiAgICAgICAgICAgIC8vIHBhc3Npbmcgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZSBpbiB0aGUgY29tcG9uZW50IG9wdGlvbnMuXG4gICAgICAgICAgICBjbGFzcyBPYnNlcnZhYmxlVmlld01vZGVsIGV4dGVuZHMgQXBpXzEuT2JzZXJ2YWJsZUJhc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSBuZXcgQXBpXzEuT2JzZXJ2YWJsZVByb3BlcnR5KFwiV29ybGRcIiwgeyBuYW1lOiBcIm5hbWVcIiwgZm9yd2FyZFRvOiB0aGlzIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGVWaWV3TW9kZWwgPSBuZXcgT2JzZXJ2YWJsZVZpZXdNb2RlbCh7IG5hbWU6IFwiVk1cIiB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVDb21wMSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChvYnNlcnZhYmxlVmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sOiAnSGVsbG8gPGktdj5uYW1lPC9pLXY+JyxcbiAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDEuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5Xb3JsZDwvaS12PicsICdDb21wb25lbnQgc2hvd3MgaW5pdGlhbCB2YWx1ZSBiZWZvcmUgdXBkYXRlJyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlVmlld01vZGVsLm5hbWUudmFsdWUgPSBcIk5lcHR1bmVcIjtcbiAgICAgICAgICAgIH0sIDUwMCk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQob2JzZXJ2ZUNvbXAxLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+TmVwdHVuZTwvaS12PicsICdSZW5kZXIoKSBjYWxsZWQgd2hlbiBvYnNlcnZpbmcgdmlld01vZGVsLCBpZiBwcm9wZXJ0eSBpcyBmb3J3YXJkZWQuJykpO1xuICAgICAgICAgICAgLy8gWW91IGNhbiBhbHNvIG9ic2VydmUgZWFjaCBpbmRpdmlkdWFsIHByb3BlcnR5IG9mIGEgdmlldyBtb2RlbCwgd2hpY2ggaXMgdXNlZnVsIHdoZW4gdGhlIFZNIGl0c2VsZiBpcyBhIGR1bWIgb2JqZWN0LiBXaGljaFxuICAgICAgICAgICAgLy8gaXMgZ2VuZXJhbGx5IGJldHRlciwgaW4gbXkgb3Bpbmlvbi4gU2ltcGxlciBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgICAgICAgIGNsYXNzIE1vcmVUeXBpY2FsVmlld01vZGVsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmV3IEFwaV8xLk9ic2VydmFibGVQcm9wZXJ0eShcIldvcmxkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1bWJWaWV3TW9kZWwgPSBuZXcgTW9yZVR5cGljYWxWaWV3TW9kZWwoKTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVDb21wMiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChkdW1iVmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sOiAnSGVsbG8gPGktdj5uYW1lPC9pLXY+JyxcbiAgICAgICAgICAgICAgICBvYnNlcnZlQWxsVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDIuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5Xb3JsZDwvaS12PicsICdDb21wb25lbnQgc2hvd3MgaW5pdGlhbCB2YWx1ZSBiZWZvcmUgdXBkYXRlICMyJyk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBkdW1iVmlld01vZGVsLm5hbWUudmFsdWUgPSBcIk1hcnNcIjtcbiAgICAgICAgICAgIH0sIDYwMCk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBBcGlfMS5hc3NlcnQob2JzZXJ2ZUNvbXAyLmlubmVySFRNTCA9PT0gJ0hlbGxvIDxpLXY+TWFyczwvaS12PicsICdSZW5kZXIoKSBjYWxsZWQgd2hlbiBvYnNlcnZpbmcgYWxsIG9ic2VydmFibGUgcHJvcGVydGllcyBvZiBhIGR1bWIgdmlldyBtb2RlbCcpKTtcbiAgICAgICAgICAgIC8vIE9mIGNvdXJzZSwgeW91IGNhbiBtYW51YWxseSBzcGVjaWZ5IHRoZSBvYnNlcnZlcnMgKHNhbWUgYXMgb2JzZXJ2ZVZpZXdNb2RlbCkuXG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlQ29tcDMgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoZHVtYlZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgIGlubmVySHRtbDogJ0hlbGxvIDxpLXY+bmFtZTwvaS12PiAjMicsXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZVRhcmdldHM6IFtkdW1iVmlld01vZGVsLm5hbWVdXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDMuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5NYXJzPC9pLXY+ICMyJywgJ1JlbmRlcigpIGNhbGxlZCB3aGVuIG9ic2VydmluZyBvYnNlcnZhYmxlIHByb3BlcnRpZXMgb24gYSBkdW1iIHZpZXcgbW9kZWwgZXhwbGljaXRseScpKTtcbiAgICAgICAgICAgIC8vIE9yIG1hbnVhbGx5IHNwZWNpZnkgdGhlIHBhcmVudCBvZiBvYnNlcnZlcnMgKHNhbWUgYXMgb2JzZXJ2ZUFsbFZpZXdNb2RlbClcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVDb21wNCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChkdW1iVmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sOiAnSGVsbG8gPGktdj5uYW1lPC9pLXY+ICMzJyxcbiAgICAgICAgICAgICAgICBvYnNlcnZlQWxsVGFyZ2V0czogW2R1bWJWaWV3TW9kZWxdXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDQuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5NYXJzPC9pLXY+ICMzJywgJ1JlbmRlcigpIGNhbGxlZCB3aGVuIG9ic2VydmluZyBhbGwgb2JzZXJ2YWJsZSBwcm9wZXJ0aWVzIG9mIGEgbGlzdCBvZiBkdW1iIHZpZXcgbW9kZWxzJykpO1xuICAgICAgICAgICAgLy8gT3IgaWYgY29tcGxldGUgbWFudWFsIGFzc2lnbm1lbnQgaXMgeW91ciB0aGluZywgeW91IGRvbid0IG5lZWQgdG8gdXNlIHRoZSBoZWxwZXJzLlxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZUNvbXA1ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KG9ic2VydmFibGVWaWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICBpbm5lckh0bWw6ICdIZWxsbyA8aS12Pm5hbWU8L2ktdj4gIzInXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgYXMgY2FsbGluZ1xuICAgICAgICAgICAgLy8gb2JzZXJ2ZUNvbXA1LnZpZXdNb2RlbC5zdWJzY3JpYmUob2JzZXJ2ZUNvbXA1LnJlbmRlciwgb2JzZXJ2ZUNvbXA1KVxuICAgICAgICAgICAgb2JzZXJ2ZUNvbXA1Lm9ic2VydmUoKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDUuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5OZXB0dW5lPC9pLXY+ICMyJywgJ1JlbmRlcigpIGNhbGxlZCB3aGVuIHRoZSBvYnNlcnZlKCkgbWV0aG9kIGlzIGNhbGxlZCcpKTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVDb21wNiA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChkdW1iVmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sOiAnSGVsbG8gPGktdj5uYW1lPC9pLXY+ICM0J1xuICAgICAgICAgICAgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGFzIGNhbGxpbmdcbiAgICAgICAgICAgIC8vIG9ic2VydmVDb21wNi52aWV3TW9kZWwuc3Vic2NyaWJlKG9ic2VydmVDb21wNS5yZW5kZXIsIG9ic2VydmVDb21wNS5uYW1lKVxuICAgICAgICAgICAgb2JzZXJ2ZUNvbXA2Lm9ic2VydmVBbGwoKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IEFwaV8xLmFzc2VydChvYnNlcnZlQ29tcDYuaW5uZXJIVE1MID09PSAnSGVsbG8gPGktdj5NYXJzPC9pLXY+ICM0JywgJ1JlbmRlcigpIGNhbGxlZCB3aGVuIHRoZSBvYnNlcnZlQWxsKCkgbWV0aG9kIGlzIGNhbGxlZCcpKTtcbiAgICAgICAgICAgIC8vIFRoZSBWTSBkb2Vzbid0IG1hdHRlciBhcyBsb25nIGFzIGl0J3Mgb2JzZXJ2YWJsZS4gVGhlIHByb2Nlc3MgaXMgdGhlIHNhbWUgZm9yIGFuIGFycmF5LlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCB0aGUgYXJyYXkgaXMgdGhlIHZpZXcgbW9kZWwsIHNvIHBhc3Mgb2JzZXJ2ZVZpZXdNb2RlbCB0byB0cnVlLlxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZUFyciA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoWydPbmUnLCAnVHdvJ10pO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZUNvbXA3ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KG9ic2VydmFibGVBcnIsIHtcbiAgICAgICAgICAgICAgICBvdXRlckh0bWw6IGA8ZGl2IDpsb29wPVwiLlwiPjxzcGFuIGNsYXNzPVwib2JzZXJ2aW5nXCI+PGktdj4uPC9pLXY+IDwvc3Bhbj48L2Rpdj5gLFxuICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KEFycmF5LmZyb20ob2JzZXJ2ZUNvbXA3LmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnLm9ic2VydmluZycpKS5sZW5ndGggPT09IDIsICdBcnJheSBsZW5ndGggYmVmb3JlIHVwZGF0aW5nLicpO1xuICAgICAgICAgICAgb2JzZXJ2YWJsZUFyci5wdXNoKCdUaHJlZScpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KEFycmF5LmZyb20ob2JzZXJ2ZUNvbXA3LmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnLm9ic2VydmluZycpKS5sZW5ndGggPT09IDMsICdBcnJheSBsZW5ndGggYWZ0ZXIgdXBkYXRpbmcuJykpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KEFycmF5LmZyb20ob2JzZXJ2ZUNvbXA3LmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnLm9ic2VydmluZyBpLXYnKSkucG9wKCkuaW5uZXJIVE1MID09PSAnVGhyZWUnLCAnTGFzdCBpdGVtIGlzIHRoZSBtb3N0IHJlY2VudCBhcnJheSBhZGRpdGlvbicpKTtcbiAgICAgICAgICAgIC8vIEVhY2ggb2YgdGhlIGF0dHJpYnV0ZS1kZWZpbmVkIHByb3BlcnRpZXMgaW4gdGhlIGJvdW5kIGNvbXBvbmVudHMgY2FuIGJlIHNldCB0aHJvdWdoIGZsdWVudCBtZXRob2RzLiBZb3UgcHJvYmFibHkgd291bGRuJ3RcbiAgICAgICAgICAgIC8vIHVzZSB0aGlzIGZvciBldmVyeXRoaW5nICh3aHkgdXNlIGFuIGJvdW5kIGNvbXBvbmVudCB3aXRoIG5vIGF0dHJpYnV0ZXM/KSBidXQgZnJvbSB0aW1lIHRvIHRpbWUgaXQncyB1c2VmdWwuXG4gICAgICAgICAgICBjb25zdCBmbHVlbmN5ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KGJhc2ljVmlld01vZGVsLCB7IGlubmVySHRtbDogJ0hlbGxvb28sIDxpLXY+bmFtZTwvaS12PicgfSkuYXBwZW5kVG9QYXJlbnQodGhpcy50ZXN0QXJlYSk7XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHVwZGF0ZSBwYXJhbWV0ZXIgdG8gdHJ1ZSBvbiB0aGUgbGFzdCBjaGFuZ2UgdG8gcmUtcmVuZGVyIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSB3aGVuIHlvdSBjYWxsIGl0IHNvIHRoZSBudW1iZXIgb2YgcmVkcmF3cyBpcyBtaW5pbWl6ZWQuXG4gICAgICAgICAgICBmbHVlbmN5LnNldENzc0NsYXNzKCdjc3NDbGFzcycpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuY2xhc3NOYW1lID09PSAnJywgJ1NpbW9uIGRpZG50IHNheSAodXBkYXRlIG5vdCB0cnVlKScpO1xuICAgICAgICAgICAgZmx1ZW5jeS5hZGRBdHRyaWJ1dGVNYXBwaW5nKCdib2d1cycsICdjc3NDbGFzcycsIHRydWUpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuY2xhc3NOYW1lID09PSAnZG9lcy1ub3RoaW5nJywgJ1VwZGF0ZSBjYWxsZWQgZm9yY2VzIHJlLXJlbmRlcicpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuY29udGVudC5nZXRBdHRyaWJ1dGUoJ2JvZ3VzJykgPT09ICdkb2VzLW5vdGhpbmcnLCAnVXBkYXRlIGNhbGxlZCBmb3JjZXMgYSBjb21wbGV0ZSByZS1yZW5kZXInKTtcbiAgICAgICAgICAgIC8vIE9yIGNhbGwgLnJlbmRlcigpIGF0IHRoZSBlbmQuIEl0J3MgYSBmbHVlbnQgQVBJLlxuICAgICAgICAgICAgZmx1ZW5jeS5yZW1vdmVBdHRyaWJ1dGVNYXBwaW5nKCdib2d1cycpLnNldExvb3AoJ2xpc3QnLCAnPGRpdiA6dGV4dD1cIi5cIj48L2Rpdj4nKS5yZW5kZXIoKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LmlubmVySFRNTCA9PT0gJzxkaXYgOnRleHQ9XCIuXCIgaXZfYm91bmRfY29tcG9uZW50PVwiXCI+PGktdj5Xb3JsZDwvaS12PjwvZGl2PjxkaXYgOnRleHQ9XCIuXCIgaXZfYm91bmRfY29tcG9uZW50PVwiXCI+PGktdj5VbmRlcndvcmxkPC9pLXY+PC9kaXY+JywgJ3NldExvb3AoKSByZXBsYWNlcyBjb250ZW50IHdpdGggdGhlIHByb3ZpZGVkIGxvb3AnKTtcbiAgICAgICAgICAgIC8vIEFsbCB0aGVzZSBhcmUgc2V0dGluZyByZW5kZXIgdG8gdHJ1ZSBzbyB0aGUgb3V0cHV0IGlzIHZpc2libGUgaW4gdGhlIHRlc3QgYXJlYSwgYnV0IHRoZXkgZG9uJ3QgbmVlZCB0byBiZS5cbiAgICAgICAgICAgIGZsdWVuY3kuc2V0VmlzaWJpbGl0eSgndHJ1bXBpbmVzcycsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LmNvbnRlbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnLCAnc2V0VmlzaWJpbGl0eSgpIGhpZGVzJyk7XG4gICAgICAgICAgICBmbHVlbmN5LnNldFZpc2liaWxpdHkoJ3RydXRoaW5lc3MnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW5jeS5jb250ZW50LnN0eWxlLmRpc3BsYXkgPT09ICcnLCAnc2V0VmlzaWJpbGl0eSgpIHNob3dzJyk7XG4gICAgICAgICAgICBmbHVlbmN5LmFkZEF0dHJpYnV0ZU1hcHBpbmcoJ3N0eWxlJywgJ2JvbGQnLCB0cnVlKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LnN0eWxlLmNzc1RleHQgPT09ICdmb250LXdlaWdodDogYm9sZDsnLCAnYWRkQXR0cmlidXRlKCkgY2hhbmdlcyBhdHRyaWJ1dGUnKTtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3MgYSBkaWZmZXJlbmNlIGJldHdlZW4gcmVtb3ZlQXR0cmlidXRlIG9uIHRoZSBjb250ZW50IGFuZCByZW1vdmluZyB0aGUgZHluYW1pYyBpNV9hdHRyaWJ1dGUgbWFwcGluZ1xuICAgICAgICAgICAgZmx1ZW5jeS5jb250ZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIGZsdWVuY3kucmVuZGVyKCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW5jeS5zdHlsZS5jc3NUZXh0ID09PSAnZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2FkZEF0dHJpYnV0ZSgpIHJlZ2VuZXJhdGVkIGR1cmluZyBlYWNoIHJlbmRlcmluZycpO1xuICAgICAgICAgICAgZmx1ZW5jeS5jb250ZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgIGZsdWVuY3kucmVtb3ZlQXR0cmlidXRlTWFwcGluZygnc3R5bGUnLCB0cnVlKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LnN0eWxlLmNzc1RleHQgPT09ICcnLCAncmVtb3ZlQXR0cmlidXRlKCkgdGFrZXMgZHluYW1pYyBhdHRyaWJ1dGUgYXdheScpO1xuICAgICAgICAgICAgZmx1ZW5jeS5zZXRDc3NDbGFzcygnY3NzQ2xhc3NlcycsIHRydWUpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuY2xhc3NOYW1lID09PSAnY2xhc3MtMSBjbGFzcy0yJywgJ3NldENzc0NsYXNzKCkgc2V0cyBjbGFzc05hbWUnKTtcbiAgICAgICAgICAgIGZsdWVuY3kuc2V0Q3NzU3R5bGUoJ2JvbGQnLCB0cnVlKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LnN0eWxlLmNzc1RleHQgPT09ICdmb250LXdlaWdodDogYm9sZDsnLCAnc2V0Q3NzU3R5bGUoKSBjaGFuZ2VzIHN0eWxlJyk7XG4gICAgICAgICAgICBmbHVlbmN5LmFkZENzc0NsYXNzU3dpdGNoKCdzb21lLWNsYXNzJywgJ3RydXRoaW5lc3MnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW5jeS5jbGFzc05hbWUgPT09ICdjbGFzcy0xIGNsYXNzLTIgc29tZS1jbGFzcycsICdhZGRDc3NDbGFzc1N3aXRjaCgpIGFkZHMgY2xhc3MgaWYgcHJvcGVydHkgaXMgdHJ1ZScpO1xuICAgICAgICAgICAgLy8gVGhpcyBjYXNlIGlzIGEgcGFpbiB0byB0ZXN0IHdpdGhvdXQgYnJpbmdpbmcgb2JzZXJ2YWJsZXMgaW50byBpdFxuICAgICAgICAgICAgYmFzaWNWaWV3TW9kZWwudHJ1dGhpbmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgZmx1ZW5jeS5yZW5kZXIoKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChmbHVlbmN5LmNsYXNzTmFtZSA9PT0gJ2NsYXNzLTEgY2xhc3MtMicsICdjbGFzcyBzd2l0Y2ggc3RpbGwgYWN0aXZlJyk7XG4gICAgICAgICAgICBmbHVlbmN5LnJlbW92ZUNzc0NsYXNzU3dpdGNoKCdzb21lLWNsYXNzJyk7XG4gICAgICAgICAgICBiYXNpY1ZpZXdNb2RlbC50cnV0aGluZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGZsdWVuY3kucmVuZGVyKCk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW5jeS5jbGFzc05hbWUgPT09ICdjbGFzcy0xIGNsYXNzLTInLCAnY2xhc3Mgc3dpdGNoIG5vdCBhY3RpdmUnKTtcbiAgICAgICAgICAgIC8vIFRoZSBwYXJ0aWFsIGV4Y2VwdGlvbiAgdG8gdGhlIHJ1bGUgdGhhdCB1cGRhdGUgc2hvdWxkIGJlIHRydWUgaXMgc2V0VGVtcGxhdGUoKSwgYW5kIGl0cyBjaGlsZHJlbiBzZXRIdG1sVGVtcGxhdGUoKVxuICAgICAgICAgICAgLy8gYW5kIHNldFRleHRUZW1wbGF0ZSgpLiBGdWxsIHJlbmRlcmluZyBpcyBzdGlsbCBkZWxheWVkLCBidXQgaW5pdGlhbCByZXBsYWNlbWVudHMgYXJlIGRvbmUgYmVmb3JlIHdyaXRpbmcuXG4gICAgICAgICAgICAvLyBJIHNlZSBwcmUtcmVwbGFjZW1lbnQgdmFsdWVzIG9uIHBhZ2VzIGFsbCB0aGUgdGltZSBhbmQgaXQncyB0YWNreS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBieSBkZWZhdWx0IHRoaXMgb25seSByZXBsYWNlcyB0ZXh0LiBBbnkgcmVsYXRlZCBjbGFzc2VzLCBzdHlsZXMsIGV0YyxcbiAgICAgICAgICAgIC8vIGFyZSBub3Qgc2VlbiB1bnRpbCByZW5kZXIoKSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICBmbHVlbmN5LnNldEh0bWxUZW1wbGF0ZSgncmF3SHRtbCcpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuaW5uZXJIVE1MID09PSAnPGktdiBub2VzY2FwZT1cIlwiPkhlbGxvIDxlbT5Xb3JsZDwvZW0+PC9pLXY+JywgJ3NldEh0bWxUZW1wbGF0ZSgpIHNldHMgbm9lc2NhcGUnKTtcbiAgICAgICAgICAgIGZsdWVuY3kuc2V0VGV4dFRlbXBsYXRlKCdyYXdIdG1sJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW5jeS5pbm5lckhUTUwgPT09ICc8aS12PkhlbGxvICZsdDtlbSZndDtXb3JsZCZsdDsvZW0mZ3Q7PC9pLXY+JywgJ3NldFRleHRUZW1wbGF0ZSgpIGRvZXNudCBzZXQgbm9lc2NhcGUnKTtcbiAgICAgICAgICAgIGZsdWVuY3kuc2V0VGVtcGxhdGUoJ0hpeWEgPGktdj5uYW1lPC9pLXY+IScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGZsdWVuY3kuaW5uZXJIVE1MID09PSAnSGl5YSA8aS12PldvcmxkPC9pLXY+IScsICdzZXRUZW1wbGF0ZSgpIGFjdHMgdGhlIHNhbWUgYXMgaWYgb3JpZ2luYWwgaW5uZXJIVE1MIHdlcmUgc2V0Jyk7XG4gICAgICAgICAgICBjb25zdCBmbHVlbnRJbnB1dCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudChiYXNpY1ZpZXdNb2RlbCwgeyB0eXBlOiAnaW5wdXQnLCBhdHRyaWJ1dGVzOiB7IHN0eWxlOiAnZGlzcGxheTogYmxvY2s7JywgaTVfaW5wdXQ6ICd3cml0YWJsZScgfSB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGZsdWVudElucHV0LnNldFZhbHVlQXR0cmlidXRlKCduYW1lJywgdHJ1ZSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZmx1ZW50SW5wdXQudmFsdWUgPT09ICdXb3JsZCcsICdzZXRWYWx1ZUF0dHJpYnV0ZSgpIHNldHMgYSB2YWx1ZSBtYXBwaW5nJyk7XG4gICAgICAgICAgICAvLyBSZS1yZW5kZXJpbmcgYWZ0ZXIgdGhpcyBvbmUgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIsIHNpbmNlIHRoaXMgaXNuJ3QgcmVuZGVyZWRcbiAgICAgICAgICAgIGZsdWVudElucHV0LmFkZFdyaXRlVGFyZ2V0KCd3cml0YWJsZTInKTtcbiAgICAgICAgICAgIGZsdWVudElucHV0LnZhbHVlID0gJ0lucHV0IFRlc3QgMSc7XG4gICAgICAgICAgICBmbHVlbnRJbnB1dC5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoYmFzaWNWaWV3TW9kZWwud3JpdGFibGUyID09PSAnSW5wdXQgVGVzdCAxJywgJ2FkZFdyaXRlVGFyZ2V0KCkgYWRkcyBhIGZvcm0gaW5wdXQgYmluZGluZycpO1xuICAgICAgICAgICAgZmx1ZW50SW5wdXQucmVtb3ZlV3JpdGVUYXJnZXQoJ3dyaXRhYmxlMicpO1xuICAgICAgICAgICAgZmx1ZW50SW5wdXQudmFsdWUgPSAnSW5wdXQgVGVzdCAyJztcbiAgICAgICAgICAgIGZsdWVudElucHV0LmNvbnRlbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChiYXNpY1ZpZXdNb2RlbC53cml0YWJsZTIgPT09ICdJbnB1dCBUZXN0IDEnLCAncmVtb3ZlV3JpdGVUYXJnZXQoKSByZW1vdmVzIHRoZSBpbnB1dCBiaW5kaW5nJyk7XG4gICAgICAgICAgICAvLyBTdGF0ZSBvYnNlcnZhYmxlcyBhcmUgc2ltaWxhciwgYnV0IGtlZXAgaW4gbWluZCBhIGZldyB0aGluZ3MuXG4gICAgICAgICAgICAvLyBNb3N0IGltcG9ydGFudGx5LCB5b3Ugc2hvdWxkIG9ic2VydmUgdGhlIHZpZXcgbW9kZWwgaXRzZWxmLCBuZXZlciB0aGUgc3ViLW9iamVjdHMsIHdoaWNoIGFyZSBqdXN0IHBhcnRzIG9mIHRoZSBvdmVyYWxsIHN0YXRlLlxuICAgICAgICAgICAgLy8gQWxzbywgeW91IGFyZSBhIGJpdCBsaW1pdGVkIGluIHRoZSBjb21wbGV4aXR5IG9mIHlvdXIgb2JqZWN0LlxuICAgICAgICAgICAgY29uc3Qgc3RhdGVPYnNlcnZhYmxlID0gbmV3IEFwaV8xLk9ic2VydmFibGVTdGF0ZShiYXNpY1ZpZXdNb2RlbCk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlQ29tcDggPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQoc3RhdGVPYnNlcnZhYmxlLCB7XG4gICAgICAgICAgICAgICAgaW5uZXJIdG1sOiAnSGVsbG8gPGktdj5sYXN0TGlzdEl0ZW08L2ktdj4nLFxuICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgIH0pLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gQXBpXzEuYXNzZXJ0KG9ic2VydmVDb21wOC5pbm5lckhUTUwgPT09ICdIZWxsbyA8aS12Pk1pZGRsZSBFYXJ0aDwvaS12PicsICdSZW5kZXIoKSBjYWxsZWQgd2l0aCBzZXRTdGF0ZSgpJykpO1xuICAgICAgICAgICAgc3RhdGVPYnNlcnZhYmxlLnNldFN0YXRlKHsgbGlzdDogWydXb3JsZCcsICdVbmRlcndvcmxkJywgJ01pZGRsZSBFYXJ0aCddIH0pO1xuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBzaG91bGRuJ3QgdGhyb3cuIFRoZXkgd29uJ3QgZG8gYW55dGhpbmcsIGJ1dCB0aGV5IHNob3VsZG4ndCB0aHJvdy5cbiAgICAgICAgICAgIGNvbnN0IG51bGwxID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHVuZGVmaW5lZCwgeyBlbGVtZW50OiBBcGlfMS5jcmVhdGVFbGVtZW50KEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCB7IGlubmVySFRNTDogJ051bGwtaGVsbG8gPGktdj5uYW1lPC9pLXY+JyB9KSB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbnN0IG51bGwyID0gbmV3IExvb3BDb21wb25lbnQyKHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIG91dGVySHRtbDogYDxkaXYgaWQ9XCJudWxsMlwiIGk1X2xvb3A9XCIuXCI+PHNwYW4+PGktdj4uPC9pLXY+IDwvc3Bhbj48L2Rpdj5gLFxuICAgICAgICAgICAgICAgIGxvb3BJdGVtQ2xhc3M6IExvb3BDb21wb25lbnQzLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBmYWxzZSAvLyBOb3QgdXNpbmcgYXN5bmMgcmVuZGVyIGJlY2F1c2UgaXQgbWFrZXMgdGVzdGluZyBzdWNrICh0aGlzIGlzIGRlZmF1bHQpXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIGNvbnN0IG51bGwzID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIGlubmVySHRtbDogJ051bGwtaGVsbG8gPGktdj5uYW1lPC9pLXY+JyxcbiAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICB9KS5hcHBlbmRUb1BhcmVudCh0aGlzLnRlc3RBcmVhKTtcbiAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFN5bmMgdGVzdCBzdWNjZXNzZnVsYCk7XG4gICAgICAgICAgICB0aGlzLmxvZygnU3RhcnRpbmcgYXN5bmMgdGVzdHMnKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IEFzeW5jIHRlc3RzIHN1Y2NlZWRlZGApKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdBU1lOQyBURVNUUyBGQUlMRUQ6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDEwID0gVGVzdDAxMDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNvbnN0IFRlc3RDYXNlVmlld18xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3XCIpO1xuY29uc3QgVGVzdENhc2VWaWV3TW9kZWxfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld01vZGVsXCIpO1xuLy8gdHNsaW50OmRpc2FibGU6bWF4LWNsYXNzZXMtcGVyLWZpbGVcbmNsYXNzIFRlc3RWaWV3TW9kZWwgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdNb2RlbF8xLlRlc3RDYXNlVmlld01vZGVsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogJ0NvbXBsZXRlIEJvdW5kIENvbXBvbmVudCBFeGFtcGxlcycsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGA8cD5QYXJ0IHR3bzogbW9yZSBvZiB0aGUgc2FtZS48L3A+XG4gICAgICAgICAgICA8cD5Cb3VuZENvbXBvbmVudHMgYXJlIHByZXR0eSBjb21wbGV4IGFuZCBoYXZlIGxvdHMgb2Ygb3B0aW9ucy4gU28gbXVjaCB0aGF0IEknbSBzcGxpdHRpbmcgaXQgdXAgaW50byAyIHRlc3QgY2FzZXMuIEFuZFxuICAgICAgICAgICAgdG8gYmUgaG9uZXN0LCB0aGUgZmlyc3QgdGVzdCBjYXNlIGlzIHJlYWxseSByZWFsbHkgbG9uZy48L3A+XG5cbiAgICAgICAgICAgIDxwPldoeSBhcmUgYm91bmQgY29tcG9uZW50cyBzbyBsYXJnZSAoaW4gdGVybXMgb2YgZnVuY3Rpb25hbGl0eSAuLi4gdGhlIGNsYXNzIGlzIG9ubHkgODAwIGxpbmVzKT8gV2h5IGRvIHRoZXkgaGF2ZSBzbyBtYW55XG4gICAgICAgICAgICBvcHRpb25zPyBXZWxsLCBldmVyeW9uZSBoYXMgYSBkaWZmZXJlbnQgd2F5IG9mIGRldmVsb3BpbmcsIGFuZCBJIGRvbid0IHdhbnQgdG8gcHVzaCBhbnlvbmUgaW50byAnTXkgV2F5JyAuLi4gdGhpcyBpc24ndCBBbmd1bGFyXG4gICAgICAgICAgICBvciBzb21ldGhpbmcuIEVzcGVjaWFsbHkgc2luY2UgTXkgV2F5IGNoYW5nZXMgZGVwZW5kaW5nIG9uIHRoZSBwcm9qZWN0IGFuZCBzb21ldGltZXMgdGhlIHNwZWNpZmljIGZ1bmN0aW9uYWxpdHkuIFNvbWV0aW1lc1xuICAgICAgICAgICAgKHVzdWFsbHkpIGEgd2ViIHNlcnZlciBwdXNoZXMgdGhlIEhUTUwgYW5kIENTUyBhbmQgdGhlIEpTIGp1c3QgYWRkcyBvbiB0byB0aGF0LiBTb21ldGltZXMsIGl0J3MgYW4gU1BBIGFuZCBldmVyeXRoaW5nIGlzXG4gICAgICAgICAgICBwcm9kdWNlZCBpbiBKUy4gU29tZXRpbWVzIEknbSBidWlsZGluZyBhIGNvbXBvbmVudCB0aGF0J3MgZ2V0dGluZyBpbmplY3RlZCBpbnRvIGEgY29tcGxldGVseSBkaWZmZXJlbnQgcGFnZS48L3A+XG5cbiAgICAgICAgICAgIDxwPlRoZXJlIGFyZSBkaWZmZXJlbnQgd2F5cyB0byBkbyBlYWNoIG9mIHRoZXNlLiBJbnRlcmFjdGlvbiB3aXRoIHRoZSBET00gbWF5IGJlIGJhc2VkIG9uIGEgbG90IG9mIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKClcbiAgICAgICAgICAgIGNhbGxzLiBPciBpdCBtYXkgaW52b2x2ZSBhIGxvdCBvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50LiBBbmQgZXZlbiBpbiB0aGUgbGF0dGVyIGNhc2UsIHRoYXQgY291bGQgaW52b2x2ZSBjcmVhdGluZyBlYWNoXG4gICAgICAgICAgICBpbmRpdmlkdWFsIGVsZW1lbnRzIG9yIHB1c2hpbmcgYSBibG9iIG9mIEhUTUwgaW50byBpbm5lckhUTUwuIEl0IGFsbCBkZXBlbmRzLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhpcyB0ZXN0IGNhc2UgaW1wbGVtZW50cyBhIFZFUlkgc2ltcGxpc3RpYyBjaGF0IGNvbXBvbmVudCBpbiBhIHZhcmlldHkgb2YgZGlmZmVyZW50IHdheXMsIHVzaW5nIGRpZmZlcmVudCBmZWF0dXJlcyBvZlxuICAgICAgICAgICAgdGhlIGNsYXNzIGluIGVhY2ggY2FzZS48L3A+XG5cbiAgICAgICAgICAgIDxwPkkgdG90YWxseSBkbyBub3Qgd2FudCB0byBzcGVuZCB0aGUgdGltZSB3cml0aW5nIHVwIGEgc2VyaW91cyBzdHlsZXNoZWV0IGZvciB0aGlzLCBtdWNoIGxlc3MgcHVsbGluZyBpbiBib290c3RyYXAsIHNvIHRoaXNcbiAgICAgICAgICAgIHdpbGwgbG9vayBhcyBwcmltaXRpdmUgYXMgaGVjay48L3A+XG5cbiAgICAgICAgICAgIDxoMj5XYXJuaW5nPC9oMj5cbiAgICAgICAgICAgIDxwPlRlc3RzIGFyZSBhc3luYyBhbmQgd2lsbCBrZWVwIHJ1bm5pbmcuIFdhaXQgZm9yIHRlc3RzIHRvIGNvbXBsZXRlIGJlZm9yZSBsZWF2aW5nIHBhZ2UuPC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDExIGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gU2V0IHVwIGNvbW1vbiB0ZXN0cyBmb3IgYWxsIHRoZXNlIGlkZW50aWNhbCBjb21wb25lbnRzLCB3aGljaCBhcmUgYWxsIHRoZSBzYW1lIHRoaW5nLCBqdXN0IGNvbnN0cnVjdGVkIGluIGRpZmZlcmVudCB3YXlzLlxuICAgICAgICAgICAgLy8gVGVzdGluZyB0aGlzIHN0dWZmIGFzeW5jaHJvbm91c2x5IGlzIHN1cGVyIGRpZmZpY3VsdCwgdGhvdWdoLiBOb3JtYWxseSB3aXRoIGEgdXNlciwgeW91J2QgbWFrZSBhIGNoYW5nZSwgdGVzdCBpdCwgdGhlbiBjb250aW51ZS5cbiAgICAgICAgICAgIGNvbnN0IGFzeW5jQXNzZXJ0cyA9IG5ldyBBcGlfMS5EZWZlcnJlZFByb21pc2UoQXBpXzEuZGVsYXkoMTAwMCksIHRydWUpO1xuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdE1lc3NhZ2UxKHZpZXcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tZWxlbWVudCA9IHZpZXcuY29udGVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dC5jaGF0LWZyb20nKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJlbGVtZW50ID0gdmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LmNoYXQtc3ViamVjdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZ2VsZW1lbnQgPSB2aWV3LmNvbnRlbnQucXVlcnlTZWxlY3RvcigndGV4dGFyZWEuY2hhdC1tZXNzYWdlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnRuID0gdmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jaGF0LXN1Ym1pdCcpO1xuICAgICAgICAgICAgICAgIGZyb21lbGVtZW50LnZhbHVlID0gdmlldy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgICAgIGZyb21lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgc3ViZWxlbWVudC52YWx1ZSA9IFwiSGVsbG9cIjtcbiAgICAgICAgICAgICAgICBzdWJlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgbXNnZWxlbWVudC52YWx1ZSA9IFwiRXZlcnkgY2xpZW50IGlzIGFkZGluZyB0aGUgc2FtZSBtZXNzYWdlLlwiO1xuICAgICAgICAgICAgICAgIG1zZ2VsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2lucHV0JywgeyBidWJibGVzOiB0cnVlIH0pKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGJ0bi5jbGljaygpLCA1MCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiB0ZXN0TWVzc2FnZTIodmlldykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb21lbGVtZW50ID0gdmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LmNoYXQtZnJvbScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmVsZW1lbnQgPSB2aWV3LmNvbnRlbnQucXVlcnlTZWxlY3RvcignaW5wdXQuY2hhdC1zdWJqZWN0Jyk7XG4gICAgICAgICAgICAgICAgZnJvbWVsZW1lbnQudmFsdWUgPSAnSm9obiBTbWl0aCBvbiBiZWhhbGYgb2YgJyArIHZpZXcuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICBmcm9tZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIHN1YmVsZW1lbnQudmFsdWUgPSAnWW91ciBhc3Npc3RhbmNlIGlzIG5lZWRlZCc7XG4gICAgICAgICAgICAgICAgc3ViZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gdGVzdENvbXBvbmVudCh2aWV3KSB7XG4gICAgICAgICAgICAgICAgdGVzdE1lc3NhZ2UxKHZpZXcpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGVzdE1lc3NhZ2UyKHZpZXcpLCA1MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gYXNzZXJ0Q29tcG9uZW50KHZpZXcsIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQodmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5jaGF0LWNsb3NpbmcnKS5pbm5lckhUTUwuaW5jbHVkZXMoJ0pvaG4gU21pdGgnKSwgJ0Zyb20gZmllbGQgdXBkYXRlcyBjbG9zaW5nOiAnICsgdmlldy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQoIXZpZXcuY29udGVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dC5jaGF0LWZyb20nKS5jbGFzc0xpc3QudG9TdHJpbmcoKS5pbmNsdWRlcygncmVkJyksICdDbGFzcyBzd2l0Y2ggcmVtb3ZlZCB3aGVuIGZyb20gZmlsbGVkOiAnICsgdmlldy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJlbGVtZW50ID0gdmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2Rpdi5jaGF0LXN1YmplY3QtZGlzcGxheScpO1xuICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChzdWJlbGVtZW50LmlubmVySFRNTC5pbmNsdWRlcygnWW91ciBhc3Npc3RhbmNlIGlzIG5lZWRlZCcpLCAnU3ViamVjdCBkaXNwbGF5IHVwZGF0ZWQgYnkgc3ViamVjdCBmaWVsZDogJyArIHZpZXcuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHN1YmVsZW1lbnQuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnLCAnaTVfaWYgYWxsb3dzIGhpZGRlbiBmaWVsZCB0byBiZWNvbWUgdmlzaWJsZTogJyArIHZpZXcuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHZpZXcuY29udGVudC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYS5jaGF0LW1lc3NhZ2UnKS5jbGFzc0xpc3QudG9TdHJpbmcoKS5pbmNsdWRlcygncmVkJyksICdDbGFzcyBzd2l0Y2ggYWRkZWQgd2hlbiBubyBtZXNzYWdlOiAnICsgdmlldy5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgICAgICBBcGlfMS5hc3NlcnQodmlldy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ2J1dHRvbi5jaGF0LXN1Ym1pdCcpLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSwgJ0Rpc2FibGVkIGJvb2xlYW4gYXR0cmlidXRlIGFkZGVkIHdoZW4gbm8gbWVzc2FnZTogJyArIHZpZXcuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGxpc3QuY2hhdHMubGVuZ3RoID09PSA2LCAnQ2hhdHMgd2VyZSBhZGRlZCB0byB0aGUgdmlld21vZGVsIGR1cmluZyBlYWNoIGNoYXQgc3VibWl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0Vmlld01vZGVsIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcihjaGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWQgPSAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZWQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyb21OYW1lID0gJ0Fub255bW91cyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViamVjdCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zaW5nID0gJ0kgbG9vayBmb3J3YXJkIHRvIGhlYXJpbmcgZnJvbSB5b3UgYW5kIEkgcmVtYWluIG1lYW53aGlsZSwnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjaGF0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpcHBlZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGAke3RoaXMubWVzc2FnZX0gJHt0aGlzLmNsb3Npbmd9ICR7dGhpcy5mcm9tTmFtZX1gLnJlcGxhY2UoL1tcXHJcXG5dL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW52YWxpZCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLnN1YmplY3QgfHwgIXRoaXMubWVzc2FnZSB8fCAhdGhpcy5mcm9tTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0TGlzdFZpZXdNb2RlbCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhdHMgPSBBcGlfMS5PYnNlcnZhYmxlUHJveHkucHJveGltYXRlKFtdKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXROZXdDaGF0cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihuZXdDaGF0cyA9PiB0aGlzLmNoYXRzLnB1c2goLi4ubmV3Q2hhdHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVnaW5DaGF0KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQXBpXzEuT2JzZXJ2YWJsZVByb3h5LnByb3hpbWF0ZSh0aGlzLl9uZXdDaGF0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRDaGF0KGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkKGNoYXQpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyZXNwID0+IHRoaXMuZ2V0TmV3Q2hhdHMoY2hhdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihuZXdDaGF0cyA9PiB0aGlzLmNoYXRzLnB1c2goLi4ubmV3Q2hhdHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5fbmV3Q2hhdCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2V0TmV3Q2hhdHMoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBub3QgYWRkIGEgcmVmZXJlbmNlIHRvIHRoZSB3b3JraW5nIGNvcHkuIElmIHRoaXMgd2VyZSB0byBiZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHVsbGVkIGRvd24gZnJvbSBhIHNlcnZpY2UsIGl0IHdvdWxkIGJlIGEgbmV3IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoJ0ltYWdpbmUgYSBmZXRjaCByZXF1ZXN0IGhlcmUnKS50aGVuKCgpID0+IFtuZXcgQ2hhdFZpZXdNb2RlbChjaGF0KV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbmV3Q2hhdCgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4SWQgPSAodGhpcy5jaGF0c1t0aGlzLmNoYXRzLmxlbmd0aCAtIDFdIHx8IHsgaWQ6IDAgfSkuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdFZpZXdNb2RlbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogbWF4SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVkOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbU5hbWU6ICdBbm9ueW1vdXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBsb2FkKGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnSW1hZ2luZSBhIGZldGNoIHJlcXVlc3QgaGVyZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBmdW4sIHdlJ2xsIGxldCBhbGwgb3VyIGRpZmZlcmVudCB0ZXN0cyBpbnRlcmFjdCB3aXRoIHRoZSBzYW1lIHZpZXcgbW9kZWwuXG4gICAgICAgICAgICAvLyBCdXQgd2UnbGwgYXJyYW5nZSBzbyB0aGF0IHRoZXkgZ2l2ZSBlYWNoIGNvbXBvbmVudCBpdHMgb3duIGN1cnJlbnQgd29ya2luZyBvYmplY3QuXG4gICAgICAgICAgICBjb25zdCBjaGF0bGlzdCA9IG5ldyBDaGF0TGlzdFZpZXdNb2RlbCgpO1xuICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHByZXR0eSBjaGVhcCB3YXkgdG8gcHJvZHVjZSBhbiBpbmxpbmUgc3R5bGVzaGVldCBidXQgaXQgd29ya3MgYW5kIGl0IGRvZXNuJ3QgZXZlbiBtYWtlIGR1cGVzLlxuICAgICAgICAgICAgLy8gSSBkb24ndCBsaWtlIGhvdyBzY29wZWQgc3R5bGVzaGVldHMgZ290IHJlbW92ZWQgZnJvbSB0aGUgc3RhbmRhcmQsIHRob3VnaCwgZm9yY2luZyB3ZWlyZCBzZWxlY3RvcnMuXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTFN0eWxlRWxlbWVudCwge1xuICAgICAgICAgICAgICAgIGlkOiAnY2hhdC1zdHlsZXNoZWV0JyxcbiAgICAgICAgICAgICAgICBpbm5lckhUTUw6IGBcbiAgICAgICAgICAgICAgICAgICAgLmNoYXQtZXhhbXBsZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDNweCBzb2xpZCBibGFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiA3NXZ3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIFByb2JhYmx5IHdvdWxkbid0IGJlIHVzZWQgaW4gYSByZWFsIHRlc3QsIGJ1dCBmb3IgdGhpcyB0ZXN0LCB3b3JrcyBhcyBlbXBoYXNpcy4gKi9cbiAgICAgICAgICAgICAgICAgICAgLmNoYXQtZXhhbXBsZSAuY29tcG9uZW50OmhvdmVyIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IGdvbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBlYXNlLWluLW91dCBiYWNrZ3JvdW5kLWNvbG9yIDFzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC5jaGF0LWV4YW1wbGUgLmNoYXQtc3ViamVjdC1kaXNwbGF5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHBvd2RlcmJsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDJweCBzb2xpZCBibHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLmNoYXQtZXhhbXBsZSAuY2hhdC1zdWJtaXQge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLXJpZ2h0OiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luLWxlZnQ6IGF1dG87XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAuY2hhdC1leGFtcGxlIGlucHV0LHRleHRhcmVhIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiA1MHZ3O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC5jaGF0LWV4YW1wbGUgLnJlZCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiBzYWxtb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGBcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBleGFtcGxlIGlzIHlvdXIgdHJhZGl0aW9uYWwgRVM2IGFwcHJvYWNoLCB3aXRoIGZ1bGwgSFRNTCBiZWluZyBwcm92aWRlZCBieSBhIHdlYiBzZXJ2ZXIgc29tZXdoZXJlLFxuICAgICAgICAgICAgLy8gdGhlbiB3aXRoIGxvZ2ljIGxheWVyZWQgb24gdG9wIGluIEpTLiBUaGUgZGVmYXVsdCBCb3VuZENvbXBvbmVudCB3aWxsIGJlIHVzZWQsIGFzIHRoZXJlJ3Mgbm8gZnVuY3Rpb25hbGl0eVxuICAgICAgICAgICAgLy8gdG8gYmUgb3ZlcnJpZGRlbiB3aXRoIGN1c3RvbSBsb2dpYy5cbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUxaHRtbCA9IGBcbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiY2hhdC1leGFtcGxlMVwiIGNsYXNzPVwiY2hhdC1leGFtcGxlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxoND5FeGFtcGxlIDE8L2g0PiA8IS0tIE1pc3VzaW5nIGhlYWRpbmcgdGFncyBieSBqdW1waW5nIHRvIEg0LS0+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgOmxvb3A9XCJjaGF0c1wiIGNsYXNzPVwiY29tcG9uZW50IGNoYXQtbGlzdFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiM8aS12PmlkPC9pLXY+IEZyb206PGktdj5mcm9tTmFtZTwvaS12PiBhdCA8aS12PmNyZWF0ZWQ8L2ktdj4uIDxpLXY+c3ViamVjdDwvaS12PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGktdj5zdHJpcHBlZDwvaS12PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoYXQtZWRpdG9yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSA6ZXZlbnQgKHN1Ym1pdCk9XCJzdWJtaXRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcG9uZW50IGNoYXQtc3ViamVjdC1kaXNwbGF5XCIgOnRleHQ9XCJzdWJqZWN0XCIgOmlmPVwic3ViamVjdFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPkZyb206PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1mcm9tXCIgOmlucHV0Oj1cImZyb21OYW1lXCIgOnN3aXRjaC06cmVkPVwiZnJvbU5hbWVcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlN1YmplY3Q6PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1zdWJqZWN0XCIgOmlucHV0Oj1cInN1YmplY3RcIiA6c3dpdGNoLTpyZWQ9XCJzdWJqZWN0XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dGV4dGFyZWEgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1tZXNzYWdlXCIgOmlucHV0Oj1cIm1lc3NhZ2VcIiA6c3dpdGNoLTpyZWQ9XCJtZXNzYWdlXCI+PC90ZXh0YXJlYT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcG9uZW50IGNoYXQtY2xvc2luZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aS12PmNsb3Npbmc8L2ktdj4gPGJyIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpLXY+ZnJvbU5hbWU8L2ktdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29tcG9uZW50IGNoYXQtc3VibWl0XCIgdHlwZT1cInN1Ym1pdFwiIDpib29sOmRpc2FibGVkPVwiaW52YWxpZFwiPlN1Ym1pdDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHdoZXJlIHRoZSBcIndlYiBzZXJ2ZXJcIiByZXR1cm5zIGEgc3RhdGljIHBhZ2VcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlSHRtbChleGFtcGxlMWh0bWwpKTtcbiAgICAgICAgICAgIGNsYXNzIENoYXRWaWV3MSBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHsgc2VsZWN0b3I6ICcjY2hhdC1leGFtcGxlMScgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsID0gdmlld01vZGVsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnZpZXdNb2RlbC5iZWdpbkNoYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHRoaXMudmlld01vZGVsLCBuZXcgQXBpXzEuRXhpc3RpbmdMb29rdXBCaW5kaW5nT3B0aW9ucyh7IHBhcmVudDogdGhpcy5jb250ZW50LCBzZWxlY3RvcjogJy5jaGF0LWxpc3QnIH0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9ic2VydmUodGhpcy52aWV3TW9kZWwuY2hhdHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3REaXNwbGF5OiBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy5jdXJyZW50LCBuZXcgQXBpXzEuRXhpc3RpbmdMb29rdXBCaW5kaW5nT3B0aW9ucyh7IHBhcmVudDogdGhpcy5jb250ZW50LCBzZWxlY3RvcjogJy5jaGF0LXN1YmplY3QtZGlzcGxheScsIG9ic2VydmVWaWV3TW9kZWw6IHRydWUgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHRoaXMuY3VycmVudCwgbmV3IEFwaV8xLkV4aXN0aW5nTG9va3VwQmluZGluZ09wdGlvbnMoeyBwYXJlbnQ6IHRoaXMuY29udGVudCwgc2VsZWN0b3I6ICcuY2hhdC1zdWJqZWN0Jywgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy5jdXJyZW50LCBuZXcgQXBpXzEuRXhpc3RpbmdMb29rdXBCaW5kaW5nT3B0aW9ucyh7IHBhcmVudDogdGhpcy5jb250ZW50LCBzZWxlY3RvcjogJy5jaGF0LWZyb20nLCBvYnNlcnZlVmlld01vZGVsOiB0cnVlIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh0aGlzLmN1cnJlbnQsIG5ldyBBcGlfMS5FeGlzdGluZ0xvb2t1cEJpbmRpbmdPcHRpb25zKHsgcGFyZW50OiB0aGlzLmNvbnRlbnQsIHNlbGVjdG9yOiAnLmNoYXQtbWVzc2FnZScsIG9ic2VydmVWaWV3TW9kZWw6IHRydWUgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2luZzogbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHRoaXMuY3VycmVudCwgbmV3IEFwaV8xLkV4aXN0aW5nTG9va3VwQmluZGluZ09wdGlvbnMoeyBwYXJlbnQ6IHRoaXMuY29udGVudCwgc2VsZWN0b3I6ICcuY2hhdC1jbG9zaW5nJywgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZSB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b246IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh0aGlzLmN1cnJlbnQsIG5ldyBBcGlfMS5FeGlzdGluZ0xvb2t1cEJpbmRpbmdPcHRpb25zKHsgcGFyZW50OiB0aGlzLmNvbnRlbnQsIHNlbGVjdG9yOiAnLmNoYXQtc3VibWl0Jywgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZSB9KSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbmxpbmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJtaXQoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRDaGF0KHRoaXMuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG5ld2NoYXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmN1cnJlbnQsIG5ld2NoYXQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUxVmlldyA9IG5ldyBDaGF0VmlldzEoY2hhdGxpc3QpO1xuICAgICAgICAgICAgdGVzdENvbXBvbmVudChleGFtcGxlMVZpZXcpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXNzZXJ0Q29tcG9uZW50KGV4YW1wbGUxVmlldywgY2hhdGxpc3QpKTtcbiAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdhcyBhIGJpdCB2ZXJib3NlLCBidXQgaXQncyBhIGdvb2QgbWF0Y2ggZm9yIHRoZSBkZXZlbG9wZXIgd2hvIHdhbnRzIHRvIGNvbnRyb2wgZXZlcnl0aGluZyBhbmQgdHJhY2tcbiAgICAgICAgICAgIC8vIGV2ZXJ5IGNvbXBvbmVudCBpbiB0aGUgdmlldywgb3IgZG9lc24ndCBoYXZlIGEgbG90IG9mIGlkZW50aWNhbCBjb21wb25lbnRzLiBJdCBkb2VzIGludm9sdmUgYSB3b3Jrb3V0IGZvciB0aGUgY29udHJvbC1WIGtleS5cbiAgICAgICAgICAgIC8vIEJ1dCBtb3N0LCB3aGVuIGZhY2VkIGJ5IHNvIG11Y2ggY29kZSBkdXBsaWNhdGlvbiwgd291bGQgZ28gd2l0aCBzb21ldGhpbmcgbGlrZSBleGFtcGxlIDIsIHdoaWNoIHVzZXMgdGhlIGluamVjdCBtZXRob2QuXG4gICAgICAgICAgICAvLyBUaGlzIG9uZSBjYW4gd29yayB3aXRoIHRoZSBzYW1lIEhUTUwgcHJvdmlkZWQgYnkgdGhlIHdlYiBzZXJ2ZXIuXG4gICAgICAgICAgICBjbGFzcyBDaGF0VmlldzIgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih7IHNlbGVjdG9yOiAnI2NoYXQtZXhhbXBsZTInIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52aWV3TW9kZWwuYmVnaW5DaGF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdCA9IEFwaV8xLkJvdW5kQ29tcG9uZW50LmluamVjdCgnI2NoYXQtZXhhbXBsZTIgLmNoYXQtbGlzdCcsIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCB0aGlzLnZpZXdNb2RlbCkpWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAub2JzZXJ2ZSh0aGlzLnZpZXdNb2RlbC5jaGF0cyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluamVjdCBhbGwgY2hhdCBlbnRyeSBjb21wb25lbnRzIGluIG9uZSBnb1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSBBcGlfMS5Cb3VuZENvbXBvbmVudC5pbmplY3QoJyNjaGF0LWV4YW1wbGUyIC5jaGF0LWVkaXRvciAuY29tcG9uZW50JywgeyBvYnNlcnZlVmlld01vZGVsOiB0cnVlIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCB0aGlzLmN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbmxpbmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJtaXQoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRDaGF0KHRoaXMuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG5ld2NoYXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmN1cnJlbnQsIG5ld2NoYXQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUyaHRtbCA9IGV4YW1wbGUxaHRtbC5yZXBsYWNlKCdleGFtcGxlMScsICdleGFtcGxlMicpLnJlcGxhY2UoJ0V4YW1wbGUgMScsICdFeGFtcGxlIDInKTtcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlSHRtbChleGFtcGxlMmh0bWwpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGUyVmlldyA9IG5ldyBDaGF0VmlldzIoY2hhdGxpc3QpO1xuICAgICAgICAgICAgdGVzdENvbXBvbmVudChleGFtcGxlMlZpZXcpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXNzZXJ0Q29tcG9uZW50KGV4YW1wbGUyVmlldywgY2hhdGxpc3QpKTtcbiAgICAgICAgICAgIC8vIFNvbWUgcGVvcGxlIGRvbid0IGxpa2UgdGhlIERJViBzb3VwIHRoYXQgbWFrZXMgdXAgbW9zdCBIVE1MLiBJdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGhhdmUgY3VzdG9tIGVsZW1lbnRzIHRoYXQgc2F5XG4gICAgICAgICAgICAvLyB3aGF0IHRoZXkgYXJlLiBJdCBpcyB0aGVzZSBwZW9wbGUgd2hvIGFyZSBnaXZpbmcgdXMgd2ViIGNvbXBvbmVudHMgKHdoaWNoIGFyZSBhIG5lYXQgaWRlYSBpZiB0aGV5IGNhbiBnZXQgdGhlbSB3b3JraW5nKVxuICAgICAgICAgICAgLy8gKHRob3VnaCBpbiBtb3N0IGNhc2VzIGl0IHdvdWxkIGluY3JlYXNlIG15IHdvcmtsb2FkIG1hbnkgdGltZXMpLiAgSXQgaXMgdG8gc3VwcG9ydCB0aGlzIHN0eWxlIG9mIGRldmVsb3BpbmcgdGhhdCBJIHdyb3RlXG4gICAgICAgICAgICAvLyB0aGUgaW5qZWN0KCkgbWV0aG9kIGZvci4gWW91IGNhbiB3cml0ZSBIVE1MIHRoYXQgbG9va3MgbGlrZSBpdCdzIHRydWx5IGNvbXBvbmVudGl6ZWQuXG4gICAgICAgICAgICAvLyBJdCB0YWtlcyBhIExPVCBvZiBjbGFzc2VzLCBob3dldmVyLCBhbmQgaXMgb3ZlcmtpbGwgZm9yIGFuIGV4YW1wbGUgdGhpcyBzaW1wbGUuXG4gICAgICAgICAgICBjbGFzcyBDaGF0TGlzdDMgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgLy8gSSdkIGxpa2UgdG8gY2FsbCB0aGlzIGluamVjdCwgYnV0IFRTJ3MgcmVzdHJpY3Rpb25zIG9uIG92ZXJyaWRlIG5hbWluZyBmb3JjZXMgbWUgdG8gYXZvaWQgdGhlIGZyaWVuZGxpZXN0IG5hbWVzLlxuICAgICAgICAgICAgICAgIHN0YXRpYyBhZGQodmlld01vZGVsLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmljcyBhcmUgdGhlIHdvcmRpZXN0IHRoaW5ncyBpbiB0eXBlc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluamVjdChgJHtwYXJlbnRJZH0gY2hhdC1saXN0YCwgeyByZXBsYWNlOiB0cnVlIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCB2aWV3TW9kZWwpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIdG1sOiBgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IDpsb29wPVwiY2hhdHNcIiBjbGFzcz1cImNvbXBvbmVudCBjaGF0LWxpc3RcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PiM8aS12PmlkPC9pLXY+IEZyb206PGktdj5mcm9tTmFtZTwvaS12PiBhdCA8aS12PmNyZWF0ZWQ8L2ktdj4uIDxpLXY+c3ViamVjdDwvaS12PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxpLXY+c3RyaXBwZWQ8L2ktdj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PmAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVGFyZ2V0czogW3ZpZXdNb2RlbC5jaGF0c11cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdFN1YmplY3REaXNwbGF5MyBleHRlbmRzIEFwaV8xLkJvdW5kQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBzdGF0aWMgYWRkKHZpZXdNb2RlbCwgcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5qZWN0KGAke3BhcmVudElkfSBjaGF0LXN1YmplY3QtZGlzcGxheWAsIHsgcmVwbGFjZTogdHJ1ZSB9LCBBcGlfMS5rdygndmlld01vZGVsJywgdmlld01vZGVsKSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySHRtbDogYDxkaXYgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1zdWJqZWN0LWRpc3BsYXlcIiA6dGV4dD1cInN1YmplY3RcIiA6aWY9XCJzdWJqZWN0XCI+PC9kaXY+YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdFN1YmplY3QzIGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIHN0YXRpYyBhZGQodmlld01vZGVsLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGNvbXBvbmVudCAobm90IGJvdW5kIGNvbXBvbmVudCkgaW5qZWN0aW9uIHRvIGZpbGwgb3V0IHN0YXRpYyB0ZXh0LCBsaWtlIGxhYmVscy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBBcGlfMS5Db21wb25lbnQuaW5qZWN0KGAke3BhcmVudElkfSBjaGF0LXN1YmplY3RgLCBgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlN1YmplY3Q6PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImNvbXBvbmVudCBjaGF0LXN1YmplY3RcIiA6aW5wdXQ6PVwic3ViamVjdFwiIDpzd2l0Y2gtOnJlZD1cInN1YmplY3RcIiAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0U3ViamVjdDModmlld01vZGVsLCB7IHBhcmVudDogaW5qZWN0ZWQuY29udGVudCwgc2VsZWN0b3I6ICdpbnB1dCcsIG9ic2VydmVWaWV3TW9kZWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdEZyb20zIGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIHN0YXRpYyBhZGQodmlld01vZGVsLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmplY3RlZCA9IEFwaV8xLkNvbXBvbmVudC5pbmplY3QoYCR7cGFyZW50SWR9IGNoYXQtZnJvbWAsIGBcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+RnJvbTo8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiY29tcG9uZW50IGNoYXQtZnJvbVwiIDppbnB1dDo9XCJmcm9tTmFtZVwiIDpzd2l0Y2gtOnJlZD1cImZyb21OYW1lXCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgYClbMF07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hhdEZyb20zKHZpZXdNb2RlbCwgeyBwYXJlbnQ6IGluamVjdGVkLmNvbnRlbnQsIHNlbGVjdG9yOiAnaW5wdXQnLCBvYnNlcnZlVmlld01vZGVsOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRNZXNzYWdlMyBleHRlbmRzIEFwaV8xLkJvdW5kQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBzdGF0aWMgYWRkKHZpZXdNb2RlbCwgcGFyZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5qZWN0ZWQgPSBBcGlfMS5Db21wb25lbnQuaW5qZWN0KGAke3BhcmVudElkfSBjaGF0LW1lc3NhZ2VgLCBgXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx0ZXh0YXJlYSBjbGFzcz1cImNvbXBvbmVudCBjaGF0LW1lc3NhZ2VcIiA6aW5wdXQ6PVwibWVzc2FnZVwiIDpzd2l0Y2gtOnJlZD1cIm1lc3NhZ2VcIj48L3RleHRhcmVhPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICBgKVswXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGF0TWVzc2FnZTModmlld01vZGVsLCB7IHBhcmVudDogaW5qZWN0ZWQuY29udGVudCwgc2VsZWN0b3I6ICd0ZXh0YXJlYScsIG9ic2VydmVWaWV3TW9kZWw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdENsb3NpbmczIGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIHN0YXRpYyBhZGQodmlld01vZGVsLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3QoYCR7cGFyZW50SWR9IGNoYXQtY2xvc2luZ2AsIHsgcmVwbGFjZTogdHJ1ZSB9LCBBcGlfMS5rdygndmlld01vZGVsJywgdmlld01vZGVsKSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dGVySHRtbDogYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1jbG9zaW5nXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpLXY+Y2xvc2luZzwvaS12PiA8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGktdj5mcm9tTmFtZTwvaS12PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PmAsXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRTdWJtaXQzIGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIHN0YXRpYyBhZGQodmlld01vZGVsLCBwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmplY3QoYCR7cGFyZW50SWR9IGNoYXQtc3VibWl0YCwgeyByZXBsYWNlOiB0cnVlIH0sIEFwaV8xLmt3KCd2aWV3TW9kZWwnLCB2aWV3TW9kZWwpKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ZXJIdG1sOiBgPGJ1dHRvbiBjbGFzcz1cImNvbXBvbmVudCBjaGF0LXN1Ym1pdFwiIHR5cGU9XCJzdWJtaXRcIiA6Ym9vbDpkaXNhYmxlZD1cImludmFsaWRcIj5TdWJtaXQ8L2J1dHRvbj5gLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0VmlldzMgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJZCA9ICcjY2hhdC1leGFtcGxlMyc7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHsgc2VsZWN0b3I6IHBhcmVudElkIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52aWV3TW9kZWwuYmVnaW5DaGF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdCA9IENoYXRMaXN0My5hZGQodGhpcy52aWV3TW9kZWwsIHBhcmVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0RGlzcGxheTogQ2hhdFN1YmplY3REaXNwbGF5My5hZGQodGhpcy5jdXJyZW50LCBwYXJlbnRJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0OiBDaGF0U3ViamVjdDMuYWRkKHRoaXMuY3VycmVudCwgcGFyZW50SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogQ2hhdEZyb20zLmFkZCh0aGlzLmN1cnJlbnQsIHBhcmVudElkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IENoYXRNZXNzYWdlMy5hZGQodGhpcy5jdXJyZW50LCBwYXJlbnRJZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zaW5nOiBDaGF0Q2xvc2luZzMuYWRkKHRoaXMuY3VycmVudCwgcGFyZW50SWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBDaGF0U3VibWl0My5hZGQodGhpcy5jdXJyZW50LCBwYXJlbnRJZClcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJbmxpbmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdWJtaXQoZXZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbC5hZGRDaGF0KHRoaXMuY3VycmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKG5ld2NoYXQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmN1cnJlbnQsIG5ld2NoYXQpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBjb25zb2xlLmVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgd2hlcmUgdGhlIFwid2ViIHNlcnZlclwiIHJldHVybnMgYSBzdGF0aWMgcGFnZVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZTNodG1sID0gYFxuICAgICAgICAgICAgPGRpdiBpZD1cImNoYXQtZXhhbXBsZTNcIiBjbGFzcz1cImNoYXQtZXhhbXBsZVwiPlxuICAgICAgICAgICAgICAgIDxoND5FeGFtcGxlIDM8L2g0PiA8IS0tIE1pc3VzaW5nIGhlYWRpbmcgdGFncyBieSBqdW1waW5nIHRvIEg0LS0+XG4gICAgICAgICAgICAgICAgPGNoYXQtbGlzdD48L2NoYXQtbGlzdD5cbiAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hhdC1lZGl0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAgPGZvcm0gOmV2ZW50IChzdWJtaXQpPVwic3VibWl0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2hhdC1zdWJqZWN0LWRpc3BsYXk+PC9jaGF0LXN1YmplY3QtZGlzcGxheT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjaGF0LWZyb20+PC9jaGF0LWZyb20+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2hhdC1zdWJqZWN0PjwvY2hhdC1zdWJqZWN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGNoYXQtbWVzc2FnZT48L2NoYXQtbWVzc2FnZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjaGF0LWNsb3Npbmc+PC9jaGF0LWNsb3Npbmc+XG4gICAgICAgICAgICAgICAgICAgICAgICA8Y2hhdC1zdWJtaXQ+PC9jaGF0LXN1Ym1pdD5cbiAgICAgICAgICAgICAgICAgICAgPC9mb3JtPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChBcGlfMS5jcmVhdGVIdG1sKGV4YW1wbGUzaHRtbCkpO1xuICAgICAgICAgICAgY29uc3QgZXhhbXBsZTNWaWV3ID0gbmV3IENoYXRWaWV3MyhjaGF0bGlzdCk7XG4gICAgICAgICAgICB0ZXN0Q29tcG9uZW50KGV4YW1wbGUzVmlldyk7XG4gICAgICAgICAgICBhc3luY0Fzc2VydHMudGhlbigoKSA9PiBhc3NlcnRDb21wb25lbnQoZXhhbXBsZTNWaWV3LCBjaGF0bGlzdCkpO1xuICAgICAgICAgICAgLy8gSXQncyBub3QgbmVjZXNzYXJ5IHRvIHVzZSBjdXN0b20gdGFncy4gWW91IGNhbiBnZXQgc2ltaWxhciBIVE1MIHdoaWxlIGtlZXBpbmcgdGhpbmdzIHZhbmlsbGEgYW5kIGRvaW5nIG1vc3Qgb2YgdGhlIHdvcmtcbiAgICAgICAgICAgIC8vIG9uIHRoZSBKUyBzaWRlLiBUaGlzIGV4YW1wbGUgd2lsbCBhdm9pZCB1c2luZyBpbmplY3Rpb24uICBUaGF0IG1ha2VzIHRoaW5ncyBtb3JlIHZlcmJvc2UuXG4gICAgICAgICAgICBjbGFzcyBDaGF0TGlzdDQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQucXVlcnlTZWxlY3RvcignLmNoYXQtbGlzdCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+IzxpLXY+aWQ8L2ktdj4gRnJvbTo8aS12PmZyb21OYW1lPC9pLXY+IGF0IDxpLXY+Y3JlYXRlZDwvaS12Pi4gPGktdj5zdWJqZWN0PC9pLXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+PGktdj5zdHJpcHBlZDwvaS12PjwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PmBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfbG9vcDogXCJjaGF0c1wiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZVRhcmdldHM6IFt2aWV3TW9kZWwuY2hhdHNdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRTdWJqZWN0RGlzcGxheTQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQucXVlcnlTZWxlY3RvcignLmNoYXQtc3ViamVjdC1kaXNwbGF5JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfdGV4dDogXCJzdWJqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfaWY6IFwic3ViamVjdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0U3ViamVjdDQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGlzIGhhcyB3cmFwcGVyIEhUTUwsIHdlIG5lZWQgdG8gYWRkIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBBcyBsb25nIGFzIHdlIGRvbid0IHJlZmVyZW5jZSB0aGlzLCB3ZSBjYW4gZG8gaXQgYmVmb3JlIHRoZSBzdXBlcigpIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBBcGlfMS5kaXYoYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPlN1YmplY3Q6PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImNvbXBvbmVudCBjaGF0LXN1YmplY3RcIiA6aW5wdXQ6PVwic3ViamVjdFwiIDpzd2l0Y2gtOnJlZD1cInN1YmplY3RcIiAvPlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaGF0LXN1YmplY3QnKS5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRGcm9tNCBleHRlbmRzIEFwaV8xLkJvdW5kQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWwsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd3JhcHBlciBIVE1MXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBBcGlfMS5kaXYoYFxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+RnJvbTo8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1mcm9tXCIgOmlucHV0Oj1cImZyb21OYW1lXCIgOnN3aXRjaC06cmVkPVwiZnJvbU5hbWVcIiAvPlxuICAgICAgICAgICAgICAgICAgICBgKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaGF0LWZyb20nKS5hcHBlbmRDaGlsZCh3cmFwcGVyKTtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB3cmFwcGVyLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRNZXNzYWdlNCBleHRlbmRzIEFwaV8xLkJvdW5kQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWwsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd3JhcHBlciBIVE1MXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZXIgPSBBcGlfMS5kaXYoYFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRleHRhcmVhIGNsYXNzPVwiY29tcG9uZW50IGNoYXQtbWVzc2FnZVwiIDppbnB1dDo9XCJtZXNzYWdlXCIgOnN3aXRjaC06cmVkPVwibWVzc2FnZVwiPjwvdGV4dGFyZWE+XG4gICAgICAgICAgICAgICAgICAgIGApO1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucXVlcnlTZWxlY3RvcignLmNoYXQtbWVzc2FnZScpLmFwcGVuZENoaWxkKHdyYXBwZXIpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHdyYXBwZXIucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdENsb3Npbmc0IGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5jaGF0LWNsb3NpbmcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckhUTUw6IGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGktdj5jbG9zaW5nPC9pLXY+IDxiciAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aS12PmZyb21OYW1lPC9pLXY+YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdFN1Ym1pdDQgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIodmlld01vZGVsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBwYXJlbnQucXVlcnlTZWxlY3RvcignLmNoYXQtc3VibWl0JyksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfYm9vbF9kaXNhYmxlZDogJ2ludmFsaWQnXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZVZpZXdNb2RlbDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0VmlldzQgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih7IHNlbGVjdG9yOiAnI2NoYXQtZXhhbXBsZTQnIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52aWV3TW9kZWwuYmVnaW5DaGF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdCA9IG5ldyBDaGF0TGlzdDQodGhpcy52aWV3TW9kZWwsIHRoaXMuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdERpc3BsYXk6IG5ldyBDaGF0U3ViamVjdERpc3BsYXk0KHRoaXMuY3VycmVudCwgdGhpcy5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3Q6IG5ldyBDaGF0U3ViamVjdDQodGhpcy5jdXJyZW50LCB0aGlzLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbmV3IENoYXRGcm9tNCh0aGlzLmN1cnJlbnQsIHRoaXMuY29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBuZXcgQ2hhdE1lc3NhZ2U0KHRoaXMuY3VycmVudCwgdGhpcy5jb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Npbmc6IG5ldyBDaGF0Q2xvc2luZzQodGhpcy5jdXJyZW50LCB0aGlzLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBuZXcgQ2hhdFN1Ym1pdDQodGhpcy5jdXJyZW50LCB0aGlzLmNvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZElubGluZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Ym1pdChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZENoYXQodGhpcy5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obmV3Y2hhdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudCwgbmV3Y2hhdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhpcyBpcyB3aGVyZSB0aGUgXCJ3ZWIgc2VydmVyXCIgcmV0dXJucyBhIHN0YXRpYyBwYWdlXG4gICAgICAgICAgICBjb25zdCBleGFtcGxlNGh0bWwgPSBgXG4gICAgICAgICAgICA8ZGl2IGlkPVwiY2hhdC1leGFtcGxlNFwiIGNsYXNzPVwiY2hhdC1leGFtcGxlXCI+XG4gICAgICAgICAgICAgICAgPGg0PkV4YW1wbGUgNDwvaDQ+IDwhLS0gTWlzdXNpbmcgaGVhZGluZyB0YWdzIGJ5IGp1bXBpbmcgdG8gSDQtLT5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29tcG9uZW50IGNoYXQtbGlzdFwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWVkaXRvclwiPlxuICAgICAgICAgICAgICAgICAgICA8Zm9ybSA6ZXZlbnQgKHN1Ym1pdCk9XCJzdWJtaXRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1zdWJqZWN0LWRpc3BsYXlcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LWZyb21cIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LXN1YmplY3RcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGF0LW1lc3NhZ2VcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb21wb25lbnQgY2hhdC1jbG9zaW5nXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiY29tcG9uZW50IGNoYXQtc3VibWl0XCI+U3VibWl0PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlSHRtbChleGFtcGxlNGh0bWwpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4YW1wbGU0VmlldyA9IG5ldyBDaGF0VmlldzQoY2hhdGxpc3QpO1xuICAgICAgICAgICAgdGVzdENvbXBvbmVudChleGFtcGxlNFZpZXcpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXNzZXJ0Q29tcG9uZW50KGV4YW1wbGU0VmlldywgY2hhdGxpc3QpKTtcbiAgICAgICAgICAgIC8vIFNvbWUgZGV2ZWxvcGVycyBtYXkgd2FudCB0byBhZGQgZXZlcnl0aGluZyBpbiBqYXZhc2NyaXB0IHVzaW5nIGRvbSBtYW5pcHVsYXRpb24gbWV0aG9kcy5cbiAgICAgICAgICAgIC8vIFRoaXMgY29kaW5nIHN0eWxlIHByb2R1Y2VzIG1heGltdW0gdmVyYm9zaXR5LCBhbmQgcHJvYmFibHkgd2lsbCBub3QgYmUgdXNlZCBmb3IgYSBsYXJnZSB2aWV3LFxuICAgICAgICAgICAgLy8gYnV0IGl0IG1pZ2h0IGJlIHVzZWQgZm9yIHNtYWxsIGNvbXBvbmVudHMgaGVyZSBhbmQgdGhlcmUuXG4gICAgICAgICAgICBjbGFzcyBDaGF0TGlzdDUgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTERpdkVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4jPGktdj5pZDwvaS12PiBGcm9tOjxpLXY+ZnJvbU5hbWU8L2ktdj4gYXQgPGktdj5jcmVhdGVkPC9pLXY+LiA8aS12PnN1YmplY3Q8L2ktdj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj48aS12PnN0cmlwcGVkPC9pLXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+YFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2NvbXBvbmVudCBjaGF0LWxpc3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk1X2xvb3A6IFwiY2hhdHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVUYXJnZXRzOiBbdmlld01vZGVsLmNoYXRzXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0U3ViamVjdERpc3BsYXk1IGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHR5cGUgaXMgb3B0aW9uYWwgKERJViBpcyBkZWZhdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnY29tcG9uZW50IGNoYXQtc3ViamVjdC1kaXNwbGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpNV90ZXh0OiBcInN1YmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpNV9pZjogXCJzdWJqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRTdWJqZWN0NSBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHsgcHJvcGVydGllczogeyBpbm5lckhUTUw6IGA8c3Bhbj5TdWJqZWN0Ojwvc3Bhbj5gIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIGFyZSB0d28gcG9zc2libGUgd2F5cyB0byBoYW5kbGUgdGhlIHdyYXBwZXIgRElWLlxuICAgICAgICAgICAgICAgICAgICAvLyBPbmUgd2F5IGlzIHRvIHBhc3MgdGhlIHBhcmVudCBpbnRvIHRoZSBjb25zdHJ1Y3RvciwgYW5kIHRoZSBzYW1lIGFzIGluIGV4YW1wbGUgNCxcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgd3JhcHBlciBkaXYgYW5kIGluc2VydCBpbnRvIGl0LiBCdXQganVzdCB0byBiZSBkaWZmZXJlbnQsIGV4YW1wbGUgNSB3aWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIGVudGlyZSBkaXYsIGluY2x1ZGluZyB0aGUgbGFiZWwsIGludG8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ib3VuZCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh2aWV3TW9kZWwsIG5ldyBBcGlfMS5Jbm5lckh0bWxCaW5kaW5nT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBBcGlfMS5lbGVtZW50VHlwZS5IVE1MSW5wdXRFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAnY29tcG9uZW50IGNoYXQtc3ViamVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfaW5wdXRfdmFsdWU6IFwic3ViamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk1X3N3aXRjaDBfcmVkOiBcInN1YmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpLmFwcGVuZFRvUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRGcm9tNSBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHsgcHJvcGVydGllczogeyBpbm5lckhUTUw6IGA8c3Bhbj5Gcm9tOjwvc3Bhbj5gIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm91bmQgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodmlld01vZGVsLCBuZXcgQXBpXzEuSW5uZXJIdG1sQmluZGluZ09wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTElucHV0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2NvbXBvbmVudCBjaGF0LWZyb20nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk1X2lucHV0X3ZhbHVlOiBcImZyb21OYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTVfc3dpdGNoMF9yZWQ6IFwiZnJvbU5hbWVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSkpLmFwcGVuZFRvUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRNZXNzYWdlNSBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYm91bmQgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodmlld01vZGVsLCBuZXcgQXBpXzEuSW5uZXJIdG1sQmluZGluZ09wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTFRleHRBcmVhRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogJ2NvbXBvbmVudCBjaGF0LW1lc3NhZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk1X2lucHV0X3ZhbHVlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpNV9zd2l0Y2gwX3JlZDogXCJtZXNzYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pKS5hcHBlbmRUb1BhcmVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBDaGF0Q2xvc2luZzUgZXh0ZW5kcyBBcGlfMS5Cb3VuZENvbXBvbmVudCB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3Iodmlld01vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHZpZXdNb2RlbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnkgcHJvcGVydGllcyBpbiBIVE1MIGNhbiBiZSBjcmVhdGVkIGVpdGhlciBhcyBhdHRyaWJ1dGVzIG9yIHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IHJlbWVtYmVyIHRoYXQgbmFtZXMgbWF5IGNoYW5nZSwgYXMgY2xhc3MgYmVjb21lcyBjbGFzc05hbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY29tcG9uZW50IGNoYXQtY2xvc2luZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJIVE1MOiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpLXY+Y2xvc2luZzwvaS12PiA8YnIgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGktdj5mcm9tTmFtZTwvaS12PmBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZlVmlld01vZGVsOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIENoYXRTdWJtaXQ1IGV4dGVuZHMgQXBpXzEuQm91bmRDb21wb25lbnQge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlcih2aWV3TW9kZWwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxCdXR0b25FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVySFRNTDogJ1N1Ym1pdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Ym1pdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6ICdjb21wb25lbnQgY2hhdC1zdWJtaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk1X2Jvb2xfZGlzYWJsZWQ6ICdpbnZhbGlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmVWaWV3TW9kZWw6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQ2hhdFZpZXc1IGV4dGVuZHMgQXBpXzEuQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjaGF0LWV4YW1wbGU1JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjaGF0LWV4YW1wbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52aWV3TW9kZWwuYmVnaW5DaGF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdCA9IG5ldyBDaGF0TGlzdDUodGhpcy52aWV3TW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3REaXNwbGF5OiBuZXcgQ2hhdFN1YmplY3REaXNwbGF5NSh0aGlzLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ViamVjdDogbmV3IENoYXRTdWJqZWN0NSh0aGlzLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogbmV3IENoYXRGcm9tNSh0aGlzLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbmV3IENoYXRNZXNzYWdlNSh0aGlzLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2luZzogbmV3IENoYXRDbG9zaW5nNSh0aGlzLmN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uOiBuZXcgQ2hhdFN1Ym1pdDUodGhpcy5jdXJyZW50KSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MSGVhZGluZzRFbGVtZW50LCB7IGlubmVySFRNTDogJ0V4YW1wbGUgNScgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMubGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MQlJFbGVtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IEFwaV8xLmRpdignJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnY2hhdC1lZGl0b3InXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MRm9ybUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHRoaXMuZWRpdG9yLnN1YmplY3REaXNwbGF5LmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHRoaXMuZWRpdG9yLmZyb20uY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3Iuc3ViamVjdC5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRvci5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHRoaXMuZWRpdG9yLmNsb3NpbmcuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3IuYnV0dG9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuc3VibWl0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVkaXRvcikuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Ym1pdChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZENoYXQodGhpcy5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obmV3Y2hhdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudCwgbmV3Y2hhdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRG9pbmcgZXZlcnl0aGluZyBpbiBqYXZhc2NyaXB0LCBob3dldmVyLCBtZWFucyBmZXcgYXNzdW1wdGlvbnMgYWJvdXQgd2hhdCBIVE1MIHRoZSB3ZWIgc2VydmVyIHJldHVybnMuXG4gICAgICAgICAgICAvLyBXZSBmaW5kIGEgY29udGFpbmVyLCBjcmVhdGUgdGhlIHZpZXcsIGFuZCBkcm9wIHRoZSB2aWV3IGludG8gaXQuXG4gICAgICAgICAgICBjb25zdCBleGFtcGxlNVZpZXcgPSBuZXcgQ2hhdFZpZXc1KGNoYXRsaXN0KTtcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWEuYXBwZW5kQ2hpbGQoZXhhbXBsZTVWaWV3LmNvbnRlbnQpO1xuICAgICAgICAgICAgdGVzdENvbXBvbmVudChleGFtcGxlNVZpZXcpO1xuICAgICAgICAgICAgYXN5bmNBc3NlcnRzLnRoZW4oKCkgPT4gYXNzZXJ0Q29tcG9uZW50KGV4YW1wbGU1VmlldywgY2hhdGxpc3QpKTtcbiAgICAgICAgICAgIC8vIEkgc2FpZCBleGFtcGxlIDUgd2FzIG1heGltdW0gdmVyYm9zaXR5LCBidXQgVEhJUyBpcyBtYXhpbXVtIHZlcmJvc2l0eS4gU2F5IHlvdSByZWFsbHkgbGlrZWQgdGhlIGZsdWVudCBpbnRlcmZhY2VcbiAgICAgICAgICAgIC8vIGFuZCB3YW50ZWQgdG8gdXNlIGZsdWVudCBtZXRob2RzIGZvciBldmVyeXRoaW5nIGFuZCBub3QgZG8gYW55dGhpbmcgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgLy8gVG8gbWFrZSB0aGluZ3MgZXZlbiBuYXN0aWVyLCBJJ2xsIGRvIGl0IGFsbCBpbiBhIHNpbmdsZSB2aWV3LCB3aXRob3V0IGV2ZW4gZW5jYXBzdWxhdGluZyB0aGVtIGluIGluZGl2aWR1YWxcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCBjbGFzc2VzIC4uLiB0aGlzIGlzIHN1Y2ggYSBwYWluIHRoYXQgbm8gZGV2ZWxvcGVyIHdvdWxkIGV2ZXIgbWFrZSBhIHdob2xlIHBhZ2UgbGlrZSB0aGlzLCBidXRcbiAgICAgICAgICAgIC8vIGRvaW5nIGl0IGZvciBhIHF1aWNrIGVsZW1lbnQgd291bGQgYmUgbm8gcHJvYmxlbS4gSW4gZmFjdCwgVlNDb2RlJ3Mgc3VnZ2VzdGlvbnMgYXJlIE1VQ0ggYmV0dGVyIGZvciBtZXRob2RzIGFzXG4gICAgICAgICAgICAvLyBmb3IgY29uc3RydWN0b3IgYXJndW1lbnRzLlxuICAgICAgICAgICAgY2xhc3MgQ2hhdFZpZXc2IGV4dGVuZHMgQXBpXzEuQ29tcG9uZW50IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3TW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdjaGF0LWV4YW1wbGU2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjaGF0LWV4YW1wbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy52aWV3TW9kZWwuYmVnaW5DaGF0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MSGVhZGluZzRFbGVtZW50LCB7IGlubmVySFRNTDogJ0V4YW1wbGUgNicgfSkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3QgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy52aWV3TW9kZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbXBvbmVudCBjaGF0LWxpc3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldExvb3AoJ2NoYXRzJywgYDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj4jPGktdj5pZDwvaS12PiBGcm9tOjxpLXY+ZnJvbU5hbWU8L2ktdj4gYXQgPGktdj5jcmVhdGVkPC9pLXY+LiA8aS12PnN1YmplY3Q8L2ktdj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PjxpLXY+c3RyaXBwZWQ8L2ktdj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PmApXG4gICAgICAgICAgICAgICAgICAgICAgICAub2JzZXJ2ZSh0aGlzLnZpZXdNb2RlbC5jaGF0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW5kZXIoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvUGFyZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTEJSRWxlbWVudCkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0RGlzcGxheSA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbXBvbmVudCBjaGF0LXN1YmplY3QtZGlzcGxheScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VGV4dFRlbXBsYXRlKCdzdWJqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWaXNpYmlsaXR5KCdzdWJqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYnNlcnZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViamVjdCA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh0aGlzLmN1cnJlbnQsIHsgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTElucHV0RWxlbWVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKCdjb21wb25lbnQgY2hhdC1zdWJqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZUF0dHJpYnV0ZSgnc3ViamVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkV3JpdGVUYXJnZXQoJ3N1YmplY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFdyaXRlRXZlbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENzc0NsYXNzU3dpdGNoKCdyZWQnLCAnc3ViamVjdCcsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAub2JzZXJ2ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy5jdXJyZW50LCB7IHR5cGU6IEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxJbnB1dEVsZW1lbnQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnY29tcG9uZW50IGNoYXQtZnJvbScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWVBdHRyaWJ1dGUoJ2Zyb21OYW1lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRXcml0ZVRhcmdldCgnZnJvbU5hbWUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZFdyaXRlRXZlbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENzc0NsYXNzU3dpdGNoKCdyZWQnLCAnZnJvbU5hbWUnLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9ic2VydmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gbmV3IEFwaV8xLkJvdW5kQ29tcG9uZW50KHRoaXMuY3VycmVudCwgeyB0eXBlOiBBcGlfMS5lbGVtZW50VHlwZS5IVE1MVGV4dEFyZWFFbGVtZW50IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbXBvbmVudCBjaGF0LW1lc3NhZ2UnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFZhbHVlQXR0cmlidXRlKCdtZXNzYWdlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRXcml0ZVRhcmdldCgnbWVzc2FnZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkV3JpdGVFdmVudCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ3NzQ2xhc3NTd2l0Y2goJ3JlZCcsICdtZXNzYWdlJywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYnNlcnZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvc2luZyA9IG5ldyBBcGlfMS5Cb3VuZENvbXBvbmVudCh0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbXBvbmVudCBjaGF0LWNsb3NpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldFRlbXBsYXRlKGA8aS12PmNsb3Npbmc8L2ktdj4gPGJyIC8+IDxpLXY+ZnJvbU5hbWU8L2ktdj5gKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9ic2VydmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidXR0b24gPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy5jdXJyZW50LCBuZXcgQXBpXzEuSW5uZXJIdG1sQmluZGluZ09wdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQXBpXzEuZWxlbWVudFR5cGUuSFRNTEJ1dHRvbkVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7IGlubmVySFRNTDogJ1N1Ym1pdCcsIHR5cGU6ICdzdWJtaXQnIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbXBvbmVudCBjaGF0LXN1Ym1pdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQm9vbGVhbkF0dHJpYnV0ZU1hcHBpbmcoJ2Rpc2FibGVkJywgJ2ludmFsaWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm9ic2VydmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3REaXNwbGF5LCBzdWJqZWN0LCBmcm9tLCBtZXNzYWdlLCBjbG9zaW5nLCBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gQXBpXzEuZGl2KCcnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdjaGF0LWVkaXRvcidcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm0gPSBBcGlfMS5jcmVhdGVFbGVtZW50KEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxGb3JtRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3Iuc3ViamVjdERpc3BsYXkuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoQXBpXzEuZGl2KCc8c3Bhbj5Gcm9tOjwvc3Bhbj4nKSkuYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3IuZnJvbS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChBcGlfMS5kaXYoJzxzcGFuPlN1YmplY3Q6PC9zcGFuPicpKS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRvci5zdWJqZWN0LmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKEFwaV8xLmRpdigpKS5hcHBlbmRDaGlsZCh0aGlzLmVkaXRvci5tZXNzYWdlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHRoaXMuZWRpdG9yLmNsb3NpbmcuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQodGhpcy5lZGl0b3IuYnV0dG9uLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsIHRoaXMuc3VibWl0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGVkaXRvcikuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1Ym1pdChldnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld01vZGVsLmFkZENoYXQodGhpcy5jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4obmV3Y2hhdCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuY3VycmVudCwgbmV3Y2hhdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IGNvbnNvbGUuZXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhhbXBsZTZWaWV3ID0gbmV3IENoYXRWaWV3NihjaGF0bGlzdCk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKGV4YW1wbGU2Vmlldy5jb250ZW50KTtcbiAgICAgICAgICAgIHRlc3RDb21wb25lbnQoZXhhbXBsZTZWaWV3KTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IGFzc2VydENvbXBvbmVudChleGFtcGxlNlZpZXcsIGNoYXRsaXN0KSk7XG4gICAgICAgICAgICB0aGlzLmxvZygnU3RhcnRpbmcgYXN5bmMgdGVzdHMnKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy50aGVuKCgpID0+IHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IEFzeW5jIHRlc3RzIHN1Y2NlZWRlZGApKTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKCdBU1lOQyBURVNUUyBGQUlMRUQ6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFzeW5jQXNzZXJ0cy5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDExID0gVGVzdDAxMTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xucmVxdWlyZShcIi4uL3NyYy9FeHRlbnNpb25Mb2FkZXJcIik7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgVGVzdENhc2VWaWV3XzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdNb2RlbF8xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3TW9kZWxcIik7XG4vLyB0c2xpbnQ6ZGlzYWJsZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuY2xhc3MgVGVzdFZpZXdNb2RlbCBleHRlbmRzIFRlc3RDYXNlVmlld01vZGVsXzEuVGVzdENhc2VWaWV3TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiAnRXh0ZW5zaW9uIE1ldGhvZHMnLFxuICAgICAgICAgICAgZGVzY3JpcHRpb25IdG1sOiBgPHA+SW4gMjAxNywgdGhlIG9yaWdpbmFsIGdvYWwgd2FzIHRvIGhhdmUgb25lLWxpbmUgYmluZGluZyBvZiBIVE1MIGVsZW1lbnRzIHRvIGR5bmFtaWMgcHJvcGVydGllcywgYXMgaWZcbiAgICAgICAgICAgIGl0IHdlcmUgYSBidWlsdC1pbiBwYXJ0IG9mIHRoZSBIVE1MNSBzdGFuZGFyZC4gVGhpcyBldmVudHVhbGx5IGludm9sdmVkIHRoZSBjcmVhdGlvbiBvZiBwcm90b3R5cGUgZXh0ZW5zaW9uIG1ldGhvZHMuIFRoZVxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gaGFzIGNoYW5nZWQgLS0gbm93IGV2ZXJ5dGhpbmcgdXNlcyBjb21wb25lbnQgYmluZGluZyAtLSBidXQgdGhlIG9yaWdpbmFsIEFQSSBvZiBleHRlbnNpb24gbWV0aG9kcyByZW1haW5zLiBcbiAgICAgICAgICAgIEZ1cnRoZXIgZXh0ZW5zaW9ucyB3ZXJlIGNyZWF0ZWQgdG8gZG8gb3RoZXIgdXNlZnVsIHRhc2tzLCBzdWNoIGFzIHJlcGxhY2luZyBhbiBlbGVtZW50LjwvcD5cblxuICAgICAgICAgICAgPHA+VG8gYWRkIGV4dGVuc2lvbiBtZXRob2RzIHRvIHRoZSBIVE1MIGVsZW1lbnQgcHJvdG90eXBlcywgaW1wb3J0IEV4dGVuc2lvbkxvYWRlci50cyBkaXJlY3RseS48L3A+XG5cbiAgICAgICAgICAgIDxoMj5Vc2FnZTwvaDI+XG5cbiAgICAgICAgICAgIDxwPlRoZXNlIGFyZSBqdXN0IGxpbmtzIHRvIG90aGVyIG1ldGhvZHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZWZlcmVuY2VkIGVsc2V3aGVyZSwgc28gSSdtIGp1c3QgZ29pbmcgdG8gbGlzdCB0aGUgbWV0aG9kcy48L3A+XG5cbiAgICAgICAgICAgIDxwcmU+PGNvZGU+XG4gICAgICAgICAgICBpbnRlcmZhY2UgSFRNTEVsZW1lbnQge1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvUGFyZW50KHBhcmVudDogSFRNTEVsZW1lbnQpOiB0aGlzO1xuICAgICAgICAgICAgICAgIGFwcGVuZENoaWxkRmx1ZW50PFQgZXh0ZW5kcyBOb2RlPihjaGlsZDogVCk6IHRoaXM7XG4gICAgICAgICAgICAgICAgYXBwZW5kU2libGluZzxUIGV4dGVuZHMgTm9kZT4obmV4dDogVCk6IFQ7XG4gICAgICAgICAgICAgICAgYXBwZW5kU2libGluZ0ZsdWVudDxUIGV4dGVuZHMgTm9kZT4obmV4dDogVCk6IHRoaXM7XG4gICAgICAgICAgICAgICAgcmVwbGFjZVdpdGg8VCBleHRlbmRzIE5vZGU+KG5ld0VsZW1lbnQ6IFQpOiBUO1xuICAgICAgICAgICAgICAgIHN3YXA8VCBleHRlbmRzIE5vZGU+KGVsZW1lbnQ6IFQpOiBUO1xuICAgICAgICAgICAgICAgIGV4dHJhY3QoKTogdGhpcztcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyRmx1ZW50KGV2ZW50VHlwZTogc3RyaW5nLCBldmVudDogKGV2dDogRXZlbnQpID0+IGFueSwgb3B0aW9ucz86IEFkZEV2ZW50TGlzdGVuZXJPcHRpb25zKTogdGhpcztcbiAgICAgICAgICAgICAgICBhZGRTdHlsZShwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdGhpcztcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhjbGFzc05hbWVzOiBzdHJpbmcgfCBzdHJpbmdbXSk6IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcmZhY2UgRG9jdW1lbnRGcmFnbWVudCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlRWxlbWVudDxURWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50Pih0YWdOYW1lOiBzdHJpbmcsIHByb3BlcnRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBhdHRyaWJ1dGVzPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFRFbGVtZW50O1xuICAgICAgICAgICAgICAgIGNyZWF0ZUVsZW1lbnRGbHVlbnQodGFnTmFtZTogc3RyaW5nLCBwcm9wZXJ0aWVzPzogUmVjb3JkPHN0cmluZywgYW55PiwgYXR0cmlidXRlcz86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB0aGlzO1xuICAgICAgICAgICAgICAgIGFwcGVuZFRvUGFyZW50PFRFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHBhcmVudDogVEVsZW1lbnQpOiBURWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludGVyZmFjZSBIVE1MRWxlbWVudCB7XG4gICAgICAgICAgICAgICAgZ2V0Q29tcG9uZW50KHRoaXM6IEhUTUxFbGVtZW50KTogSUNvbnRlbnQgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgYmluZENvbXBvbmVudDxURWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50ID0gSFRNTEVsZW1lbnQsIFRNb2RlbCA9IGFueT4odGhpczogVEVsZW1lbnQsIHZpZXdNb2RlbDogVE1vZGVsKTogQm91bmRDb21wb25lbnQ8VEVsZW1lbnQsIFRNb2RlbD47XG4gICAgICAgICAgICAgICAgZGVsZXRlQ29tcG9uZW50KCk6IHZvaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcmZhY2UgT2JqZWN0IHtcbiAgICAgICAgICAgICAgICB0b09ic2VydmFibGU8VD4obmFtZT86IHN0cmluZyk6IE9ic2VydmFibGVQcm9wZXJ0eTxUPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGludGVyZmFjZSBTdHJpbmcge1xuICAgICAgICAgICAgICAgIHRvT2JzZXJ2YWJsZShuYW1lPzogc3RyaW5nKTogT2JzZXJ2YWJsZVByb3BlcnR5PHN0cmluZz47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnRlcmZhY2UgTnVtYmVyIHtcbiAgICAgICAgICAgICAgICB0b09ic2VydmFibGUobmFtZT86IHN0cmluZyk6IE9ic2VydmFibGVQcm9wZXJ0eTxudW1iZXI+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJmYWNlIEJvb2xlYW4ge1xuICAgICAgICAgICAgICAgIHRvT2JzZXJ2YWJsZShuYW1lPzogc3RyaW5nKTogT2JzZXJ2YWJsZVByb3BlcnR5PGJvb2xlYW4+O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgPC9jb2RlPjwvcHJlPlxuXG4gICAgICAgICAgICA8aDI+V2FybmluZzwvaDI+XG4gICAgICAgICAgICA8cD5UZXN0cyBhcmUgYXN5bmMgYW5kIHdpbGwga2VlcCBydW5uaW5nLiBXYWl0IGZvciB0ZXN0cyB0byBjb21wbGV0ZSBiZWZvcmUgbGVhdmluZyBwYWdlLjwvcD5cbiAgICAgICAgICAgIGBcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVGVzdDAxMiBleHRlbmRzIFRlc3RDYXNlVmlld18xLlRlc3RDYXNlVmlldyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKG5ldyBUZXN0Vmlld01vZGVsKCkpO1xuICAgIH1cbiAgICB0ZXN0Q2FzZSgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjbGlja1Rlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0RpdiA9IEFwaV8xLmRpdihcIlBBUkVOVFwiLCB7IGlkOiBcIm5ld0RpdlwiIH0pO1xuICAgICAgICAgICAgY29uc3Qgc2lzdGVyID0gbmV3RGl2LmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpXG4gICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkRmx1ZW50KEFwaV8xLmRpdihcIkNISUxEXCIsIHsgaWQ6IFwiY2hpbGRcIiB9KSlcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoXCJzb21lLWNsYXNzXCIpXG4gICAgICAgICAgICAgICAgLmFkZFN0eWxlKFwidGV4dC1kZWNvcmF0aW9uXCIsIFwidW5kZXJsaW5lXCIpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFNpYmxpbmdGbHVlbnQoQXBpXzEuZGl2KFwiQlJPVEhFUlwiLCB7IGlkOiBcImJyb3RoZXJcIiB9KSlcbiAgICAgICAgICAgICAgICAuYXBwZW5kU2libGluZyhBcGlfMS5kaXYoXCJTSVNURVJcIiwgeyBpZDogXCJzaXN0ZXJcIiB9KSlcbiAgICAgICAgICAgICAgICAuYWRkRXZlbnRMaXN0ZW5lckZsdWVudChcImNsaWNrXCIsICgpID0+IHsgY2xpY2tUZXN0ID0gdHJ1ZTsgfSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQobmV3RGl2LnBhcmVudEVsZW1lbnQgPT09IHRoaXMudGVzdEFyZWEsIFwiQXBwZW5kVG9QYXJlbnQgYWRvcHRzIHBhcmVudCBlbGVtZW50XCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hpbGRcIikucGFyZW50RWxlbWVudCA9PT0gbmV3RGl2LCBcIkFwcGVuZENoaWxkRmx1ZW50IHdvcmtzIGFzIGFwcGVuZENoaWxkXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG5ld0Rpdi5jbGFzc05hbWUgPT09ICdzb21lLWNsYXNzJywgXCJBZGRDbGFzcyBhZGRzIGEgY2xhc3MsIGFuZCBhcHBlbmRDaGlsZEZsdWVudCByZXR1cm5lZCByZWZlcmVuY2UgdG8gZmx1ZW50IG9iamVjdFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChuZXdEaXYuc3R5bGUudGV4dERlY29yYXRpb24gPT09ICd1bmRlcmxpbmUnLCBcIkFkZFN0eWxlIGFkZHMgYSBzdHlsZSwgYW5kIGFkZENsYXNzIHJldHVybmVkIHJlZmVyZW5jZSB0byBmbHVlbnQgb2JqZWN0XCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiYnJvdGhlclwiKS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLnRlc3RBcmVhLCBcIkFwcGVuZFNpYmxpbmdGbHVlbnQgYWRkcyBhIHNpYmxpbmcgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpc3RlclwiKS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLnRlc3RBcmVhLCBcIkFwcGVuZFNpYmxpbmcgYWRkcyBhIHNpYmxpbmcgZWxlbWVudCBhbmQgYXBwZW5kU2libGluZ0ZsdWVudCByZXR1cm5lZCByZWZlcmVuY2UgdG8gZmx1ZW50IG9iamVjdFwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpc3RlclwiKSA9PT0gc2lzdGVyLCBcIkFwcGVuZFNpYmxpbmcgcmV0dXJucyByZWZlcmVuY2UgdG8gYXJndW1lbnQgYW5kIGFkZEV2ZW50TGlzdGVuZXJGbHVlbnQgcmV0dXJuZWQgcmVmZXJlbmNlIHRvIGZsdWVudCBvYmplY3RcIik7XG4gICAgICAgICAgICBzaXN0ZXIuY2xpY2soKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChjbGlja1Rlc3QsIFwiQWRkRXZlbnRMaXN0ZW5lckZsdWVudCBhZGRzIGNsaWNrIGhhbmRsZXJcIik7XG4gICAgICAgICAgICBjb25zdCBleGNoYW5nZVN0dWRlbnQgPSB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdihcIkZBTUlMWSBJTiBBTk9USEVSIENPVU5UUllcIiwgeyBpZDogXCJmb3JlaWduXCIgfSkpXG4gICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKEFwaV8xLmRpdihcIkVYQ0hBTkdFIFNUVURFTlRcIiwgeyBpZDogXCJleGNoYW5nZVwiIH0pKTtcbiAgICAgICAgICAgIGV4Y2hhbmdlU3R1ZGVudC5zd2FwKHNpc3Rlcik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmb3JlaWduXCIpID09PSBzaXN0ZXIucGFyZW50RWxlbWVudCAmJiBleGNoYW5nZVN0dWRlbnQucGFyZW50RWxlbWVudCA9PT0gdGhpcy50ZXN0QXJlYSwgXCJTd2FwIGV4Y2hhbmdlZCBlbGVtZW50IGxvY2F0aW9uc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHB1cHB5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjaGlsZFwiKS5yZXBsYWNlV2l0aChBcGlfMS5kaXYoXCJQVVBQWVwiKSk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQocHVwcHkucGFyZW50RWxlbWVudCA9PT0gbmV3RGl2ICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY2hpbGRcIikgPT09IG51bGwsIFwiUmVwbGFjZVdpdGggYWRkZWQgcmVwbGFjZWQgdGhlIGVsZW1lbnRcIik7XG4gICAgICAgICAgICBzaXN0ZXIuZXh0cmFjdCgpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2lzdGVyXCIpID09PSBudWxsLCBcIkV4dHJhY3QgcmVtb3ZlZCB0aGUgZWxlbWVudFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgICBmcmFnLmNyZWF0ZUVsZW1lbnRGbHVlbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTERpdkVsZW1lbnQsIHsgaW5uZXJIVE1MOiBcIkZyYWcgQnJvdGhlclwiLCBpZDogXCJmcmFnLWJyb3RoZXJcIiB9KVxuICAgICAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KEFwaV8xLmVsZW1lbnRUeXBlLkhUTUxEaXZFbGVtZW50LCB7IGlubmVySFRNTDogXCJGcmFnIFNpc3RlclwiLCBpZDogXCJmcmFnLXNpc3RlclwiIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZENoaWxkKEFwaV8xLmRpdihcIkZyYWcgTmVwaGV3XCIsIHsgaWQ6IFwiZnJhZy1uZXBoZXdcIiB9KSk7XG4gICAgICAgICAgICBmcmFnLmFwcGVuZFRvUGFyZW50KHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJhZy1icm90aGVyXCIpLnBhcmVudEVsZW1lbnQgPT09IHRoaXMudGVzdEFyZWEsIFwiQ3JlYXRlRWxlbWVudEZsdWVudCBjcmVhdGVkIGFuIGVsZW1lbnQgYW5kIGFwcGVuZFRvUGFyZW50IGFkZGVkIHRoZSBmcmFnbWVudCBjb250ZW50XCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZnJhZy1zaXN0ZXJcIikucGFyZW50RWxlbWVudCA9PT0gdGhpcy50ZXN0QXJlYSwgXCJDcmVhdGVFbGVtZW50IGNyZWF0ZWQgYW4gZWxlbWVudCBhbmQgQ3JlYXRlUmVmZXJlbmNGbHVlbnQgcmV0dXJuZWQgcmVmZXJlbmNlIHRvIGZsdWVudCBvYmplY3RcIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcmFnLW5lcGhld1wiKS5wYXJlbnRFbGVtZW50ID09PSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZyYWctc2lzdGVyXCIpLCBcIkNyZWF0ZUVsZW1lbnQgcmV0dXJuZWQgcmVmZXJlbmNlIHRvIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgY29uc3QgdGVzdFZpZXdNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIk15IE5hbWVcIi50b09ic2VydmFibGUoKSxcbiAgICAgICAgICAgICAgICBhZ2U6ICgyNCkudG9PYnNlcnZhYmxlKCksXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZWQ6IHRydWUudG9PYnNlcnZhYmxlKCksXG4gICAgICAgICAgICAgICAgZnJpZW5kOiBleGNoYW5nZVN0dWRlbnQudG9PYnNlcnZhYmxlKCksXG4gICAgICAgICAgICAgICAgZnJpZW5kc05hbWU6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZnJpZW5kLnZhbHVlLmlubmVySFRNTDsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh0ZXN0Vmlld01vZGVsLm5hbWUgaW5zdGFuY2VvZiBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHksIFwidG9PYnNlcnZhYmxlIG1hZGUgc2ltcGxlIHN0cmluZyBhbiBvYnNlcnZhYmxlXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHRlc3RWaWV3TW9kZWwuYWdlIGluc3RhbmNlb2YgQXBpXzEuT2JzZXJ2YWJsZVByb3BlcnR5LCBcInRvT2JzZXJ2YWJsZSBtYWRlIHNpbXBsZSBudW1iZXIgYW4gb2JzZXJ2YWJsZVwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh0ZXN0Vmlld01vZGVsLm9ic2VydmVkIGluc3RhbmNlb2YgQXBpXzEuT2JzZXJ2YWJsZVByb3BlcnR5LCBcInRvT2JzZXJ2YWJsZSBtYWRlIHNpbXBsZSBib29sIGFuIG9ic2VydmFibGVcIik7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodGVzdFZpZXdNb2RlbC5mcmllbmQgaW5zdGFuY2VvZiBBcGlfMS5PYnNlcnZhYmxlUHJvcGVydHksIFwidG9PYnNlcnZhYmxlIG1hZGUgb2JqZWN0IGFuIG9ic2VydmFibGVcIik7XG4gICAgICAgICAgICAvLyBOb3cgd2UgcHV0IGl0IGFsbCB0b2dldGhlci4gSSBkb24ndCByZWNvbW1lbmQgYnVpbGRpbmcgYSBmdWxsIGZvcm0gbGlrZSB0aGlzLiBTb21lb25lIHdpbGwgbmVlZCB0byBtYWludGFpbiBpdC5cbiAgICAgICAgICAgIC8vIFRoYXQgcGVyc29uIG1pZ2h0IGJlIHlvdS4gQnV0IGZvciBhZGRpbmcgYSBzaW5nbGUgYm91bmQgZWxlbWVudCwgaXQgY291bGQgd29yay5cbiAgICAgICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTEZvcm1FbGVtZW50KSk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MSW5wdXRFbGVtZW50LCB7IGlkOiBcIm5hbWVcIiB9KVxuICAgICAgICAgICAgICAgIC5iaW5kQ29tcG9uZW50KHRlc3RWaWV3TW9kZWwpXG4gICAgICAgICAgICAgICAgLnNldFZhbHVlQXR0cmlidXRlKFwibmFtZVwiKVxuICAgICAgICAgICAgICAgIC5hZGRXcml0ZVRhcmdldChcIm5hbWVcIilcbiAgICAgICAgICAgICAgICAuYWRkV3JpdGVFdmVudCgpXG4gICAgICAgICAgICAgICAgLm9ic2VydmUodGVzdFZpZXdNb2RlbC5uYW1lKVxuICAgICAgICAgICAgICAgIC5yZW5kZXIoKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUb1BhcmVudChmb3JtKTtcbiAgICAgICAgICAgIGNvbnN0IGFnZSA9IEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTElucHV0RWxlbWVudCwgeyB0eXBlOiBcIm51bWJlclwiLCBpZDogXCJhZ2VcIiB9KVxuICAgICAgICAgICAgICAgIC5iaW5kQ29tcG9uZW50KHRlc3RWaWV3TW9kZWwuYWdlKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZUF0dHJpYnV0ZSgpIC8vIGRlZmF1bHRzIHRvIC5cbiAgICAgICAgICAgICAgICAuYWRkV3JpdGVUYXJnZXQoKSAvLyBkZWZhdWx0cyB0byAuXG4gICAgICAgICAgICAgICAgLmFkZFdyaXRlRXZlbnQoKVxuICAgICAgICAgICAgICAgIC5vYnNlcnZlKClcbiAgICAgICAgICAgICAgICAucmVuZGVyKClcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG9QYXJlbnQoZm9ybSk7XG4gICAgICAgICAgICBjb25zdCBvYnNlcnZlZCA9IEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTElucHV0RWxlbWVudCwgeyBpZDogXCJvYnNlcnZlZFwiIH0sIHsgcmVhZG9ubHk6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAuYmluZENvbXBvbmVudCh0ZXN0Vmlld01vZGVsKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZUF0dHJpYnV0ZShcIm9ic2VydmVkXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvUGFyZW50KGZvcm0pO1xuICAgICAgICAgICAgY29uc3QgZnJpZW5kID0gQXBpXzEuY3JlYXRlRWxlbWVudChBcGlfMS5lbGVtZW50VHlwZS5IVE1MSW5wdXRFbGVtZW50LCB7IGlkOiBcImZyaWVuZFwiIH0sIHsgcmVhZG9ubHk6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAuYmluZENvbXBvbmVudCh0ZXN0Vmlld01vZGVsKVxuICAgICAgICAgICAgICAgIC5zZXRWYWx1ZUF0dHJpYnV0ZShcImZyaWVuZHNOYW1lXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvUGFyZW50KGZvcm0pO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KG5hbWUudmFsdWUgPT09IFwiTXkgTmFtZVwiLCBcIkVsZW1lbnQgYmluZGluZyBpcyBpbiBwbGFjZVwiKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChhZ2UudmFsdWUgPT09IDI0LCBcIkVsZW1lbnQgYmluZGluZyBpcyBpbiBwbGFjZSB3aXRoIGRlZmF1bHQgYXR0cmlidXRlXCIpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcmllbmQnKS5nZXRDb21wb25lbnQoKSA9PT0gZnJpZW5kLCBcIkdldENvbXBvbmVudCBnZXRzIHRoZSBjb21wb25lbnQgYm91bmRcIik7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVEVTVCAke3RoaXMudmlld01vZGVsLnRlc3ROdW1iZXJ9OiBCZWdpbiBBc3luYyBUZXN0YCk7XG4gICAgICAgICAgICBuYW1lLnZhbHVlID0gXCJOb3QgTXkgTmFtZVwiO1xuICAgICAgICAgICAgbmFtZS5jb250ZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB0ZXN0Vmlld01vZGVsLmFnZS52YWx1ZSA9IDI1O1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGFnZS52YWx1ZSA9PT0gMjUsIFwiVHdvLXdheSBiaW5kaW5nIGlzIHJlYWRpbmdcIik7XG4gICAgICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KHRlc3RWaWV3TW9kZWwubmFtZS52YWx1ZSA9PT0gXCJOb3QgTXkgTmFtZVwiLCBcIlR3by13YXkgYmluZGluZyBpcyB3cml0aW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGBURVNUICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IEFzeW5jIFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVEVTVCAke3RoaXMudmlld01vZGVsLnRlc3ROdW1iZXJ9OiBTeW5jIFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiRVJST1I6IFwiICsgZXJyKTtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGVzdDAxMiA9IFRlc3QwMTI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdfMSA9IHJlcXVpcmUoXCIuL1Rlc3RDYXNlVmlld1wiKTtcbmNvbnN0IFRlc3RDYXNlVmlld01vZGVsXzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdNb2RlbFwiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZXN0Vmlld01vZGVsIGV4dGVuZHMgVGVzdENhc2VWaWV3TW9kZWxfMS5UZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdEZWRpY2F0ZWQgV2ViIFdvcmtlciAoRXhwZXJpbWVudGFsKScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGA8cD5UaGlzIGlzIGFuIGV4cGVyaW1lbnRhbCB3ZWIgd29ya2VyIHRoYXQgY2FuIGJlIGNyZWF0ZWQgb24gdGhlIGZseSBhbmQgZGVkaWNhdGVkXG4gICAgICAgICAgICB0byBoZWF2eSB0YXNrcyB0aGF0LCBhc3N1bWluZyB0aGUgdXNlcidzIFBDIGlzIHBvd2VyZnVsIGVub3VnaCwgYmUgcnVuIG9uIGJhY2tncm91bmQgdGhyZWFkcyB3aXRob3V0XG4gICAgICAgICAgICBpbXBhY3RpbmcgZnJvbnQtZW5kIHBlcmZvcm1hbmNlLjwvcD5cblxuICAgICAgICAgICAgPHA+WW91IGNhbiB0eXBlIGF3YXkgaW4gdGhlIG5leHQgaW5wdXQgdG8gc2VlIHRoYXQgdGhlIGZyb250IGVuZCBpcyBub3QgYmVpbmcgYmxvY2tlZCBhbmQgdGhlcmUgaXMgbm9cbiAgICAgICAgICAgIHN0dXR0ZXJpbmcgaW4gdGhlIGRlYnVnIGNvbnNvbGUuPC9wPlxuICAgICAgICAgICAgPGlucHV0IHN0eWxlPVwid2lkdGg6IDEwMCU7XCIvIGlkPVwic3R1dHRlci1jaGVja1wiPlxuXG4gICAgICAgICAgICA8aDI+VXNhZ2U8L2gyPlxuICAgICAgICAgICAgPHA+UGFzcyB0aGUgdGFzayBhbmQgaXRzIGFyZ3VtZW50cyB0byB0YXNrU3RhcnQoKS50aGVuKHJlc3BvbnNlID0+IHdhaXQgZm9yIHRoZSByZXNwb25zZSk7PC9wPlxuICAgICAgICAgICAgYFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUZXN0MDEzIGV4dGVuZHMgVGVzdENhc2VWaWV3XzEuVGVzdENhc2VWaWV3IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIobmV3IFRlc3RWaWV3TW9kZWwoKSk7XG4gICAgfVxuICAgIHRlc3RDYXNlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnVuY3Rpb24gYmlnQ2FsY3VsYXRpb24oaXRlciwgbXVsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByaW1lcyA9IGNhbGN1bGF0ZVByaW1lcyhpdGVyLCBtdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJpbWVzO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVByaW1lcyhpdGVyYXRpb25zLCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1zaGFkb3dlZC12YXJpYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmltZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IGkgKiAobXVsdGlwbGllciAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlzUHJpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IDI7IGMgPD0gTWF0aC5zcXJ0KGNhbmRpZGF0ZSk7ICsrYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUgJSBjID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltZXMucHVzaChjYW5kaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmltZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVG8gbWFrZSBpdCBleHRyYSBkaWZmaWN1bHQsIHdlJ2xsIGFsc28gc3BlbmQgQ1BVIG9uIHRoZSBjdXJyZW50IHRocmVhZCBsb2dnaW5nIHdoYXQgdGhlIHVzZXIgdHlwZXMuXG4gICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3R1dHRlci1jaGVjaycpLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKGV2dCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXZ0LmN1cnJlbnRUYXJnZXQudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxvZyhgVGVzdCAke3RoaXMudmlld01vZGVsLnRlc3ROdW1iZXJ9OiBUZXN0IHN0YXJ0YCk7XG4gICAgICAgICAgICBsZXQgY2FsYyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZHluID0gbmV3IEFwaV8xLkR5bmFtaWNXZWJXb3JrZXIoKTtcbiAgICAgICAgICAgIGR5bi50YXNrU3RhcnQoYmlnQ2FsY3VsYXRpb24sIDEwMDAsIDEwMDAwMDAwMDApLnRoZW4ocmVzcCA9PiB7XG4gICAgICAgICAgICAgICAgY2FsYyA9IHJlc3A7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXNwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZyhyZXNwLmxlbmd0aCArICcgcHJpbWVzIGNhbGN1bGF0ZWQnKTtcbiAgICAgICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIEFwaV8xLmFzc2VydChjYWxjLmxlbmd0aCA9PT0gMTAwMCwgJ0FsbCB0aGUgcHJpbWVzIHdlcmUgY2FsY3VsYXRlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKGBUZXN0ICR7dGhpcy52aWV3TW9kZWwudGVzdE51bWJlcn06IFRlc3Qgc3VjY2Vzc2Z1bGApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDEzID0gVGVzdDAxMztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVGVzdENhc2VWaWV3XzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZVZpZXdcIik7XG5jb25zdCBUZXN0Q2FzZVZpZXdNb2RlbF8xID0gcmVxdWlyZShcIi4vVGVzdENhc2VWaWV3TW9kZWxcIik7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgQ3NzU3R5bGVTaGVldF8xID0gcmVxdWlyZShcIi4uL3NyYy9Dc3MvQ3NzU3R5bGVTaGVldFwiKTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jbGFzcyBUZXN0Vmlld01vZGVsIGV4dGVuZHMgVGVzdENhc2VWaWV3TW9kZWxfMS5UZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6ICdKUyBDU1MgQ2xhc3NlcyAoRXhwZXJpbWVudGFsKScsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbkh0bWw6IGA8cD5IZXJlJ3MgYW5vdGhlciBleHBlcmltZW50YWwgbW9kZWwgdGhhdCB3aWxsIGJlIG9mIGxpbWl0ZWQgdXRpbGl0eSwgYnV0IGl0J3Mga2luZFxuICAgICAgICAgICAgb2YgbmVhdC4gSXQncyBtYWtpbmcgQ1NTIGNsYXNzZXMgKGFueSBydWxlcywgaW4gZmFjdCwgZXZlbiB0aG9zZSB0aGF0IGFyZW4ndCB1c2luZyBjbGFzcyBzZWxlY3RvcnMpIGFjdFxuICAgICAgICAgICAgbW9yZSBsaWtlIEpTIGNsYXNzZXMsIHdpdGggaW5oZXJpdGFuY2UgYW5kIHRyYWl0cy4gQmFzaWNhbGx5IHNpbWlsYXIgdG8gU0FTUy9TQ1NTIGV4Y2VwdCBhdCBydW50aW1lIChteVxuICAgICAgICAgICAgZmlyc3QgdmVyc2lvbiB1c2VkIFNDU1Mgc3ludGF4IGV2ZW4pLjwvcD5cblxuICAgICAgICAgICAgPHA+VGhpcyBpc24ndCB2ZXJ5IHVzZWZ1bCwgdGhlIHNhbWUgYXMgU0FTUyBpc24ndCB2ZXJ5IHVzZWZ1bC4gT2gsIEkga25vdyB0aGF0IGEgbnVtYmVyIG9mIHByb2plY3RzXG4gICAgICAgICAgICB1c2UgaXQsIGJ1dCB0aGF0IGRvZXNuJ3QgbWVhbiBpdCdzIHJlYWxseSB3b3J0aCBpdC4gVGhlIHByb2JsZW0gd2l0aCBDU1MgaXNuJ3QgdGhlIGxhY2sgb2YgaW5oZXJpdGFuY2UgLi4uXG4gICAgICAgICAgICBmb3Igc2ltcGxlIGtleS92YWx1ZSBjb2xsZWN0aW9ucywgY2xpcGJvYXJkIGluaGVyaXRhbmNlIGlzIGFubm95aW5nIGJ1dCBmdW5jdGlvbmFsLiBJdCBpc24ndCB0aGUgbGFjayBvZlxuICAgICAgICAgICAgdmFyaWFibGVzIC4uLiBDU1MgdmFyaWFibGVzIG5vdyBleGlzdC4gSXQgaXNuJ3QgdGhlIHdheSBzY29waW5nIHdhcyBkZWxldGVkIGZyb20gdGhlIHN0YW5kYXJkIC4uLiB0aGF0XG4gICAgICAgICAgICBjYW4gYmUgaGFja2VkIHRvZ2V0aGVyIHVzaW5nIHNlbGVjdG9ycyAuLi4gYnV0IGl0IGRvZXMgaHVydC48L3A+XG5cbiAgICAgICAgICAgIDxwPlRoZSBwcm9ibGVtIHdpdGggQ1NTIGlzIENTUy4gSXQncyBhIGZsYW1pbmcgdHJhaW53cmVjayBkdXJpbmcgdGhlIEhhcmQgUmFpbi4gTm8gYW1vdW50IG9mIHN1Z2FyIHdpbGwgbWFrZVxuICAgICAgICAgICAgdGhlIENTUyBsYXlvdXQgbW9kZWwgc3dlZXRlciB0aGFuIGEgaHVtYW4gd2FzdGUgcmVjeWNsaW5nIHBsYW50LiBUaGUgbW9zdCBwb3dlcmZ1bCB0b29sIC0tIHJlYWxseSB0aGUgb25seVxuICAgICAgICAgICAgdG9vbCAtLSB0aGF0IGhlbHBzIHdpdGggZGVhbGluZyB3aXRoIENTUyBpcyBhdHRpdHVkZS4gU3BlY2lmaWNhbGx5LCB0aGlzIGF0dGl0dWRlOiBcIml0IGxvb2tzIGNsb3NlIGVub3VnaC5cIjwvcD5cblxuICAgICAgICAgICAgPHA+QnV0IGl0IHdhcyBhIGZ1biBleHBlcmltZW50LiBFeGNlcHQgd2hlbiBJIGhhZCB0byBmaWdodCBidWdzIGluIFR5cGVTY3JpcHQgKHRoYXQgc3RpbGwgZXhpc3QgaW4gbmV3IHZlcnNpb25zIHNvXG4gICAgICAgICAgICBteSBOUE0gYnVpbGQgaXNzdWVzIGFyZW4ndCB0aGUgaXNzdWUgc3RyZXNzaW5nIG1lKS48L3A+XG5cbiAgICAgICAgICAgIDxoMj5Vc2FnZTwvaDI+XG4gICAgICAgICAgICA8cD5DcmVhdGUgY2xhc3NlcyBpbmhlcml0aW5nIGZyb20gQ3NzQ2xhc3MsIHdpdGggcHJvcGVydGllcyB0aGF0IG1hdGNoIHRoZSBjbGFzcyAob3Igb3RoZXIgcnVsZSkgQ1NTIHByb3BlcnRpZXMuIEluIG1vc3RcbiAgICAgICAgICAgIGNhc2VzIHRoZXNlIHdpbGwgbmVlZCB0byBiZSBxdW90ZWQuIFRoZWlyIHZhbHVlcyBjYW4gYmUgc3RyaW5ncywgaW5zdGFuY2VzIG9mIHRoZSBDc3NWYXJpYWJsZSBjbGFzcywgb3IgbmVzdGVkIHByb3BlcnRpZXMsXG4gICAgICAgICAgICB3aGljaCBhcmUgc2ltcGxlIHRleHQgbWFwcyAoZm9yIGV4YW1wbGUsIGZvbnQgPSB7IHdlaWdodDogXCJib2xkXCIgfSBpcyB0aGUgc2FtZSBhcyBzZXR0aW5nIFwiZm9udC13ZWlnaHRcIiA9IFwiYm9sZFwiKS4gXG4gICAgICAgICAgICBDYWxsIHJlbmRlciQoKSB0byBhZGQgdGhlIENTUyB0byB0aGUgcGFnZS48L3A+XG5cbiAgICAgICAgICAgIDxwPlNwZWNpYWwgcHJvcGVydGllcyBhbGwgZW5kIGluIHRoZSAkIGNoYXJhY3Rlci48L3A+XG4gICAgICAgICAgICA8Y29kZT48cHJlPlxuICAgICAgICAgICAgaW50ZXJmYWNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciQ6IHN0cmluZzsgICAgICAgICAgICAgIC8vIHNlbGVjdG9yIGZvciB0aGUgcnVsZS4gUmVxdWlyZWQuXG4gICAgICAgICAgICAgICAgbWVkaWEkPzogc3RyaW5nOyAgICAgICAgICAgICAgICAvLyBAbWVkaWEgZWxlbWVudFxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRQYXJlbnQkOiBIVE1MRWxlbWVudDsgLy8gQSA8c3R5bGU+IGVsZW1lbnQgaXMgY3JlYXRlZC4gVGhpcyBpcyB3aGVyZS4gRGVmYXVsdCBkb2N1bWVudC5oZWFkLlxuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXRJZCQ6IHN0cmluZzsgICAgICAgICAgLy8gVGhlIElEIG9mIHRoZSBzdHlsZSBlbGVtZW50IGNyZWF0ZWQuIEF1dG9nZW5lcmF0ZWQuXG4gICAgICAgICAgICAgICAgc2NvcGVFbGVtZW50JD86IEhUTUxFbGVtZW50OyAgICAvLyBTZXQgdGhpcyBpZiB5b3Ugd2FudCB0aGUgQ1NTIHRvIGFwcGx5IG9ubHkgdG8gYW4gZWxlbWVudCBvciBpdHMgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBleHRlbmRzJD86IFJ1bGVzQ2FuRXh0ZW5kIHwgUnVsZXNDYW5FeHRlbmRbXTsgICAvLyBJbmhlcml0IENTUyBmcm9tIHRoZXNlIGNsYXNzZXMuIEFsbG93cyBtdWx0aXBsZSBpbmhlcml0YW5jZS5cbiAgICAgICAgICAgICAgICBuZXN0ZWQkPzogUnVsZXNDYW5OZXN0IHwgUnVsZXNDYW5OZXN0W107ICAgICAgICAvLyBTZWUgdGhlICYgb3BlcmF0b3IgaW4gU0FTUy9MRVNTLlxuICAgICAgICAgICAgICAgIHJldmVydCQ6IGJvb2xlYW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldCB0byB0cnVlIGFzIGEgc2hvcnRjdXQgZm9yIFwiYWxsXCIgPSBcImluaXRpYWxcIlxuICAgICAgICAgICAgICAgIHJlbmRlciQoKTogdm9pZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBvciB1cGRhdGUgdGhlIDxzdHlsZT4gZWxlbWVudCwgYWRkaW5nIENTUyBzdHlsaW5nXG4gICAgICAgICAgICAgICAgcmVtb3ZlJCgpOiB2b2lkOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSA8c3R5bGU+IGVsZW1lbnQsIHJlbW92aW5nIENTUyBzdHlsaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA8L3ByZT48L2NvZGU+XG5cbiAgICAgICAgICAgIDxwPldoZW4gd3JpdGluZyB0aGUgY2xhc3MgYW5kIHVzaW5nIGluaXRpYWxpemVycywgcmVtZW1iZXIgdG8gdXNlIGVxdWFscyAoPSksIG5vdCBjb2xvbiAoOikuIFRoaXMgaXMgaW1wb3J0YW50LlxuICAgICAgICAgICAgUmVtZW1iZXIgdGhhdCB0aGlzIGlzIFR5cGVzY3JpcHQuIFwiY2xhc3MgQ0xTIHsgZm9vOiAnYmFyJyB9IGlzIHRvdGFsbHkgZGlmZmVyZW50IGZyb20gXCJ2YXIgQ0xTID0geyBmb286ICdiYXInIH0uXCIgSW4gdGhlXG4gICAgICAgICAgICBmaXJzdCBjYXNlLCBuZXcgb2JqZWN0cyBsb29rIGxpa2UgdGhpcyB7fSwgYW5kIHlvdXIgcmVzdWx0aW5nIENTUyBjbGFzcyBpcyBlbXB0eS48L3A+XG5cbiAgICAgICAgICAgIDxwPlRoZSBDc3NTdHlsZVNoZWV0IGlzIGEgY29sbGVjdGlvbiBvZiBDc3NSdWxlIG9iamVjdHMuIENzc1ZhcmlhYmxlIGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eS4gQ3NzSW5saW5lUnVsZSBpcyBhIHF1aWNrIGFuZFxuICAgICAgICAgICAgZGlydHkgd2F5IHRvIGNyZWF0ZSBhIENzc1J1bGUgaW5saW5lIGluIGNvZGUgd2l0aG91dCBjcmVhdGluZyBhIGNsYXNzLjwvcD5gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFRlc3QwMTQgZXh0ZW5kcyBUZXN0Q2FzZVZpZXdfMS5UZXN0Q2FzZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihuZXcgVGVzdFZpZXdNb2RlbCgpKTtcbiAgICB9XG4gICAgdGVzdENhc2UoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBEZW1vIHN0b3Jpbmcgc3R5bGVzIHNvbWV3aGVyZSBvdGhlciB0aGFuIHRoZSBIRUFEXG4gICAgICAgICAgICBjb25zdCByYW5kb21TdHlsZURpdiA9IEFwaV8xLmRpdih7IGlkOiAnc29tZXdoZXJlLWZvci10aGUtc3R5bGUnIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChyYW5kb21TdHlsZURpdik7XG4gICAgICAgICAgICBjb25zdCBzY29wZWREaXYgPSBBcGlfMS5kaXYoeyBpZDogJ3Njb3BlZCcsIGNsYXNzTmFtZTogJ2RpdnBhcmVudCcgfSk7XG4gICAgICAgICAgICBzY29wZWREaXYuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKCdIZWxsbyBXb3JsZCcsIHsgaWQ6ICdwYXJhJyB9KSkuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKCkpOyAvLyBkdW1teSBwIHRhZyBhdCBlbmRcbiAgICAgICAgICAgIHNjb3BlZERpdi5hcHBlbmRDaGlsZChBcGlfMS5hbmNob3IoJ1Rlc3QxJywgJ2h0dHBzOi8vd3d3Lmdvb2dsZS5jb20nLCB7IGlkOiAnYTEnIH0pKS5hcHBlbmRDaGlsZChBcGlfMS5wYXJhZ3JhcGgoKSk7IC8vIGR1bW15IHAgYXQgZW5kXG4gICAgICAgICAgICBzY29wZWREaXYuYXBwZW5kQ2hpbGQoQXBpXzEuYW5jaG9yKCdUZXN0MicsICdodHRwczovL3d3dy5nb29nbGUuY29tJywgeyBpZDogJ2EyJywgY2xhc3NOYW1lOiAnbmVzdGVkJyB9KSkuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKCkpO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5hcHBlbmRDaGlsZChzY29wZWREaXYpO1xuICAgICAgICAgICAgY29uc3QgY29sb3JWYXIgPSBuZXcgQXBpXzEuQ3NzVmFyaWFibGUoXCJwcmltYXJ5XCIsIFwiYmx1ZVwiKTtcbiAgICAgICAgICAgIGNsYXNzIEJvcmRlckJhc2VSdWxlIGV4dGVuZHMgQXBpXzEuQ3NzU2ltcGxlUnVsZSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJib3JkZXItc3R5bGVcIl0gPSBcInNvbGlkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQm9yZGVyQ29sb3JSdWxlIGV4dGVuZHMgQm9yZGVyQmFzZVJ1bGUge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiYm9yZGVyLWNvbG9yXCJdID0gXCJibGFja1wiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiXSA9IFwiMTBweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIERpdlJ1bGUgZXh0ZW5kcyBBcGlfMS5Dc3NSdWxlIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIocmFuZG9tU3R5bGVEaXYpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yJCA9IFwiZGl2XCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJjb2xvclwiXSA9IGNvbG9yVmFyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiZm9udC1zaXplXCJdID0gXCIyMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJmb250XCJdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBcImJvbGRcIiAvLyBEZW1vIG5lc3RlZCBwcm9wZXJ0aWVzOiBPbmx5IG9uZSBsZXZlbCBvZiBuZXN0aW5nIGlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRlbmRzJCA9IEJvcmRlckNvbG9yUnVsZTsgLy8gRGVtbyBcIm11bHRpcGxlIGluaGVyaXRhbmNlXCJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQkID0gTmVzdGVkUnVsZTsgLy8gRGVtbyBuZXN0ZWQgcnVsZXMvc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NvcGVFbGVtZW50JCA9IHNjb3BlZERpdjsgLy8gRGVtbyBmYWtlIHNjb3BpbmcgKHNob3VsZG4ndCBhZmZlY3QgYWxsIHRoZSBvdGhlciBkaXZzIG9uIHRoZSBwYWdlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIE5lc3RlZFJ1bGUgZXh0ZW5kcyBBcGlfMS5Dc3NSdWxlIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciQgPSBcIiYgLm5lc3RlZFwiOyAvLyBOb3RlIHRoZSBTQVNTL0xFU1MgYW1wZXJzYW5kIHRoYXQgZm9yY2VzIGEgc3BhY2UuIFlvdSBjb3VsZCBoYXZlIGFsc28gdXNlZCBcIiAubmVzdGVkXCIgYnV0IHRoYXQgd291bGQgbG9vayB3ZWlyZC5cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcInRleHQtZGVjb3JhdGlvblwiXSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNzc1J1bGUgPSBuZXcgRGl2UnVsZSgpLnJlbmRlciQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpdlN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjb3BlZERpdik7XG4gICAgICAgICAgICBjb25zdCB0ZXN0QXJlYVN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGVzdEFyZWEpO1xuICAgICAgICAgICAgY29uc3QgdGV4dFN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJhJykpO1xuICAgICAgICAgICAgY29uc3QgYTFzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYTEnKSk7XG4gICAgICAgICAgICBjb25zdCBhMnN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhMicpKTtcbiAgICAgICAgICAgIHRoaXMubG9nKCdCZWdpbm5pbmcgdGVzdHMuIFdhcm5pbmc6IHRoZXNlIHRlc3RzIGFyZSBiYXNlZCBvbiB0aGUgZGVmYXVsdCBzZXR1cCB3aGVyZSBJIGxpdmUuJyk7XG4gICAgICAgICAgICB0aGlzLmxvZygnVGhleSB3aWxsIGZhaWwgaW4gYnJvd3NlcnMgd2l0aCBkaWZmZXJlbnQgQ1NTIHNldHRpbmdzJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodGV4dFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdmb250LXNpemUnKSA9PT0gJzIwcHgnLCAnRGlyZWN0IHN0cmluZyBwcm9wZXJ0eSBpcyBhcHBsaWVkJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoZGl2U3R5bGVzLmdldFByb3BlcnR5VmFsdWUoXCJib3JkZXItY29sb3JcIikgPT09ICdyZ2IoMCwgMCwgMCknLCAnSW5oZXJpdGVkIHByb3BlcnR5IGlzIGFwcGxpZWQgKDEgbGV2ZWwgZGVlcCknKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydChkaXZTdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShcImJvcmRlci1zdHlsZVwiKSA9PT0gJ3NvbGlkJywgJ0luaGVyaXRlZCBwcm9wZXJ0eSBpcyBhcHBsaWVkICgyIGxldmVscyBkZWVwKScpO1xuICAgICAgICAgICAgQXBpXzEuYXNzZXJ0KGEyc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3RleHQtZGVjb3JhdGlvbicpLmluY2x1ZGVzKCdub25lJyksICdOZXN0ZWQgcnVsZSBpcyBhcHBsaWVkJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQodGV4dFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdjb2xvcicpID09PSAncmdiKDAsIDAsIDI1NSknLCAnQ1NTIHZhcmlhYmxlIChjdXN0b20gcHJvcGVydHkpIGlzIGFwcGxpZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh0ZXh0U3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQtd2VpZ2h0JykgPT09ICc3MDAnLCAnTmVzdGVkIHByb3BlcnR5IGlzIGFwcGxpZWQnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh0ZXN0QXJlYVN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKFwiYm9yZGVyLXN0eWxlXCIpID09PSAnbm9uZScsICdTY29wZWQgc3R5bGUgc3RheXMgaW4gc2NvcGVkIGVsZW1lbnQnKTtcbiAgICAgICAgICAgIGNsYXNzIEFsbFJlZCBleHRlbmRzIEFwaV8xLkNzc1J1bGUge1xuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdG9yJCA9ICdwYWdlLXJvdXRlcic7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbJ2NvbG9yJ10gPSAncmVkJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBXYXZ5R3JhdnkgZXh0ZW5kcyBBcGlfMS5Dc3NSdWxlIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciQgPSAnaDEnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzWyd0ZXh0LWRlY29yYXRpb24nXSA9ICd3YXZ5IHVuZGVybGluZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBzdHlsZSBzaGVldCBpcyBsaXR0bGUgbW9yZSB0aGFuIGEgY29sbGVjdGlvbiBvZiBzdHlsZSBydWxlc1xuICAgICAgICAgICAgY29uc3Qgc2hlZXQxID0gbmV3IENzc1N0eWxlU2hlZXRfMS5Dc3NTdHlsZVNoZWV0KFtBbGxSZWQsIFdhdnlHcmF2eV0sIHJhbmRvbVN0eWxlRGl2KTtcbiAgICAgICAgICAgIHNoZWV0MS5yZW5kZXIoKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoMScpKS5nZXRQcm9wZXJ0eVZhbHVlKCdjb2xvcicpID09PSAncmdiKDI1NSwgMCwgMCknLCAnU3R5bGVzIGluIHN0eWxlc2hlZXQgYXJlIGFwcGxpZWQgYW5kIHRoZXJlIGlzIG5vIHNjb3BpbmcnKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoMScpKS5nZXRQcm9wZXJ0eVZhbHVlKCd0ZXh0LWRlY29yYXRpb24nKS5pbmNsdWRlcygnd2F2eScpLCAnTXVsdGlwbGUgc3R5bGVzIGluIHN0eWxlc2hlZXQgYXJlIGFwcGxpZWQnKTtcbiAgICAgICAgICAgIHNoZWV0MS5yZW1vdmUoKTtcbiAgICAgICAgICAgIEFwaV8xLmFzc2VydCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdoMScpKS5nZXRQcm9wZXJ0eVZhbHVlKCdjb2xvcicpID09PSAncmdiKDAsIDAsIDApJywgJ1N0eWxlcyBpbiBzdHlsZXNoZWV0IGFyZSByZW1vdmVkJyk7XG4gICAgICAgICAgICBBcGlfMS5hc3NlcnQoIXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2gxJykpLmdldFByb3BlcnR5VmFsdWUoJ3RleHQtZGVjb3JhdGlvbicpLmluY2x1ZGVzKCd3YXZ5JyksICdNdWx0aXBsZSBzdHlsZXMgaW4gc3R5bGVzaGVldCBhcmUgcmVtb3ZlZCcpO1xuICAgICAgICAgICAgLy8gRmluYWxseSBhIG1vcmUgY29tcGxleCB0ZXN0LiBUaGlzIHJlc2VtYmxlcyBzb21ldGhpbmcgeW91IG1pZ2h0IGFjdHVhbGx5IHVzZSB0aGlzIGZvci5cbiAgICAgICAgICAgIGNsYXNzIEJ0bkJhc2UgZXh0ZW5kcyBBcGlfMS5Dc3NSdWxlIHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciQgPSBcIi5idG5cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImRpc3BsYXlcIl0gPSBcImlubGluZS1ibG9ja1wiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiZm9udC13ZWlnaHRcIl0gPSBcIjUwMFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1widGV4dC1hbGlnblwiXSA9IFwiY2VudGVyXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ3aGl0ZS1zcGFjZVwiXSA9IFwibm93cmFwXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ2ZXJ0aWNhbC1hbGlnblwiXSA9IFwibWlkZGxlXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ1c2VyLXNlbGVjdFwiXSA9IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wiYm9yZGVyXCJdID0gXCIxcHggc29saWQgdHJhbnNwYXJlbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcInBhZGRpbmdcIl0gPSBcIi40Njg3NXJlbSAxcmVtXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJmb250LXNpemVcIl0gPSBcIjFyZW1cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImxpbmUtaGVpZ2h0XCJdID0gXCIxLjVcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImJvcmRlci1yYWRpdXNcIl0gPSBcIi4xMjVyZW1cIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcInRyYW5zaXRpb25cIl0gPSBcImNvbG9yIDAuMTVzIGVhc2UtaW4tb3V0LGJhY2tncm91bmQtY29sb3IgLjE1cyBlYXNlLWluLW91dCxib3JkZXItY29sb3IgMC4xNXMgZWFzZS1pbi1vdXQsYm94LXNoYWRvdyAuMTVzIGVhc2UtaW4tb3V0XCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkJCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcGlfMS5Dc3NJbmxpbmVSdWxlKFwiJjpob3ZlciwgJjpob3ZlclwiLCB7IFwidGV4dC1kZWNvcmF0aW9uXCI6IFwibm9uZVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFwaV8xLkNzc0lubGluZVJ1bGUoXCImOmZvY3VzLCAmLmZvY3VzXCIsIHsgXCJvdXRsaW5lXCI6IFwibm9uZVwiLCBcImJveC1zaGFkb3dcIjogXCJub25lXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQXBpXzEuQ3NzSW5saW5lUnVsZShcIiY6ZGlzYWJsZWQsICYuZGlzYWJsZWRcIiwgeyBcIm9wYWNpdHlcIjogXCIuNjVcIiwgXCJib3gtc2hhZG93XCI6IFwibm9uZVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFwaV8xLkNzc0lubGluZVJ1bGUoXCImOm5vdCg6ZGlzYWJsZWQpOm5vdCguZGlzYWJsZWQpXCIsIHsgY3Vyc29yOiBcInBvaW50ZXJcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGFzcyBCdG5QcmltYXJ5IGV4dGVuZHMgQXBpXzEuQ3NzUnVsZSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IkID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImNvbG9yXCJdID0gXCIjZmZmXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCIjZGYzODJjXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJib3JkZXItY29sb3JcIl0gPSBcIiNkZjM4MmNcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImJveC1zaGFkb3dcIl0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFwaV8xLkNzc0lubGluZVJ1bGUoXCImOmhvdmVyXCIsIHsgXCJjb2xvclwiOiBcIiNmZmZcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiI2YyMjExMlwiLCBcImJvcmRlci1jb2xvclwiOiBcIiNlYTFjMGRcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcGlfMS5Dc3NJbmxpbmVSdWxlKFwiJi5mb2N1c1wiLCB7IFwiYm94LXNoYWRvd1wiOiBcIm5vbmUsIDAgMCAwIC4ycmVtIHJnYmEoMjQ0LDY3LDU0LC41KVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFwaV8xLkNzc0lubGluZVJ1bGUoXCImLmRpc2FibGVkLCAmOmRpc2FibGVkXCIsIHsgXCJjb2xvclwiOiBcIiNmZmZcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiI2RmMzgyY1wiLCBcImJvcmRlci1jb2xvclwiOiBcIiNkZjM4MmNcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcGlfMS5Dc3NJbmxpbmVSdWxlKFwiJjpub3QoOmRpc2FibGVkKTpub3QoLmRpc2FibGVkKS5hY3RpdmUsICY6bm90KDpkaXNhYmxlZCk6bm90KC5kaXNhYmxlZCk6YWN0aXZlXCIsIHsgXCJjb2xvclwiOiBcIiNmZmZcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiI2VhMWMwZFwiLCBcImJvcmRlci1jb2xvclwiOiBcIiNkZWIxYjBjXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQXBpXzEuQ3NzSW5saW5lUnVsZShcIiY6bm90KDpkaXNhYmxlZCk6bm90KC5kaXNhYmxlZCkuYWN0aXZlOmZvY3VzLCAmOm5vdCg6ZGlzYWJsZWQpOm5vdCguZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c1wiLCB7IFwiYm94LXNoYWRvd1wiOiBcIm5vbmUsMCAwIDAgLjJyZW0gcmdiYSgyNDQsNjcsNTQsLjUpXCIgfSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xhc3MgQnRuU2Vjb25kYXJ5IGV4dGVuZHMgQXBpXzEuQ3NzUnVsZSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IkID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImNvbG9yXCJdID0gXCIjZmZmXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdID0gXCIjYWVhNzlmXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJib3JkZXItY29sb3JcIl0gPSBcIiNhZWE3OWZcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcImJveC1zaGFkb3dcIl0gPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXN0ZWQkID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEFwaV8xLkNzc0lubGluZVJ1bGUoXCImOmhvdmVyXCIsIHsgXCJjb2xvclwiOiBcIiNmZmZcIiwgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiIzVhNjI2OFwiLCBcImJvcmRlci1jb2xvclwiOiBcIiM1NDViNjJcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcGlfMS5Dc3NJbmxpbmVSdWxlKFwiJi5mb2N1c1wiLCB7IFwiYm94LXNoYWRvd1wiOiBcIm5vbmUsIDAgMCAwIC4ycmVtIHJnYmEoMjA4LDclLDQ2JSwuNSlcIiB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBBcGlfMS5Dc3NJbmxpbmVSdWxlKFwiJi5kaXNhYmxlZCwgJjpkaXNhYmxlZFwiLCB7IFwiY29sb3JcIjogXCIjZmZmXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiNhZWE3OWZcIiwgXCJib3JkZXItY29sb3JcIjogXCIjYWVhNzlmXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQXBpXzEuQ3NzSW5saW5lUnVsZShcIiY6bm90KDpkaXNhYmxlZCk6bm90KC5kaXNhYmxlZCkuYWN0aXZlLCAmOm5vdCg6ZGlzYWJsZWQpOm5vdCguZGlzYWJsZWQpOmFjdGl2ZVwiLCB7IFwiY29sb3JcIjogXCIjZmZmXCIsIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcIiM1NDViNjJcIiwgXCJib3JkZXItY29sb3JcIjogXCIjNGU1NTViXCIgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgQXBpXzEuQ3NzSW5saW5lUnVsZShcIiY6bm90KDpkaXNhYmxlZCk6bm90KC5kaXNhYmxlZCkuYWN0aXZlOmZvY3VzLCAmOm5vdCg6ZGlzYWJsZWQpOm5vdCguZGlzYWJsZWQpOmFjdGl2ZTpmb2N1c1wiLCB7IFwiYm94LXNoYWRvd1wiOiBcIm5vbmUsMCAwIDAgLjJyZW0gcmdiYSgyMDgsNyUsNDYlLC41KVwiIH0pLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzIEJ0bkNsYXNzIGV4dGVuZHMgQnRuQmFzZSB7XG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoY2xhc3NOYW1lLCBwcmltYXJ5ID0gdHJ1ZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IkID0gJy4nICsgY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZHMkID0gdGhpcy5leHRlbmRzJCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZXh0ZW5kcyQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZHMkID0gW3RoaXMuZXh0ZW5kcyRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZHMkLnB1c2gobmV3IEJ0blByaW1hcnkoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dGVuZHMkLnB1c2gobmV3IEJ0blNlY29uZGFyeSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyBzYXkgSSBpbXBvcnRlZCB0aGUgQnRuQ2xhc3MgZnJvbSBzb21lIG1vZHVsZS5cbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvblRlc3QgPSB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmRpdigpKTtcbiAgICAgICAgICAgIGNvbnN0IGJ0blByaW1hcnkgPSBuZXcgQnRuQ2xhc3MoXCJidG4tcHJpbWFyeVwiLCB0cnVlLCBidXR0b25UZXN0KS5yZW5kZXIkKCk7XG4gICAgICAgICAgICBjb25zdCBidG5TZWNvbmRhcnkgPSBuZXcgQnRuQ2xhc3MoXCJidG4tc2Vjb25kYXJ5XCIsIGZhbHNlLCBidXR0b25UZXN0KS5yZW5kZXIkKCk7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUh0bWwoYDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuLXByaW1hcnlcIj5PazwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0bi1zZWNvbmRhcnlcIj5Ob3QgT2s8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICBgKSk7XG4gICAgICAgICAgICBjb25zdCBhbGxUaGVSdWxlcyA9IEFwaV8xLmdldENzc1J1bGVzSW5FbGVtZW50KGJ1dHRvblRlc3QpO1xuICAgICAgICAgICAgdGhpcy5sb2coYWxsVGhlUnVsZXMpO1xuICAgICAgICAgICAgdGhpcy5sb2coYFRlc3QgJHt0aGlzLnZpZXdNb2RlbC50ZXN0TnVtYmVyfTogVGVzdCBzdWNjZXNzZnVsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJFUlJPUjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0MDE0ID0gVGVzdDAxNDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXBpXzEgPSByZXF1aXJlKFwiLi4vc3JjL0FwaVwiKTtcbmNsYXNzIENvbnNvbGVWaWV3TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm91dHB1dCA9IEFwaV8xLk9ic2VydmFibGVQcm94eS5wcm94aW1hdGUoW10pO1xuICAgIH1cbn1cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtY2xhc3Nlcy1wZXItZmlsZVxuY2xhc3MgQ29uc29sZVZpZXcgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBpbm5lckh0bWw6IGBcbiAgICAgICAgICAgICAgICA8aDI+TG9nPC9oMj5cbiAgICAgICAgICAgICAgICA8ZGl2IGlkPVwiY29uc29sZUxvZ1wiIDpsb29wPVwib3V0cHV0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgOml0ZW0+PGktdj4uPC9pLXY+PC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+YFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwgPSBuZXcgQ29uc29sZVZpZXdNb2RlbCgpO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSBuZXcgQXBpXzEuQm91bmRDb21wb25lbnQodGhpcy52aWV3TW9kZWwsIHtcbiAgICAgICAgICAgIHBhcmVudDogdGhpcy5jb250ZW50LFxuICAgICAgICAgICAgc2VsZWN0b3I6ICcjY29uc29sZUxvZycsXG4gICAgICAgICAgICBvYnNlcnZlQWxsVmlld01vZGVsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgdG8gdGhlIGRldiBjb25zb2xlIGJ1dCBhbHNvIHRvIHRoZSBvdXRwdXQgb2JzZXJ2YWJsZSwgd2hlcmUgaXQgY2FuIGJlIHVzZWQgZm9yIGRpc3BsYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHRoaW5nXG4gICAgICogQG1lbWJlcm9mIENvbnNvbGVWaWV3XG4gICAgICovXG4gICAgbG9nKHRoaW5nKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaW5nKTtcbiAgICAgICAgdGhpcy52aWV3TW9kZWwub3V0cHV0LnB1c2goY2xlYW4odGhpbmcpKTtcbiAgICAgICAgZnVuY3Rpb24gY2xlYW4odmFsKSB7XG4gICAgICAgICAgICBpZiAoQXBpXzEuaXNOb25lKHZhbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNvbnNvbGVWaWV3ID0gQ29uc29sZVZpZXc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIHRzbGludDpkaXNhYmxlOm1heC1jbGFzc2VzLXBlci1maWxlXG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY29uc3QgVGVzdENhc2VDb25zb2xlXzEgPSByZXF1aXJlKFwiLi9UZXN0Q2FzZUNvbnNvbGVcIik7XG5jbGFzcyBUZXN0Q2FzZVZpZXcgZXh0ZW5kcyBBcGlfMS5Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZpZXdNb2RlbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXdNb2RlbCA9IHZpZXdNb2RlbDtcbiAgICAgICAgLy8gTXVsdGlwbGUgd2F5cyBvZiBhcHBlbmRpbmcgbmV3IGNvbXBvbmVudHNcbiAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChuZXcgVGVzdEhlYWRlcih2aWV3TW9kZWwpKTtcbiAgICAgICAgdGhpcy5jb25zb2xlID0gbmV3IFRlc3RDYXNlQ29uc29sZV8xLkNvbnNvbGVWaWV3KCkuYXBwZW5kVG9QYXJlbnQodGhpcyk7XG4gICAgICAgIHRoaXMudGVzdEFyZWFIZWFkZXIgPSB0aGlzLmFwcGVuZENoaWxkKEFwaV8xLmNyZWF0ZUVsZW1lbnQoQXBpXzEuZWxlbWVudFR5cGUuSFRNTEhlYWRpbmcyRWxlbWVudCwge1xuICAgICAgICAgICAgaW5uZXJIVE1MOiAnVGVzdCBBcmVhJyxcbiAgICAgICAgICAgIHN0eWxlOiAnY3Vyc29yOiBwb2ludGVyOydcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnRlc3RBcmVhID0gdGhpcy5hcHBlbmRDaGlsZChBcGlfMS5kaXYoJycsIHsgaWQ6ICd0ZXN0QXJlYScgfSkpO1xuICAgICAgICAvLyBOZWVkIHRvIGFkZCBhIHNtYWxsIGRlbGF5LCBiZWNhdXNlIHRoaXMgY29tcG9uZW50IGlzIGFkZGVkIHRvIHRoZSBET00gYnkgdGhlIFBhZ2VSb3V0ZXIgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gYWZ0ZXIgY29uc3RydWN0aW9uLiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgpLCB1c2VkIGluIG1hbnkgdGVzdCBjYXNlcywgd29uJ3QgZmluZCBhbnl0aGluZyB1bnRpbCBhZnRlclxuICAgICAgICAvLyB0aGUgY2xvc2luZyBicmFjZS5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnRlc3RDYXNlKCksIDE1MCk7XG4gICAgICAgIC8vIE1ha2UgdGhlIHRlc3QgYXJlYSBjb2xsYXBzYWJsZSBhbmQgY29sbGFwc2UgaXQgYWZ0ZXIgM3MuXG4gICAgICAgIHRoaXMudGVzdEFyZWFIZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnRvZ2dsZVRlc3RBcmVhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnRvZ2dsZUlkID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLnRvZ2dsZVRlc3RBcmVhKCksIDMwMDApO1xuICAgIH1cbiAgICBsb2codGhpbmcpIHtcbiAgICAgICAgdGhpcy5jb25zb2xlLmxvZyh0aGluZyk7XG4gICAgfVxuICAgIHRvZ2dsZVRlc3RBcmVhKGV2dCkge1xuICAgICAgICAvLyBEb24ndCB0b2dnbGUgYWZ0ZXIgdXNlciBjbGlja3MgdGhlIGhlYWRlclxuICAgICAgICBpZiAoZXZ0ICYmIHRoaXMudG9nZ2xlSWQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvZ2dsZUlkKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGVzdEFyZWEuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhSGVhZGVyLnN0eWxlLmNvbG9yID0gJ2xpZ2h0Z3JheSc7XG4gICAgICAgICAgICB0aGlzLnRlc3RBcmVhSGVhZGVyLmlubmVySFRNTCA9ICdUZXN0IEFyZWEgKGhpZGRlbiknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMudGVzdEFyZWFIZWFkZXIuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgICAgICAgICAgdGhpcy50ZXN0QXJlYUhlYWRlci5pbm5lckhUTUwgPSAnVGVzdCBBcmVhJztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGVzdENhc2VWaWV3ID0gVGVzdENhc2VWaWV3O1xuY2xhc3MgVGVzdEhlYWRlciBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3Iodm0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHZtLm5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoQXBpXzEucGFyYWdyYXBoKGA8aDE+VGVzdCAke3ZtLnRlc3ROdW1iZXJ9OiAke3ZtLm5hbWV9PC9oMT5gKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZtLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKEFwaV8xLnNwYW4odm0uZGVzY3JpcHRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVGVzdEhlYWRlciA9IFRlc3RIZWFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFwaV8xID0gcmVxdWlyZShcIi4uL3NyYy9BcGlcIik7XG5jbGFzcyBUZXN0Q2FzZVZpZXdNb2RlbCB7XG4gICAgY29uc3RydWN0b3IoeyBuYW1lLCBkZXNjcmlwdGlvbkh0bWwgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IEFwaV8xLmVzY2FwZUh0bWwobmFtZSk7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbkh0bWw7XG4gICAgICAgIHRoaXMudGVzdE51bWJlciA9IEFwaV8xLlBhZ2VSb3V0ZXIucGFyYW1zLmdldCgnaWQnKSB8fCAnPyc7XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0Q2FzZVZpZXdNb2RlbCA9IFRlc3RDYXNlVmlld01vZGVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcGlfMSA9IHJlcXVpcmUoXCIuLi9zcmMvQXBpXCIpO1xuY2xhc3MgVGVzdGJlbmNoVmlldyBleHRlbmRzIEFwaV8xLkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGlkOiAndGVzdC1iZW5jaCcsXG4gICAgICAgICAgICBpbm5lckh0bWw6IGA8ZGl2PlxuICAgICAgICAgICAgICAgIDxhIGhyZWY9XCIjXCIgY2xhc3M9XCJ0ZXN0LWxpbmtcIj5QcmV2aW91cyBUZXN0PC9hPlxuICAgICAgICAgICAgICAgIDxzcGFuIGlkPVwidGVzdEhlYWRlclwiPlRlc3QgIzA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cInRlc3QtbGlua1wiIGRhdGEtbmV4dD1cIjFcIj5OZXh0IFRlc3Q8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgPGxheW91dC1ib2R5PjwvbGF5b3V0LWJvZHk+YFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGRyID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0SGVhZGVyJyk7XG4gICAgICAgIGlmIChoZHIpIHtcbiAgICAgICAgICAgIGhkci5pbm5lckhUTUwgPSBcIlRlc3QgI1wiICsgQXBpXzEuUGFnZVJvdXRlci5tYXRjaGVkUm91dGUucGFyYW1zLmdldCgnaWQnKSB8fCAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBwYWdlciB0byBnbyB0aHJvdWdoIHRlc3RzLlxuICAgICAgICBmb3IgKGNvbnN0IGwgb2YgdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy50ZXN0LWxpbmsnKSkge1xuICAgICAgICAgICAgbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZ290b05leHRUZXN0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdvdG9OZXh0VGVzdChldnQpIHtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IGlkID0gTnVtYmVyKEFwaV8xLlBhZ2VSb3V0ZXIubWF0Y2hlZFJvdXRlLnBhcmFtcy5nZXQoJ2lkJykgfHwgJzAnKTtcbiAgICAgICAgbGV0IG5leHRpZDtcbiAgICAgICAgaWYgKGV2dC5jdXJyZW50VGFyZ2V0LmRhdGFzZXQubmV4dCkge1xuICAgICAgICAgICAgbmV4dGlkID0gaWQgKyAxO1xuICAgICAgICAgICAgLy8gQXQgdGhlIG1vbWVudCwgdGhlcmUncyBleGFjdGx5IG9uZSByb3V0ZSBwZXIgdGVzdCwgc28gd2UgY2FuIGNoZWFwbHkga25vdyB3ZSdyZSBhdCB0aGUgZW5kXG4gICAgICAgICAgICAvLyBldmVuIHdpdGhvdXQgYW55IGNvbmZpZ3VyYXRpb24gZm9yIHRoZSB0ZXN0cyBiZWluZyBpbiB0aGlzIGNsYXNzLiBUaGlzIGlzIGEgY2hlYXQsIHRob3VnaCxcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgY291bGQgZWFzaWx5IGhhdmUgYWRkZWQgc29tZSBvdGhlciByb3V0ZXMuXG4gICAgICAgICAgICBpZiAobmV4dGlkID49IEFwaV8xLlBhZ2VSb3V0ZXIuYWxsUm91dGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHRpZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0aWQgPSBpZCAtIDE7XG4gICAgICAgICAgICBpZiAobmV4dGlkIDwgMCkge1xuICAgICAgICAgICAgICAgIG5leHRpZCA9IEFwaV8xLlBhZ2VSb3V0ZXIuYWxsUm91dGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGRyID0gdGhpcy5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoJyN0ZXN0SGVhZGVyJyk7XG4gICAgICAgIGlmIChoZHIpIHtcbiAgICAgICAgICAgIGhkci5pbm5lckhUTUwgPSBcIlRlc3QgI1wiICsgbmV4dGlkO1xuICAgICAgICB9XG4gICAgICAgIEFwaV8xLlBhZ2VSb3V0ZXIucm91dGUoJ3Rlc3QvJyArIG5leHRpZCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXN0YmVuY2hWaWV3ID0gVGVzdGJlbmNoVmlldztcbiJdfQ==
